/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BitqueryBigInt: { input: any; output: any; }
  /**
   * Represents fractional signed whole numeric values.
   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BitqueryDecimalNumber: { input: any; output: any; }
  /**
   * Represents fractional signed whole numeric values.
   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BitqueryDecimalNumberAsDiv: { input: any; output: any; }
  /** An ISO 8601-encoded date */
  BitqueryISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  BitqueryISO8601DateTime: { input: any; output: any; }
  /** A JSON Value */
  JSON: { input: any; output: any; }
};

/** Account */
export type BitqueryAccount = {
  /** Account ID */
  id: Scalars['String']['output'];
  /** Account number, the equivalent of a human-friendly public key */
  num: Scalars['Int']['output'];
  /** Realm number  */
  realmId: Scalars['Int']['output'];
  /** Shard number */
  shardId: Scalars['Int']['output'];
};

/** Solana Action */
export type BitqueryAction = {
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type BitqueryActionEnum =
  /** Add Quantity */
  | 'addQuantity'
  /** Burn */
  | 'burn'
  /** Mint */
  | 'create'
  /** Fee */
  | 'fee'
  /** Mint */
  | 'localMint'
  /** Transaction */
  | 'transaction'
  /** Transfer */
  | 'transfer';

/** Select by action */
export type BitqueryActionSelector = {
  /** Action in the list */
  in?: InputMaybe<Array<BitqueryActionEnum>>;
  /** Action is */
  is?: InputMaybe<BitqueryActionEnum>;
  /** Action not */
  not?: InputMaybe<BitqueryActionEnum>;
  /** Action not in the list */
  notIn?: InputMaybe<Array<BitqueryActionEnum>>;
};

export type BitqueryActiveAddress =
  /** Address */
  | 'address';

export type BitqueryActiveAddressUniq =
  /** Address */
  | 'address';

/** ActivePeriod */
export type BitqueryActivePeriod = {
  /** Billing day */
  billingDay: Scalars['Int']['output'];
  /** Period ends at */
  ends: BitqueryUtilitiesDate;
  /** Is blocked */
  isBlocked: Scalars['Boolean']['output'];
  /** Is paid */
  isPaid: Scalars['Boolean']['output'];
  /** Is points consumed */
  isPointsConsumed: Scalars['Boolean']['output'];
  /** Is spent */
  isSpent: Scalars['Boolean']['output'];
  /** Total available points */
  points: Scalars['BitqueryBigInt']['output'];
  /** Remaining points */
  pointsRemaining: Scalars['BitqueryBigInt']['output'];
  /** Period starts at */
  starts: BitqueryUtilitiesDate;
};

/** Blockchain address */
export type BitqueryAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
};

/** Address selector */
export type BitqueryAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Address selector */
export type BitqueryAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
};

/** Address with statistics */
export type BitqueryAddressStatDimension = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** First active */
  firstActive?: Maybe<BitqueryDateTime>;
  /** Inbound transactions */
  inboundTransactions?: Maybe<Scalars['Int']['output']>;
  /** Inflows */
  inflows?: Maybe<Scalars['Float']['output']>;
  /** Last active */
  lastActive?: Maybe<BitqueryDateTime>;
  /** Outbound transactions */
  outboundTransactions?: Maybe<Scalars['Int']['output']>;
  /** Outflows */
  outflows?: Maybe<Scalars['Float']['output']>;
  /** Unique days with transfers */
  uniqueDaysWithTransfers?: Maybe<Scalars['Int']['output']>;
  /** Unique receivers */
  uniqueReceivers?: Maybe<Scalars['Int']['output']>;
  /** Unique senders */
  uniqueSenders?: Maybe<Scalars['Int']['output']>;
};


/** Address with statistics */
export type BitqueryAddressStatDimensionBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Blockchain account with address and type */
export type BitqueryAddressWithAccount = {
  /** Account ID */
  account: Scalars['String']['output'];
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Account type */
  type: Scalars['String']['output'];
};

/** Algorand Blockchain */
export type BitqueryAlgorand = {
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryAlgorandAddressInfo>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryAlgorandArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryAlgorandBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryAlgorandCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryAlgorandSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryAlgorandTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryAlgorandTransfers>>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandArgumentFilter>>;
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandBlocksArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandSmartContractCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryAlgorandTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Algorand Blockchain */
export type BitqueryAlgorandTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryAlgorandTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfo = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Created Assets */
  createdAssets?: Maybe<Array<BitqueryAlgorandCreatedAssets>>;
  /** Current pending rewards */
  pendingRewards?: Maybe<Scalars['Float']['output']>;
  /** Current rewards */
  rewards?: Maybe<Scalars['Float']['output']>;
  /** Current round */
  round?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryAlgorandSmartContract>;
  /** Current status */
  status?: Maybe<Scalars['String']['output']>;
  /** Total amount of created apps */
  totalCreatedApps?: Maybe<Scalars['Int']['output']>;
  /** Total amount of created assets */
  totalCreatedAssets?: Maybe<Scalars['Int']['output']>;
};


/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfoPendingRewardsArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Address detailed information for Algorand network */
export type BitqueryAlgorandAddressInfoRewardsArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

export type BitqueryAlgorandArgumentFilter = {
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArguments = {
  any?: Maybe<Scalars['String']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  argindex: Scalars['Int']['output'];
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  genesisHash64?: Maybe<Scalars['String']['output']>;
  genesisId?: Maybe<Scalars['String']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryAlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<BitqueryAlgorandTxType>;
  /** The Value of argument */
  value?: Maybe<Scalars['String']['output']>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsAnyArgs = {
  of: BitqueryAlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsCountArgs = {
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsCountBigIntArgs = {
  argindex?: InputMaybe<BitqueryArgumentIndexSelector>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  caller?: InputMaybe<Array<BitqueryAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryAddressSelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandArgumentsMeasureable>;
  of: BitqueryAlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandArgumentsMeasureable>;
  of: BitqueryAlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsTxSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsTxTypeArgs = {
  txType?: InputMaybe<Array<BitqueryAlgorandTxType>>;
};


/** Arguments of Smart Contract Calls */
export type BitqueryAlgorandArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export type BitqueryAlgorandArgumentsMeasureable =
  /** Argument index */
  | 'argument_index'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

export type BitqueryAlgorandBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocks = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  currentProtocol?: Maybe<Scalars['String']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  frac: Scalars['BitqueryBigInt']['output'];
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  nextProtocol?: Maybe<Scalars['String']['output']>;
  nextProtocolApprovals?: Maybe<Scalars['BitqueryBigInt']['output']>;
  nextProtocolSwitchOn?: Maybe<Scalars['BitqueryBigInt']['output']>;
  nextProtocolVoteBefore?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Previous block hash */
  previousBlockHash: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryAddress>;
  rate?: Maybe<Scalars['Float']['output']>;
  reward?: Maybe<Scalars['Float']['output']>;
  seed?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  txnRoot: Scalars['String']['output'];
  upgradeApprove?: Maybe<Scalars['Int']['output']>;
  upgradePropose?: Maybe<Scalars['String']['output']>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksAnyArgs = {
  of: BitqueryAlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandBlocksMeasureable>;
  of: BitqueryAlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandBlocksMeasureable>;
  of: BitqueryAlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksProposerArgs = {
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksRateArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currentProtocol?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nextProtocol?: InputMaybe<BitqueryStringIdSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type BitqueryAlgorandBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryAlgorandBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Block Reward */
  | 'block_reward'
  /** Date */
  | 'date'
  /** Next protocol approvals */
  | 'next_protocol_approvals'
  /** Block Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type BitqueryAlgorandBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique proposer count */
  | 'proposers';

export type BitqueryAlgorandCallsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

/** Coinpath */
export type BitqueryAlgorandCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValue>;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryAlgorandCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Algorand created assets */
export type BitqueryAlgorandCreatedAssets = {
  /** Creator */
  creator?: Maybe<Scalars['String']['output']>;
  /** Decimals */
  decimals?: Maybe<Scalars['Int']['output']>;
  /** Asset Index */
  index?: Maybe<Scalars['Int']['output']>;
  /** Manager */
  manager?: Maybe<Scalars['String']['output']>;
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
  /** Reserve */
  reserve?: Maybe<Scalars['String']['output']>;
  /** symbol */
  symbol?: Maybe<Scalars['String']['output']>;
  /** URL */
  url?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in Algorand blockchain.
 *   Currency is selected by asset ID. To select ALGO use ID=0
 */
export type BitqueryAlgorandCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type BitqueryAlgorandNetwork =
  /** Algorand Mainnet (ALGO) */
  | 'algorand'
  /** Algorand Betanet */
  | 'algorand_betanet'
  /** Algorand Testnet */
  | 'algorand_testnet';

/** Algorand smart contract */
export type BitqueryAlgorandSmartContract = {
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract byte code */
  bytecode?: Maybe<Scalars['String']['output']>;
  /** Smart Contract Deassembled source code */
  source?: Maybe<Scalars['String']['output']>;
};

export type BitqueryAlgorandSmartContractCallFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCalls = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Fee used in transaction call */
  fee?: Maybe<Scalars['Float']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  genesisHash64?: Maybe<Scalars['String']['output']>;
  genesisId?: Maybe<Scalars['String']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryAlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<BitqueryAlgorandTxType>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsAnyArgs = {
  of: BitqueryAlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandCallsMeasureable>;
  of: BitqueryAlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandCallsMeasureable>;
  of: BitqueryAlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsTxSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryAlgorandSmartContractCallsTxTypeArgs = {
  txType?: InputMaybe<Array<BitqueryAlgorandTxType>>;
};

export type BitqueryAlgorandTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

/** Algorand transaction with attributes */
export type BitqueryAlgorandTransactionWithAttributes = {
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']['output']>;
  /** Transaction fee */
  fee?: Maybe<Scalars['Float']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  /** Transaction rewards ( from )  */
  fromrewards?: Maybe<Scalars['Float']['output']>;
  group?: Maybe<Scalars['String']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  lastRound?: Maybe<Scalars['Int']['output']>;
  lease?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Transfer transaction sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction sub type */
  subtype?: Maybe<BitqueryAlgorandTxSubType>;
  /** Transaction type in which the transfer happened */
  type?: Maybe<BitqueryAlgorandTxType>;
};

/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Asset related to transaction */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  genesisHash?: Maybe<Scalars['String']['output']>;
  genesisId?: Maybe<Scalars['String']['output']>;
  group?: Maybe<Scalars['String']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  poolerror?: Maybe<Scalars['String']['output']>;
  /** Transaction sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction sub type */
  subtype?: Maybe<BitqueryAlgorandTxSubType>;
  /** Transaction type */
  type?: Maybe<BitqueryAlgorandTxType>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsAnyArgs = {
  of: BitqueryAlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryAlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsCurrencyArgs = {
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  group?: InputMaybe<BitqueryGroupSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCurrency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txSubtype?: InputMaybe<BitqueryTxSubtypeSelector>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransactionsMeasureable>;
  of: BitqueryAlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransactionsMeasureable>;
  of: BitqueryAlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsSubtypeArgs = {
  txType?: InputMaybe<BitqueryTxSubtypeSelector>;
};


/** Transactions in Algorand blockchain */
export type BitqueryAlgorandTransactionsTypeArgs = {
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

export type BitqueryAlgorandTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee value */
  | 'fee'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender';

export type BitqueryAlgorandTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique TX senders count */
  | 'senders';

export type BitqueryAlgorandTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};

export type BitqueryAlgorandTransferType =
  /** Close */
  | 'close'
  /** Create Asset */
  | 'create'
  /** Asset Freeze */
  | 'freeze'
  /** Genesis Block */
  | 'genesis'
  /** Reward */
  | 'reward'
  /** Send */
  | 'send'
  /** Asset Unfreeze */
  | 'unfreeze';

/** Select transfers by type */
export type BitqueryAlgorandTransferTypeSelector = {
  /** Transfer Type in the list */
  in?: InputMaybe<Array<BitqueryAlgorandTransferType>>;
  /** Transfer Type is */
  is?: InputMaybe<BitqueryAlgorandTransferType>;
  /** Transfer Type not */
  not?: InputMaybe<BitqueryAlgorandTransferType>;
  /** Transfer Type not in the list */
  notIn?: InputMaybe<Array<BitqueryAlgorandTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfers = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  firstRound?: Maybe<Scalars['Int']['output']>;
  lastRound?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryAlgorandTransactionWithAttributes>;
  /** Transfer Type */
  transferType?: Maybe<BitqueryAlgorandTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersAnyArgs = {
  of: BitqueryAlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryAlgorandTransferTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryAddressSelector>>;
  txType?: InputMaybe<BitqueryTxTypeSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryAlgorandCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransfersMeasureable>;
  of: BitqueryAlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryAlgorandTransfersMeasureable>;
  of: BitqueryAlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryAlgorandTransfersTransferTypeArgs = {
  transferType?: InputMaybe<Array<BitqueryAlgorandTransferType>>;
};

export type BitqueryAlgorandTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Currency Asset ID */
  | 'asset_id'
  /** Block */
  | 'block'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transfer type */
  | 'transfer_type'
  /** Transaction hash */
  | 'tx_hash'
  /** TX Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

export type BitqueryAlgorandTxSubType =
  /** Close */
  | 'close'
  /** Asset Configuration */
  | 'configure'
  /** Create */
  | 'create'
  /** Asset Freeze */
  | 'freeze'
  /** Key Reg */
  | 'keyreg'
  /** None */
  | 'none'
  /** Send */
  | 'send'
  /** Asset Unfreeze */
  | 'unfreeze';

export type BitqueryAlgorandTxType =
  /** Asset Configuration */
  | 'acfg'
  /** Asset Freeze or Unfreeze */
  | 'afrz'
  /** Application Call */
  | 'appl'
  /** Asset Transfer */
  | 'axfer'
  /** Genesis Block */
  | 'genesis'
  /** Key Reg */
  | 'keyreg'
  /** Pay */
  | 'pay';

export type BitqueryAmountAggregateFunction =
  /** Any value */
  | 'any'
  /** Last value */
  | 'anyLast'
  /** Average */
  | 'average'
  /** Maximum */
  | 'maximum'
  /** Median */
  | 'median'
  /** Minimum */
  | 'minimum'
  /** Sum (total) */
  | 'sum'
  /** Unique estimate fast */
  | 'unique'
  /** Unique exact */
  | 'uniqueExact';

/** Select by amount */
export type BitqueryAmountSelector = {
  /** Amount in range */
  between?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Amount greater than */
  gt?: InputMaybe<Scalars['Float']['input']>;
  /** Amount greater or equal than */
  gteq?: InputMaybe<Scalars['Float']['input']>;
  /** Amount in the list */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Amount is */
  is?: InputMaybe<Scalars['Float']['input']>;
  /** Amount less than */
  lt?: InputMaybe<Scalars['Float']['input']>;
  /** Amount less or equal than */
  lteq?: InputMaybe<Scalars['Float']['input']>;
  /** Amount not */
  not?: InputMaybe<Scalars['Float']['input']>;
  /** Amount not in the list */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** Selector of index of argument in call */
export type BitqueryArgumentIndexSelector = {
  /** Tx index in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Tx index is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Argument of Smart contract method or event */
export type BitqueryArgumentName = {
  /** Name */
  name: Scalars['String']['output'];
  /** Type */
  type: Scalars['String']['output'];
};

/** Argument name and value of smart contract call or event */
export type BitqueryArgumentNameValue = {
  /** Argument name */
  argument: Scalars['String']['output'];
  /** Argument data type */
  argumentType: Scalars['String']['output'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  /** Value as String */
  value: Scalars['String']['output'];
};

/** Selector of argument for smart contract method or event */
export type BitqueryArgumentSelector = {
  /** Argument in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Argument is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Argument not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Argument not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Selector of argument type for smart contract method or event */
export type BitqueryArgumentTypeSelector = {
  /** Argument type in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Argument type is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Argument type not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Argument type not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Argument value of smart contract call or event */
export type BitqueryArgumentValue = {
  /** Value as Address */
  address?: Maybe<BitqueryEthereumAddressInfo>;
  /** Value as String */
  value: Scalars['String']['output'];
};

/** Selector of value of argument for smart contract method or event */
export type BitqueryArgumentValueSelector = {
  /** Value in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Value is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Value not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Value not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryBaseCurrencyEnum =
  /** Binance Smart Chain */
  | 'BNB'
  /** Bitcoin */
  | 'BTC'
  /** Ethereum */
  | 'ETH'
  /** Dollar */
  | 'USD'
  /** Tether USDT */
  | 'USDT';

/** Select by ID with BigInt datatype */
export type BitqueryBigIntIdSelector = {
  /** ID in range */
  between?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** ID greater than */
  gt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID greater or equal than */
  gteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** ID is */
  is?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID less than */
  lt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID less or equal than */
  lteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID not */
  not?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
};

/** Select by big number */
export type BitqueryBigIntegerSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** not */
  not?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['BitqueryBigInt']['input']>>;
};

/** Binance DEX */
export type BitqueryBinance = {
  /** Binance DEX Network Blocks */
  blocks?: Maybe<Array<BitqueryBinanceBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryBinanceCoinpath>>;
  /** Binance DEX Network Exchange Orders */
  orders?: Maybe<Array<BitqueryBinanceOrders>>;
  /** Binance DEX Network Trades between currencies */
  trades?: Maybe<Array<BitqueryBinanceTrades>>;
  /** Binance DEX Network Transactions */
  transactions?: Maybe<Array<BitqueryBinanceTransactions>>;
  /** Binance DEX Network Currency Transfers */
  transfers?: Maybe<Array<BitqueryBinanceTransfers>>;
};


/** Binance DEX */
export type BitqueryBinanceBlocksArgs = {
  any?: InputMaybe<Array<BitqueryBinanceBlockFilter>>;
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Binance DEX */
export type BitqueryBinanceCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryBinanceAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryBinanceAddressSelector>;
  sender?: InputMaybe<BitqueryBinanceAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Binance DEX */
export type BitqueryBinanceOrdersArgs = {
  any?: InputMaybe<Array<BitqueryBinanceOrderFilter>>;
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX */
export type BitqueryBinanceTradesArgs = {
  any?: InputMaybe<Array<BitqueryBinanceTradeFilter>>;
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX */
export type BitqueryBinanceTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryBinanceTransactionFilter>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX */
export type BitqueryBinanceTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryBinanceTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BitqueryBinanceAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BitqueryBinanceAddressSelectorIn = {
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
};

/** Block */
export type BitqueryBinanceBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block ID */
  blockId?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Validator consensus pubkey */
  validatorConsensusPubkey?: Maybe<Scalars['String']['output']>;
  /** Validator fee address */
  validatorFeeAddr?: Maybe<BitqueryAddress>;
  /** Validator moniker */
  validatorMoniker?: Maybe<Scalars['String']['output']>;
  /** Validator operator HR address */
  validatorOperaHrAddress?: Maybe<BitqueryAddress>;
  /** Validator operator address */
  validatorOperatorAddress?: Maybe<BitqueryAddress>;
};


/** Block */
export type BitqueryBinanceBlockAnyArgs = {
  of: BitqueryBinanceBlocksMeasureable;
};


/** Block */
export type BitqueryBinanceBlockBlockIdArgs = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBinanceBlockCountArgs = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryBinanceBlockUniq>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockCountBigIntArgs = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryBinanceBlockUniq>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryBinanceBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryBinanceBlockMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceBlocksMeasureable>;
  of: BitqueryBinanceBlocksMeasureable;
};


/** Block */
export type BitqueryBinanceBlockMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceBlocksMeasureable>;
  of: BitqueryBinanceBlocksMeasureable;
};


/** Block */
export type BitqueryBinanceBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorConsensusPubkeyArgs = {
  validatorConsensusPubkey?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorFeeAddrArgs = {
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorMonikerArgs = {
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorOperaHrAddressArgs = {
  validatorOperaHrAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};


/** Block */
export type BitqueryBinanceBlockValidatorOperatorAddressArgs = {
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};

export type BitqueryBinanceBlockFilter = {
  blockId?: InputMaybe<BitqueryStringIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorFeeAddr?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorMoniker?: InputMaybe<BitqueryStringIdSelector>;
  validatorOperahraddress?: InputMaybe<BitqueryBinanceAddressSelector>;
  validatorOperatorAddress?: InputMaybe<BitqueryBinanceAddressSelector>;
};

export type BitqueryBinanceBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Validator fee addresses */
  | 'validator_fee_addresses'
  /** Validator operators */
  | 'validator_operator_addresses';

export type BitqueryBinanceBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator moniker */
  | 'validator_moniker';

/** Coinpath */
export type BitqueryBinanceCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryBinanceCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryBinanceCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Coinpath */
export type BitqueryBinanceCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryBinanceCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBinanceCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBinanceCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Binance network */
export type BitqueryBinanceCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Binance token selector by tokenId.
 *     Native binance token has BNB symbol.
 *     Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
 */
export type BitqueryBinanceCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryBinanceOrderFilter = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryBinanceOrderSide =
  /** Buy Side */
  | 'buy'
  /** Sell Side */
  | 'sell';

export type BitqueryBinanceOrderStatus =
  /** Ack */
  | 'Ack'
  /** Canceled */
  | 'Canceled'
  /** Expired */
  | 'Expired'
  /** Failed Blocking */
  | 'FailedBlocking'
  /** Fully Fill */
  | 'FullyFill'
  /** Ioc Expire */
  | 'IocExpire'
  /** Ioc No Fill */
  | 'IocNoFill'
  /** Partial Fill */
  | 'PartialFill';

export type BitqueryBinanceOrderTimeInForce =
  /** Good Till Expiry */
  | 'GTE'
  /** Immediate Or Cancel */
  | 'IOC';

export type BitqueryBinanceOrderType =
  /** Limit Order */
  | 'LimitOrder';

/** Binance DEX Order */
export type BitqueryBinanceOrders = {
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block where order transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Order ID */
  orderId?: Maybe<Scalars['String']['output']>;
  /** Order owner address */
  orderOwner?: Maybe<BitqueryAddress>;
  /** Order Side */
  orderSide?: Maybe<BitqueryBinanceOrderSide>;
  /** Order Status */
  orderStatus?: Maybe<BitqueryBinanceOrderStatus>;
  /** Order Time In Force */
  orderTimeInForce?: Maybe<BitqueryBinanceOrderTimeInForce>;
  /** Order Type */
  orderType?: Maybe<BitqueryBinanceOrderType>;
  price?: Maybe<Scalars['Float']['output']>;
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  quoteCurrency?: Maybe<BitqueryCurrency>;
  /** Transaction where order created */
  transaction?: Maybe<BitqueryTransactionHash>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersAnyArgs = {
  of: BitqueryBinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersBaseAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersCountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersCountBigIntArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceOrdersMeasureable>;
  of: BitqueryBinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceOrdersMeasureable>;
  of: BitqueryBinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderIdArgs = {
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderOwnerArgs = {
  owner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderSideArgs = {
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderStatusArgs = {
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderTimeInForceArgs = {
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersOrderTypeArgs = {
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersQuoteAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  orderOwner?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  orderSide?: InputMaybe<Array<BitqueryOrderSideSelector>>;
  orderStatus?: InputMaybe<Array<BitqueryOrderStatusSelector>>;
  orderTimeInForce?: InputMaybe<Array<BitqueryOrderTimeInForceSelector>>;
  orderType?: InputMaybe<Array<BitqueryOrderTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BitqueryBinanceOrdersTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryBinanceOrdersMeasureable =
  /** Base Amount */
  | 'base_amount'
  /** Base currency */
  | 'base_currency'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Order ID */
  | 'order_id'
  /** Order owner */
  | 'order_owner'
  /** Order side */
  | 'order_side'
  /** Order status */
  | 'order_status'
  /** Price */
  | 'price'
  /** Quote Amount */
  | 'quote_amount'
  /** Quote currency */
  | 'quote_currency'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryBinanceOrdersUniq =
  /** Unique base currencies */
  | 'base_currencies'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique order ID count */
  | 'orders'
  /** Unique order owners */
  | 'owners'
  /** Unique quote currencies */
  | 'quote_currencies'
  /** Unique Transactions */
  | 'txs';

export type BitqueryBinanceTradeFilter = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Binance DEX Trades */
export type BitqueryBinanceTrades = {
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block where trade transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Buy Order ID */
  buyOrderId?: Maybe<Scalars['String']['output']>;
  /** Trade buyer address */
  buyer?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  quoteCurrency?: Maybe<BitqueryCurrency>;
  /** Sell Order ID */
  sellOrderId?: Maybe<Scalars['String']['output']>;
  /** Trade seller address */
  seller?: Maybe<BitqueryAddress>;
  /** Trade ID */
  tradeId?: Maybe<Scalars['String']['output']>;
  /** Transaction where trade happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesAnyArgs = {
  of: BitqueryBinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBaseAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBuyOrderIdArgs = {
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesBuyerArgs = {
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesCountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesCountBigIntArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceTradesMeasureable>;
  of: BitqueryBinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceTradesMeasureable>;
  of: BitqueryBinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesQuoteAmountArgs = {
  baseAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  baseCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  buyOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  buyer?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesSellOrderIdArgs = {
  sellOrderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesSellerArgs = {
  seller?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesTradeIdArgs = {
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
};


/** Binance DEX Trades */
export type BitqueryBinanceTradesTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryBinanceTradesMeasureable =
  /** Base Amount */
  | 'base_amount'
  /** Base currency */
  | 'base_currency'
  /** Block */
  | 'block'
  /** Buy Order ID */
  | 'buy_order_id'
  /** Buyer */
  | 'buyer'
  /** Date */
  | 'date'
  /** Price */
  | 'price'
  /** Quote Amount */
  | 'quote_amount'
  /** Quote currency */
  | 'quote_currency'
  /** Sell Order ID */
  | 'sell_order_id'
  /** Seller */
  | 'seller'
  /** Time */
  | 'time'
  /** Trade ID */
  | 'trade_id'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryBinanceTradesUniq =
  /** Unique base currencies */
  | 'base_currencies'
  /** Unique blocks */
  | 'blocks'
  /** Buy Orders */
  | 'buy_orders'
  /** Unique buyers count */
  | 'buyers'
  /** Unique date count */
  | 'dates'
  /** Unique quote currencies */
  | 'quote_currencies'
  /** Sell Orders */
  | 'sell_orders'
  /** Unique sellers count */
  | 'sellers'
  /** Trades */
  | 'trades'
  /** Unique Transactions */
  | 'txs';

export type BitqueryBinanceTransactionFilter = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryBinanceTransactionType =
  /** Bind */
  | 'BIND'
  /** Submit evidence */
  | 'BSC_SUBMIT_EVIDENCE'
  /** Burn */
  | 'BURN'
  /** Cancel Order */
  | 'CANCEL_ORDER'
  /** Cross chain claim */
  | 'CLAIM'
  /** Hash Timer Locked Claim */
  | 'CLAIM_HTL'
  /** Create sidechain validator */
  | 'CREATE_SIDECHAIN_VALIDATOR'
  /** Deposit */
  | 'DEPOSIT'
  /** Hash Timer Locked Deposit */
  | 'DEPOSIT_HTL'
  /** Edit sidechain validator */
  | 'EDIT_SIDECHAIN_VALIDATOR'
  /** Freeze Token */
  | 'FREEZE_TOKEN'
  /** Hash Timer Locked Transfer */
  | 'HTL_TRANSFER'
  /** Issue */
  | 'ISSUE'
  /** Listing */
  | 'LISTING'
  /** Mini Token Issue */
  | 'MINI_TOKEN_ISSUE'
  /** Mini Token Listing */
  | 'MINI_TOKEN_LIST'
  /** Mini Token Set URI */
  | 'MINI_TOKEN_SET_URI'
  /** Mint */
  | 'MINT'
  /** New Order */
  | 'NEW_ORDER'
  /** Hash Timer Locked  Refund */
  | 'REFUND_HTL'
  /** Delegate for sidechain */
  | 'SIDECHAIN_DELEGATE'
  /** ReDelegate for sidechain */
  | 'SIDECHAIN_REDELEGATE'
  /** Unbond from sidechain */
  | 'SIDECHAIN_UNBOND'
  /** Unjail from sidechain */
  | 'SIDECHAIN_UNJAIL'
  /** Side chain deposit */
  | 'SIDE_DEPOSIT'
  /** Side chain submit poroposal */
  | 'SIDE_SUBMIT_PROPOSAL'
  /** Side chain vote */
  | 'SIDE_VOTE'
  /** Submit Proposal */
  | 'SUBMIT_PROPOSAL'
  /** Set Account Flag */
  | 'SetAccountFlag'
  /** Tiny Token Issue */
  | 'TINY_TOKEN_ISSUE'
  /** Tiny Token Listing */
  | 'TINY_TOKEN_LIST'
  /** Tiny Token Set URI */
  | 'TINY_TOKEN_SET_URI'
  /** Transfer */
  | 'TRANSFER'
  /** Cross chain transfer */
  | 'TRANSFER_OUT'
  /** Time Lock */
  | 'TimeLock'
  /** Time Relock */
  | 'TimeRelock'
  /** Time Unlock */
  | 'TimeUnlock'
  /** UnBind */
  | 'UNBIND'
  /** Unfreeze Token */
  | 'UNFREEZE_TOKEN'
  /** Vote */
  | 'VOTE';

/** Select by transaction type */
export type BitqueryBinanceTransactionTypeSelector = {
  /** Transaction Type in the list */
  in?: InputMaybe<Array<BitqueryBinanceTransactionType>>;
  /** Transaction Type is */
  is?: InputMaybe<BitqueryBinanceTransactionType>;
  /** Transaction Type not */
  not?: InputMaybe<BitqueryBinanceTransactionType>;
  /** Transaction Type not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceTransactionType>>;
};

/** Transaction */
export type BitqueryBinanceTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency issued in transaction */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Deposit amount in transaction */
  deposit?: Maybe<Scalars['Float']['output']>;
  /** Transaction Description */
  description?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** TX index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction Log */
  log?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Transaction Memo */
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proposal ID */
  proposalId?: Maybe<Scalars['Int']['output']>;
  /** Transaction Type */
  transactionCode?: Maybe<Scalars['Int']['output']>;
  /** Transaction Source */
  transactionSource?: Maybe<BitqueryTransactionSource>;
  /** Transaction Type */
  transactionType?: Maybe<BitqueryBinanceTransactionType>;
};


/** Transaction */
export type BitqueryBinanceTransactionsAnyArgs = {
  of: BitqueryBinanceTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBinanceTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction */
export type BitqueryBinanceTransactionsCountArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTransactionsUniq>;
};


/** Transaction */
export type BitqueryBinanceTransactionsCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposalId?: InputMaybe<BitqueryStringIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
  transactionType?: InputMaybe<BitqueryBinanceTransactionTypeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryBinanceTransactionsUniq>;
};


/** Transaction */
export type BitqueryBinanceTransactionsCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsDepositArgs = {
  deposit?: InputMaybe<Array<BitqueryAmountSelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction */
export type BitqueryBinanceTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceTransactionsMeasureable>;
  of: BitqueryBinanceTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBinanceTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceTransactionsMeasureable>;
  of: BitqueryBinanceTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBinanceTransactionsProposalIdArgs = {
  proposalId?: InputMaybe<Array<BitqueryIntIdSelector>>;
};


/** Transaction */
export type BitqueryBinanceTransactionsTransactionCodeArgs = {
  transactionCode?: InputMaybe<BitqueryIntIdSelector>;
};


/** Transaction */
export type BitqueryBinanceTransactionsTransactionSourceArgs = {
  transactionSource?: InputMaybe<BitqueryIntIdSelector>;
};


/** Transaction */
export type BitqueryBinanceTransactionsTransactionTypeArgs = {
  transactionType?: InputMaybe<Array<BitqueryBinanceTransactionTypeSelector>>;
};

export type BitqueryBinanceTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Currency */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Transaction Code */
  | 'transaction_code'
  /** Transaction Memo */
  | 'transaction_memo'
  /** Transaction Source Code */
  | 'transaction_source_code'
  /** Transaction Source Name */
  | 'transaction_source_name'
  /** Transaction Type */
  | 'transaction_type'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryBinanceTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transaction source count */
  | 'transaction_sources';

export type BitqueryBinanceTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryBinanceTransferType =
  /** Bind */
  | 'BIND'
  /** Reward for block */
  | 'BLOCK_REWARD'
  /** Submit evidence */
  | 'BSC_SUBMIT_EVIDENCE'
  /** Burning amount */
  | 'BURN'
  /** Cross chain claim */
  | 'CLAIM'
  /** Claiming Hash Timer Locked Transfer */
  | 'CLAIM_HTL'
  /** Create sidechain validator */
  | 'CREATE_SIDECHAIN_VALIDATOR'
  /** Deposit for Hash Timer Locked Transfer */
  | 'DEPOSIT_HTL'
  /** Fee for DEX orders */
  | 'DEX_FEE'
  /** Edit sidechain validator */
  | 'EDIT_SIDECHAIN_VALIDATOR'
  /** Genesis declaration */
  | 'GENESIS_DELEGATION'
  /** Genesis supply declaration */
  | 'GENESIS_SUPPLY'
  /** Hash Timer Locked Transfer */
  | 'HTL_TRANSFER'
  /** Issue token */
  | 'ISSUE'
  /** Mini Token Issue */
  | 'MINI_TOKEN_ISSUE'
  /** Mint token */
  | 'MINT'
  /** Delegate for sidechain */
  | 'SIDECHAIN_DELEGATE'
  /** ReDelegate for sidechain */
  | 'SIDECHAIN_REDELEGATE'
  /** Unbond from sidechain */
  | 'SIDECHAIN_UNBOND'
  /** Side chain deposit */
  | 'SIDE_DEPOSIT'
  /** Side chain submit poroposal */
  | 'SIDE_SUBMIT_PROPOSAL'
  /** Side chain vote */
  | 'SIDE_VOTE'
  /** Tiny Token Issue */
  | 'TINY_TOKEN_ISSUE'
  /** Trade buy side */
  | 'TRADE_BUY'
  /** Trade sell side */
  | 'TRADE_SELL'
  /** Transfer */
  | 'TRANSFER'
  /** Cross chain transfer */
  | 'TRANSFER_OUT'
  /** Transaction fee */
  | 'TX_FEE'
  /** UnBind */
  | 'UNBIND';

/** Select transfer type(s) */
export type BitqueryBinanceTransferTypeSelector = {
  /** Transfer type in the list */
  in?: InputMaybe<Array<BitqueryBinanceTransferType>>;
  /** Transfer type is */
  is?: InputMaybe<BitqueryBinanceTransferType>;
  /** Transfer type not */
  not?: InputMaybe<BitqueryBinanceTransferType>;
  /** Transfer type not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfers = {
  /** Transfer amount */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Transfer count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transfer count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Order Id of trade where transfer happened */
  orderId?: Maybe<Scalars['String']['output']>;
  /** Index of the output for the transfer, 0-based */
  outputIndex?: Maybe<Scalars['Int']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Id of trade where transfer happened */
  tradeId?: Maybe<Scalars['String']['output']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transfer type */
  transferType?: Maybe<BitqueryBinanceTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersAnyArgs = {
  of: BitqueryBinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryBinanceCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryBinanceTransfersMeasureable>;
  of: BitqueryBinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryBinanceTransfersMeasureable>;
  of: BitqueryBinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersOrderIdArgs = {
  orderId?: InputMaybe<Array<BitqueryOrderIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersOutputIndexArgs = {
  outputIndex?: InputMaybe<Array<BitqueryOutputIndexSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryBinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersTradeIdArgs = {
  tradeId?: InputMaybe<Array<BitqueryTradeIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryBinanceTransfersTransferTypeArgs = {
  transferType?: InputMaybe<Array<BitqueryBinanceTransferTypeSelector>>;
};

export type BitqueryBinanceTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoin = {
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryBitcoinAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryBitcoinBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryBitcoinCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitqueryBitcoinTransactionInput>>;
  /** Blockchain Transaction OmniTransactions */
  omniTransactions?: Maybe<Array<BitqueryBitcoinOmniTransactiosn>>;
  /** Blockchain Transaction OmniTransfers */
  omniTransfers?: Maybe<Array<BitqueryBitcoinOmniTransfers>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitqueryBitcoinTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryBitcoinTransaction>>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinBlocksArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinBlockFilter>>;
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryBitcoinCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinInputsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinInputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinOmniTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinOmniTransactionsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinOmniTransfersArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinOmniTransfersFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinOutputsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinOutputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitqueryBitcoinTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryBitcoinTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};

/** AddressStat */
export type BitqueryBitcoinAddressStats = {
  /** Address With Statistics */
  address?: Maybe<BitqueryAddressStatDimension>;
};

/** Block */
export type BitqueryBitcoinBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']['output']>;
  /** Block size */
  blockSizeBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block stripped size */
  blockStrippedSize?: Maybe<Scalars['Int']['output']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']['output']>;
  /** Block weight */
  blockWeight?: Maybe<Scalars['Int']['output']>;
  /** Block chainwork */
  chainwork?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block median timestamp */
  medianTime?: Maybe<BitqueryDateTime>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']['output']>;
};


/** Block */
export type BitqueryBitcoinBlockAnyArgs = {
  of: BitqueryBitcoinBlocksMeasureable;
};


/** Block */
export type BitqueryBitcoinBlockBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockSizeArgs = {
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockStrippedSizeArgs = {
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockVersionArgs = {
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockBlockWeightArgs = {
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryBitcoinBlockCountArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinBlockUniq>;
};


/** Block */
export type BitqueryBitcoinBlockCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinBlockUniq>;
};


/** Block */
export type BitqueryBitcoinBlockDifficultyArgs = {
  difficulty?: InputMaybe<BitqueryFloatSelector>;
};


/** Block */
export type BitqueryBitcoinBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryBitcoinBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryBitcoinBlockMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinBlocksMeasureable>;
  of: BitqueryBitcoinBlocksMeasureable;
};


/** Block */
export type BitqueryBitcoinBlockMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinBlocksMeasureable>;
  of: BitqueryBitcoinBlocksMeasureable;
};


/** Block */
export type BitqueryBitcoinBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryBitcoinBlockTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinBlockFilter = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinBlockUniq =
  /** Unique date count */
  | 'dates';

export type BitqueryBitcoinBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Tx Count */
  | 'transaction_count';

/** Coinpath */
export type BitqueryBitcoinCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryBitcoinCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryBitcoinCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryBitcoinTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryBitcoinCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Bitcoin network */
export type BitqueryBitcoinCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryBitcoinCoinpathMethod =
  /** Tracking money flow by amounts, ignoring coins (default) */
  | 'moneyflow'
  /** Tracking coins by UTXO transactions */
  | 'utxo';

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitqueryBitcoinCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Method to use coinpath */
  coinpathMethod?: InputMaybe<BitqueryBitcoinCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Flow direction */
  direction?: InputMaybe<BitqueryFlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
};

export type BitqueryBitcoinInputFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinInputUniq =
  /** Unique addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions';

export type BitqueryBitcoinInputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Input index */
  | 'input_index'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

export type BitqueryBitcoinNetwork =
  /** Bitcoin Cash ( BCH ) */
  | 'bitcash'
  /** Bitcoin ( BTC ) */
  | 'bitcoin'
  /** Bitcoin SV ( BSV ) */
  | 'bitcoinsv'
  /** Dash ( DASH ) */
  | 'dash'
  /** Dogecoin ( DOGE ) */
  | 'dogecoin'
  /** Litecoin ( LTC ) */
  | 'litecoin'
  /** ZCash ( ZCASH ) */
  | 'zcash';

export type BitqueryBitcoinOmniTransactionsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinOmniTransactionsMeasureablse =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee Value */
  | 'fee_value'
  /** Time */
  | 'time'
  /** Transactions hash */
  | 'tx_hash'
  /** Transactions index */
  | 'tx_index';

export type BitqueryBitcoinOmniTransactionsUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions'
  /** Unique transaction sender */
  | 'tx_sender';

/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosn = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Hash of the block */
  blockHash: Scalars['String']['output'];
  /** OmniTransaction s count */
  count?: Maybe<Scalars['Int']['output']>;
  /** OmniTransaction s count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** OmniTransactions index in block, 0-based */
  index: Scalars['String']['output'];
  /** Invalid Reason */
  invalidReason: Scalars['String']['output'];
  /** Invalid Reason */
  json: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction Sender */
  txSender: Scalars['String']['output'];
  /** Type */
  type: Scalars['String']['output'];
  /** Type Int */
  typeInt: Scalars['Int']['output'];
  /** Version */
  valid: Scalars['Int']['output'];
  /** Version */
  version: Scalars['Int']['output'];
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnAnyArgs = {
  of: BitqueryBitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransactionsUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransactionsUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnExpressionArgs = {
  get: Scalars['String']['input'];
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnInvalidReasonArgs = {
  invalidReason?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnJsonArgs = {
  json?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransactionsMeasureablse>;
  of: BitqueryBitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransactionsMeasureablse>;
  of: BitqueryBitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnTxSenderArgs = {
  txSender?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnTypeArgs = {
  type?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnTypeIntArgs = {
  typeInt?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnValidArgs = {
  valid?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransactions */
export type BitqueryBitcoinOmniTransactiosnVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** OmniTransfers */
export type BitqueryBitcoinOmniTransfers = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Hash of the block */
  blockHash: Scalars['String']['output'];
  /** Transaction s count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transaction s count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  /** Divisible */
  divisible?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transactions index in block, 0-based */
  index: Scalars['String']['output'];
  /** Ismine */
  ismine?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer From */
  transferFrom: Scalars['String']['output'];
  /** Transfer From */
  transferTo: Scalars['String']['output'];
  /** Transaction Sender */
  txSender: Scalars['String']['output'];
  /** Type */
  type: Scalars['String']['output'];
  /** Type Int */
  typeInt: Scalars['Int']['output'];
  /** value */
  value?: Maybe<Scalars['Float']['output']>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersAnyArgs = {
  of: BitqueryBitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransfersUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOmniTransfersUniq>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersDirectionArgs = {
  direction?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersDivisibleArgs = {
  divisible?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersIsmineArgs = {
  ismine?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransfersMeasureablse>;
  of: BitqueryBitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinOmniTransfersMeasureablse>;
  of: BitqueryBitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTransferFromArgs = {
  transferFrom?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTransferToArgs = {
  transferTo?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTxSenderArgs = {
  txSender?: InputMaybe<BitqueryHashSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTypeArgs = {
  type?: InputMaybe<BitqueryStringSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersTypeIntArgs = {
  typeInt?: InputMaybe<BitqueryIntegerSelector>;
};


/** OmniTransfers */
export type BitqueryBitcoinOmniTransfersValueArgs = {
  value?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryBitcoinOmniTransfersFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  invalidReason?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeId?: InputMaybe<BitqueryIntegerSelector>;
  valid?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinOmniTransfersMeasureablse =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee Value */
  | 'fee_value'
  /** Time */
  | 'time'
  /** Transactions hash */
  | 'tx_hash'
  /** Transactions index */
  | 'tx_index';

export type BitqueryBitcoinOmniTransfersUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions'
  /** Unique transaction sender */
  | 'tx_sender';

export type BitqueryBitcoinOutputDirection =
  /** Change return */
  | 'change'
  /** Fee */
  | 'fee'
  /** Genesis */
  | 'genesis'
  /** Likely Change return */
  | 'likely_change'
  /** Likely Not a change return */
  | 'likely_not_change'
  /** Mining */
  | 'mining'
  /** Minting */
  | 'minting'
  /** Not a change return */
  | 'not_change'
  /** Not defined */
  | 'unknown';

/** A guessed direction of output */
export type BitqueryBitcoinOutputDirectionSelector = {
  /** In the list of direction */
  in?: InputMaybe<Array<BitqueryBitcoinOutputDirection>>;
  /** Equal to direction */
  is?: InputMaybe<BitqueryBitcoinOutputDirection>;
  /** Not Equal to direction */
  not?: InputMaybe<BitqueryBitcoinOutputDirection>;
  /** Not in the list of direction */
  notIn?: InputMaybe<Array<BitqueryBitcoinOutputDirection>>;
};

export type BitqueryBitcoinOutputFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinOutputUniq =
  /** Unique input addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions';

export type BitqueryBitcoinOutputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Output index */
  | 'output_index'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

/** Transaction */
export type BitqueryBitcoinTransaction = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Transaction total mined value */
  minedValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total mined value */
  minedValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transaction is coinbase */
  txCoinbase?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction locktime */
  txLocktime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']['output']>;
  /** Transaction version */
  txVersion?: Maybe<Scalars['Int']['output']>;
  /** Transaction vsize */
  txVsize?: Maybe<Scalars['Int']['output']>;
  /** Transaction weight */
  txWeight?: Maybe<Scalars['Int']['output']>;
};


/** Transaction */
export type BitqueryBitcoinTransactionAnyArgs = {
  of: BitqueryBitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBitcoinTransactionBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinTransactionUniq>;
};


/** Transaction */
export type BitqueryBitcoinTransactionCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinTransactionUniq>;
};


/** Transaction */
export type BitqueryBitcoinTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction */
export type BitqueryBitcoinTransactionFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionFeeValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinTransactionsMeasureable>;
  of: BitqueryBitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBitcoinTransactionMinedValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionMinedValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinTransactionsMeasureable>;
  of: BitqueryBitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxCoinbaseArgs = {
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxLocktimeArgs = {
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxSizeArgs = {
  txSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxVersionArgs = {
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxVsizeArgs = {
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryBitcoinTransactionTxWeightArgs = {
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  minedValue?: InputMaybe<BitqueryFloatSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCoinbase?: InputMaybe<Scalars['Boolean']['input']>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txLocktime?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  txVersion?: InputMaybe<BitqueryIntegerSelector>;
  txVsize?: InputMaybe<BitqueryIntegerSelector>;
  txWeight?: InputMaybe<BitqueryIntegerSelector>;
};

/** Blockchain transaction */
export type BitqueryBitcoinTransactionHashIndexValues = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  /** Transaction value in input */
  valueIn: Scalars['Float']['output'];
  /** Transaction value in input */
  valueInDecimal: Scalars['BitqueryDecimalNumber']['output'];
  /** Transaction value in output */
  valueOut: Scalars['Float']['output'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['BitqueryDecimalNumber']['output'];
};

/** Transaction Input */
export type BitqueryBitcoinTransactionInput = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Input count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Input address */
  inputAddress?: Maybe<BitqueryAddress>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']['output']>;
  /** Input script */
  inputScript?: Maybe<Scalars['String']['output']>;
  /** Input script type and attributes */
  inputScriptType?: Maybe<BitqueryInputScript>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputAnyArgs = {
  of: BitqueryBitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinInputUniq>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinInputUniq>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputInputAddressArgs = {
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputInputIndexArgs = {
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputInputScriptTypeArgs = {
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinInputsMeasureable>;
  of: BitqueryBitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinInputsMeasureable>;
  of: BitqueryBitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputOutputTransactionArgs = {
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryBitcoinTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

/** Transaction Output */
export type BitqueryBitcoinTransactionOutput = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Output count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output address */
  outputAddress?: Maybe<BitqueryAddress>;
  /** Output guessed direction */
  outputDirection?: Maybe<BitqueryBitcoinOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']['output']>;
  /** Output script */
  outputScript?: Maybe<Scalars['String']['output']>;
  /** Output script type and attributes */
  outputScriptType?: Maybe<BitqueryOutputScript>;
  reqSigs?: Maybe<Scalars['Int']['output']>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Output value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputAnyArgs = {
  of: BitqueryBitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOutputUniq>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryBitcoinOutputUniq>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputMaximumArgs = {
  get?: InputMaybe<BitqueryBitcoinOutputsMeasureable>;
  of: BitqueryBitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputMinimumArgs = {
  get?: InputMaybe<BitqueryBitcoinOutputsMeasureable>;
  of: BitqueryBitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputAddressArgs = {
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputDirectionArgs = {
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputIndexArgs = {
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputOutputScriptTypeArgs = {
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryBitcoinOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputScriptType?: InputMaybe<BitqueryStringSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryBitcoinTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputScriptType?: InputMaybe<BitqueryStringSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryBitcoinTransactionUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type BitqueryBitcoinTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee Value */
  | 'fee_value'
  /** Input count */
  | 'input_count'
  /** Transaction input value */
  | 'input_value'
  /** Output count */
  | 'output_count'
  /** Transaction output value */
  | 'output_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index'
  /** Transaction size */
  | 'tx_size';

/** Block */
export type BitqueryBlock = {
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

/** BlockExtended */
export type BitqueryBlockExtended = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

/** ConfluxBlock */
export type BitqueryBlockInfo = {
  /** Block hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

/** Select block by height ( sequence number) */
export type BitqueryBlockSelector = {
  /** Block height in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Block height greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** Block height in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Block height is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** Block height not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Block height not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Select block by height ( sequence number) */
export type BitqueryBlockSelectorRange = {
  /** Block height in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Block height greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** Block height eq */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** Block height less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
};

/** Blockchain network */
export type BitqueryBlockchainNetwork = {
  /** Network name */
  network: BitqueryNetwork;
  /** Network protocol type */
  protocol: BitqueryProtocol;
};

/** Select by boolean (sequence number) */
export type BitqueryBooleanSelector = {
  /** Is */
  is?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is not */
  not?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Cardano */
export type BitqueryCardano = {
  /** Information about address */
  address: Array<BitqueryCardanoAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryCardanoAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryCardanoBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryCardanoCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitqueryCardanoTransactionInput>>;
  /** Blockchain Tokens Mints */
  mints?: Maybe<Array<BitqueryCardanoTransactionMint>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitqueryCardanoTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryCardanoTransaction>>;
};


/** Cardano */
export type BitqueryCardanoAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Cardano */
export type BitqueryCardanoAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Cardano */
export type BitqueryCardanoBlocksArgs = {
  any?: InputMaybe<Array<BitqueryCardanoBlockFilter>>;
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  opCert?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  slot?: InputMaybe<BitqueryIntegerSelector>;
  slotInEpoch?: InputMaybe<BitqueryIntegerSelector>;
  slotLeaderHash?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryStringSelector>;
  vrfKey?: InputMaybe<BitqueryStringSelector>;
};


/** Cardano */
export type BitqueryCardanoCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCardanoCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Cardano */
export type BitqueryCardanoInputsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoInputFilter>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Cardano */
export type BitqueryCardanoMintsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoMintFilter>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<BitqueryFloatSelector>;
};


/** Cardano */
export type BitqueryCardanoOutputsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoOutputFilter>>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Cardano */
export type BitqueryCardanoTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryCardanoTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};

/** Address balance information for Cardano network */
export type BitqueryCardanoAddressBalance = {
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Currency value */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Address detailed information for Cardano network */
export type BitqueryCardanoAddressInfo = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Current address balances */
  balance?: Maybe<Array<BitqueryCardanoAddressBalance>>;
  /** Current staking addressese info */
  staking?: Maybe<Array<BitqueryCardanoStakingAddress>>;
};

/** AddressStat */
export type BitqueryCardanoAddressStats = {
  /** Address With Statistics */
  address?: Maybe<BitqueryAddressStatDimension>;
};

/** Block */
export type BitqueryCardanoBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']['output']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Epoch number */
  epoch?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op cert */
  opCert?: Maybe<Scalars['String']['output']>;
  /** Slot number */
  slot?: Maybe<Scalars['Int']['output']>;
  /** Slot in epoch number */
  slotInEpoch?: Maybe<Scalars['Int']['output']>;
  /** Slot leader description */
  slotLeaderDescription?: Maybe<Scalars['String']['output']>;
  /** Slot leader hash */
  slotLeaderHash?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']['output']>;
  /** VRF Key */
  vrfKey?: Maybe<Scalars['String']['output']>;
};


/** Block */
export type BitqueryCardanoBlockAnyArgs = {
  of: BitqueryCardanoBlocksMeasureable;
};


/** Block */
export type BitqueryCardanoBlockBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Block */
export type BitqueryCardanoBlockBlockSizeArgs = {
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryCardanoBlockBlockVersionArgs = {
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryCardanoBlockCountArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoBlockUniq>;
};


/** Block */
export type BitqueryCardanoBlockCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockStrippedSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  blockWeight?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoBlockUniq>;
};


/** Block */
export type BitqueryCardanoBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryCardanoBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryCardanoBlockMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoBlocksMeasureable>;
  of: BitqueryCardanoBlocksMeasureable;
};


/** Block */
export type BitqueryCardanoBlockMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoBlocksMeasureable>;
  of: BitqueryCardanoBlocksMeasureable;
};


/** Block */
export type BitqueryCardanoBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryCardanoBlockTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryCardanoBlockFilter = {
  blockHash?: InputMaybe<BitqueryStringIdSelector>;
  blockSize?: InputMaybe<BitqueryIntegerSelector>;
  blockVersion?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  opCert?: InputMaybe<BitqueryStringSelector>;
  slot?: InputMaybe<BitqueryIntegerSelector>;
  slotInEpoch?: InputMaybe<BitqueryIntegerSelector>;
  slotLeaderHash?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  version?: InputMaybe<BitqueryStringSelector>;
  vrfKey?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryCardanoBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique epoch */
  | 'epoch'
  /** Unique slot */
  | 'slot'
  /** Unique slot leader */
  | 'slot_leader'
  /** Unique version */
  | 'version';

export type BitqueryCardanoBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Tx Count */
  | 'transaction_count';

/** Coinpath */
export type BitqueryCardanoCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryCardanoCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryCardanoCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryCardanoTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryCardanoCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryCardanoCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryCardanoCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryCardanoCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Cardano network */
export type BitqueryCardanoCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryCardanoCoinpathMethod =
  /** Tracking money flow by amounts, ignoring coins (default) */
  | 'moneyflow'
  /** Tracking coins by UTXO transactions */
  | 'utxo';

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitqueryCardanoCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Method to use coinpath */
  coinpathMethod?: InputMaybe<BitqueryCardanoCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Flow direction */
  direction?: InputMaybe<BitqueryFlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
  /** Option to get info for staking addresses */
  stakingAddress?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * Cardano token selector by tokenId.
 *     Native binance token has ADA symbol, pass it as argument.
 *     Otherwise pass asset fingerprint, starting from asset...
 */
export type BitqueryCardanoCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryCardanoInputFilter = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryCardanoInputSource =
  /** Input */
  | 'input'
  /** Stake Deregistration */
  | 'stake_deregistration'
  /** Withdrawal */
  | 'withdrawal';

/** A source input */
export type BitqueryCardanoInputSourcenSelector = {
  /** In the list of source */
  in?: InputMaybe<Array<BitqueryCardanoInputSource>>;
  /** Equal to source */
  is?: InputMaybe<BitqueryCardanoInputSource>;
  /** Not Equal to source */
  not?: InputMaybe<BitqueryCardanoInputSource>;
  /** Not in the list of source */
  notIn?: InputMaybe<Array<BitqueryCardanoInputSource>>;
};

export type BitqueryCardanoInputUniq =
  /** Unique addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique currencies count */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique source count */
  | 'sources'
  /** Unique transactions count */
  | 'transactions';

export type BitqueryCardanoInputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Input index */
  | 'input_index'
  /** Input source */
  | 'source'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

export type BitqueryCardanoMintFilter = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryCardanoMintUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique currencies count */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique transactions count */
  | 'transactions';

export type BitqueryCardanoMintsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

export type BitqueryCardanoNetwork =
  /** Cardano ( ADA ) */
  | 'cardano';

export type BitqueryCardanoOutputDirection =
  /** Change return */
  | 'change'
  /** Stake Registration */
  | 'deposit'
  /** Genesis */
  | 'genesis'
  /** Not a change return */
  | 'not_change'
  /** Stake Registration */
  | 'stake_registration'
  /** Not defined */
  | 'unknown';

/** A guessed direction of output */
export type BitqueryCardanoOutputDirectionSelector = {
  /** In the list of direction */
  in?: InputMaybe<Array<BitqueryCardanoOutputDirection>>;
  /** Equal to direction */
  is?: InputMaybe<BitqueryCardanoOutputDirection>;
  /** Not Equal to direction */
  not?: InputMaybe<BitqueryCardanoOutputDirection>;
  /** Not in the list of direction */
  notIn?: InputMaybe<Array<BitqueryCardanoOutputDirection>>;
};

export type BitqueryCardanoOutputFilter = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryCardanoOutputUniq =
  /** Unique input addresses count */
  | 'addresses'
  /** Unique block count */
  | 'blocks'
  /** Unique currencies count */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique direction count */
  | 'directions'
  /** Unique transactions count */
  | 'transactions';

export type BitqueryCardanoOutputsMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Output direction */
  | 'direction'
  /** Output index */
  | 'output_index'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index';

/** Address staking information for Cardano network */
export type BitqueryCardanoStakingAddress = {
  /** Staking Address */
  address?: Maybe<BitqueryAddress>;
  /** Controlled total stake */
  controlledTotalStake?: Maybe<Scalars['Float']['output']>;
  /** Rewards value */
  rewardsAmount?: Maybe<Scalars['Float']['output']>;
  /** Rewards available */
  rewardsAvailable?: Maybe<Scalars['Float']['output']>;
  /** Staked value */
  stakedAmount?: Maybe<Scalars['Float']['output']>;
  /** Staked value including rewards */
  stakedAmountWithRewards?: Maybe<Scalars['Float']['output']>;
  /** Withdrawn value */
  withdrawnAmount?: Maybe<Scalars['Float']['output']>;
};

/** Transaction */
export type BitqueryCardanoTransaction = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Transaction total deposit value */
  depositValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  depositValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Included at timestamp */
  includedAt?: Maybe<BitqueryDateTime>;
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Invalid before */
  invalidBefore?: Maybe<Scalars['String']['output']>;
  /** Invalid hereafter */
  invalidHereafter?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction total mint count */
  mintCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total mint count */
  mintCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']['output']>;
  /** Transaction total withdrawal count */
  withdrawalCount?: Maybe<Scalars['Int']['output']>;
  /** Transaction total withdrawal count */
  withdrawalCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction total withdrawal value */
  withdrawalValue?: Maybe<Scalars['Float']['output']>;
  /** Transaction total fee value */
  withdrawalValueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transaction */
export type BitqueryCardanoTransactionAnyArgs = {
  of: BitqueryCardanoTransactionsMeasureable;
};


/** Transaction */
export type BitqueryCardanoTransactionBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoTransactionUniq>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoTransactionUniq>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionDepositValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionDepositValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction */
export type BitqueryCardanoTransactionFeeValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionFeeValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionHashArgs = {
  txHash?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionIndexArgs = {
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoTransactionsMeasureable>;
  of: BitqueryCardanoTransactionsMeasureable;
};


/** Transaction */
export type BitqueryCardanoTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoTransactionsMeasureable>;
  of: BitqueryCardanoTransactionsMeasureable;
};


/** Transaction */
export type BitqueryCardanoTransactionMintCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionMintCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionTxSizeArgs = {
  txSize?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalCountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalCountBigIntArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction */
export type BitqueryCardanoTransactionWithdrawalValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryCardanoTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  depositValue?: InputMaybe<BitqueryFloatSelector>;
  feeValue?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  inputCount?: InputMaybe<BitqueryIntegerSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  mintCount?: InputMaybe<BitqueryIntegerSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  outputCount?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txSize?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalCount?: InputMaybe<BitqueryIntegerSelector>;
  withdrawalValue?: InputMaybe<BitqueryFloatSelector>;
};

/** Blockchain transaction */
export type BitqueryCardanoTransactionHashIndexValues = {
  depositValue: Scalars['Float']['output'];
  /** Transaction deposit value as decimal */
  depositValueDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  feeValue: Scalars['Float']['output'];
  /** Transaction fee value as decimal */
  feeValueDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  includedAt: BitqueryDateTime;
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
  invalidBefore: Scalars['String']['output'];
  invalidHereafter: Scalars['String']['output'];
  metadata: Scalars['String']['output'];
  txSize: Scalars['Int']['output'];
  /** Transaction value in input */
  valueIn: Scalars['Float']['output'];
  /** Transaction value in input as decimal */
  valueInDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  /** Transaction value in output */
  valueOut: Scalars['Float']['output'];
  /** Transaction value in output as decimal */
  valueOutDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
  withdrawalValue: Scalars['Float']['output'];
  /** Transaction withdraw value as decimal */
  withdrawalValueDecimal: Scalars['BitqueryDecimalNumberAsDiv']['output'];
};

/** Transaction Input */
export type BitqueryCardanoTransactionInput = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Input count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the input */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Input address */
  inputAddress?: Maybe<BitqueryAddress>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Source of the input */
  source?: Maybe<BitqueryCardanoInputSource>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputAnyArgs = {
  of: BitqueryCardanoInputsMeasureable;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputCountArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoInputUniq>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoInputUniq>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputInputAddressArgs = {
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputInputIndexArgs = {
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoInputsMeasureable>;
  of: BitqueryCardanoInputsMeasureable;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoInputsMeasureable>;
  of: BitqueryCardanoInputsMeasureable;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputOutputTransactionArgs = {
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryStringIdSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Input */
export type BitqueryCardanoTransactionInputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

/** Transaction Mint */
export type BitqueryCardanoTransactionMint = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Mint count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Mint count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the mint */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Mint value */
  value?: Maybe<Scalars['Float']['output']>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintAnyArgs = {
  of: BitqueryCardanoMintsMeasureable;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintCountArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoMintUniq>;
  value?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoMintUniq>;
  value?: InputMaybe<BitqueryFloatSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoMintsMeasureable>;
  of: BitqueryCardanoMintsMeasureable;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoMintsMeasureable>;
  of: BitqueryCardanoMintsMeasureable;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Mint */
export type BitqueryCardanoTransactionMintValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<BitqueryFloatSelector>;
};

/** Transaction Output */
export type BitqueryCardanoTransactionOutput = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Output count */
  count?: Maybe<Scalars['Int']['output']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the output */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Output address */
  outputAddress?: Maybe<BitqueryAddress>;
  /** Output guessed direction */
  outputDirection?: Maybe<BitqueryCardanoOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']['output']>;
  /** Transaction ID Hash */
  transaction?: Maybe<BitqueryTransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputAnyArgs = {
  of: BitqueryCardanoOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputCountArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoOutputUniq>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputCountBigIntArgs = {
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryCardanoOutputUniq>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputMaximumArgs = {
  get?: InputMaybe<BitqueryCardanoOutputsMeasureable>;
  of: BitqueryCardanoOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputMinimumArgs = {
  get?: InputMaybe<BitqueryCardanoOutputsMeasureable>;
  of: BitqueryCardanoOutputsMeasureable;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputOutputAddressArgs = {
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputOutputDirectionArgs = {
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputOutputIndexArgs = {
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputTransactionArgs = {
  txId?: InputMaybe<BitqueryStringIdSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  outputAddress?: InputMaybe<BitqueryAddressSelector>;
  outputDirection?: InputMaybe<BitqueryCardanoOutputDirectionSelector>;
  outputIndex?: InputMaybe<BitqueryIntegerSelector>;
  outputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction Output */
export type BitqueryCardanoTransactionOutputValueDecimalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryCardanoCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  inOutputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inOutputTxId?: InputMaybe<BitqueryHashSelector>;
  inputAddress?: InputMaybe<BitqueryAddressSelector>;
  inputIndex?: InputMaybe<BitqueryIntegerSelector>;
  inputSource?: InputMaybe<BitqueryCardanoInputSourcenSelector>;
  inputValue?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryCardanoTransactionUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type BitqueryCardanoTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Transaction deposit value */
  | 'deposit_value'
  /** Input count */
  | 'input_count'
  /** Transaction input value */
  | 'input_value'
  /** Transaction mint count */
  | 'mint_count'
  /** Output count */
  | 'output_count'
  /** Transaction output value */
  | 'output_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction index */
  | 'tx_index'
  /** Transaction size */
  | 'tx_size'
  /** Transaction withdrawal count */
  | 'withdrawal_count'
  /** Transaction withdrawal value */
  | 'withdrawal_value';

/** Transaction attributes in coinpath */
export type BitqueryCoinpathEntry = {
  /** Amount involved in the flow */
  amount: Scalars['Float']['output'];
  /** Block of transaction */
  height: Scalars['Int']['output'];
  /** Time of transaction in ISO 8601 format */
  timestamp: Scalars['BitqueryISO8601DateTime']['output'];
  /** Hash of transaction */
  txHash: Scalars['String']['output'];
  /** Amount transfered in transaction */
  txValue: Scalars['Float']['output'];
};

export type BitqueryCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitqueryCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: InputMaybe<Scalars['Int']['input']>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Flow direction */
  direction?: InputMaybe<BitqueryFlowDirection>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: InputMaybe<Scalars['Int']['input']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
};

/** Conflux Chain */
export type BitqueryConflux = {
  /** Conflux Active Addresses */
  activeAddresses?: Maybe<Array<BitqueryConfluxActiveAddress>>;
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryConfluxAddressInfoWithBalance>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryConfluxArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryConfluxBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryConfluxCoinpath>>;
  /** References of Smart Contract Calls and Events */
  references?: Maybe<Array<BitqueryConfluxReferencess>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryConfluxSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryConfluxSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryConfluxTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryConfluxTransfers>>;
};


/** Conflux Chain */
export type BitqueryConfluxActiveAddressesArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxAddressArgs = {
  address: Array<BitqueryConfluxAddressSelectorIn>;
};


/** Conflux Chain */
export type BitqueryConfluxArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryConfluxArgumentFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Conflux Chain */
export type BitqueryConfluxBlocksArgs = {
  any?: InputMaybe<Array<BitqueryConfluxBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Conflux Chain */
export type BitqueryConfluxCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryConfluxAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryConfluxAddressSelector>;
  sender?: InputMaybe<BitqueryConfluxAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxReferencesArgs = {
  any?: InputMaybe<Array<BitqueryConfluxReferencesFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryConfluxSmartContractCallFilter>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxSmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryConfluxSmartContractEventFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Conflux Chain */
export type BitqueryConfluxTransactionsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryConfluxTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Conflux Chain */
export type BitqueryConfluxTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryConfluxTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address that have been active in transfers */
export type BitqueryConfluxActiveAddress = {
  /** Transfer address */
  address?: Maybe<BitqueryConfluxAddressInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Address that have been active in transfers */
export type BitqueryConfluxActiveAddressCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddressUniq;
};


/** Address that have been active in transfers */
export type BitqueryConfluxActiveAddressCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddressUniq;
};

/** Address detailed information for Conflux network */
export type BitqueryConfluxAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryConfluxSmartContractInfo>;
};

/** Blockchain address */
export type BitqueryConfluxAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<BitqueryConfluxBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryConfluxSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type BitqueryConfluxAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Blockchain address */
export type BitqueryConfluxAddressInfoWithBalanceBalancesArgs = {
  currency?: InputMaybe<BitqueryConfluxCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelectorRange>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/**
 * Address should start from cfx: and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryConfluxAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * Address should start from cfx: and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryConfluxAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
};

export type BitqueryConfluxArgumentFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

/** Argument name and value of smart contract call or event */
export type BitqueryConfluxArgumentNameValue = {
  /** Argument name */
  argument: Scalars['String']['output'];
  /** Argument data type */
  argumentType: Scalars['String']['output'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  /** Value as String */
  value: Scalars['String']['output'];
};

/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArguments = {
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryConfluxAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryConfluxSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<BitqueryArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryConfluxArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export type BitqueryConfluxArgumentsConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type BitqueryConfluxArgumentsMeasureable =
  /** Argument */
  | 'argument'
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Balance in a currency */
export type BitqueryConfluxBalance = {
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<BitqueryConfluxBalanceChange>>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Balance in a currency */
export type BitqueryConfluxBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type BitqueryConfluxBalanceChange = {
  /** Block number (height) in blockchain */
  block: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['BitqueryISO8601DateTime']['output']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryConfluxBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocks = {
  /** Block is adaptive */
  adaptive: Scalars['Boolean']['output'];
  any?: Maybe<Scalars['String']['output']>;
  /** Blame */
  blame: Scalars['Int']['output'];
  /** Block index in epoch */
  blockPosition: Scalars['Int']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Epoch in blockchain */
  epoch: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block height in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block miner */
  miner?: Maybe<BitqueryEthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block nonce */
  nonce: Scalars['Int']['output'];
  /** Parent block hash */
  parentHash: Scalars['String']['output'];
  /** Block is pivot */
  pivot: Scalars['Boolean']['output'];
  /** Power Quality */
  powerQuality: Scalars['BitqueryBigInt']['output'];
  refereeCount?: Maybe<Scalars['Int']['output']>;
  refereeCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Reference Block hash */
  referenceBlockHash: Scalars['String']['output'];
  size?: Maybe<Scalars['Int']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalDifficulty?: Maybe<Scalars['Float']['output']>;
  transactionCount?: Maybe<Scalars['Int']['output']>;
  transactionCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of Transaction included in block */
  txHash: Scalars['String']['output'];
  uncleCount?: Maybe<Scalars['Int']['output']>;
  uncleCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksAnyArgs = {
  of: BitqueryConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksEpochArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxBlocksMeasureable>;
  of: BitqueryConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksMinerArgs = {
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxBlocksMeasureable>;
  of: BitqueryConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksRefereeCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksRefereeCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksReferenceBlockHashArgs = {
  referenceBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksSizeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTotalDifficultyArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksTxHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksUncleCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type BitqueryConfluxBlocksUncleCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBlockSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  pivot?: InputMaybe<Scalars['Boolean']['input']>;
  refereeCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  referenceBlockHash?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export type BitqueryConfluxBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Block Miner */
  | 'miner'
  /** Block Referee Count */
  | 'referee_count'
  /** Time */
  | 'time'
  /** Block TX Count */
  | 'transaction_count';

export type BitqueryConfluxCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Coinpath */
export type BitqueryConfluxCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryConfluxCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryConfluxCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryConfluxCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryConfluxCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryConfluxCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryConfluxCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Conflux network */
export type BitqueryConfluxCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryConfluxSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in Conflux blockchain.
 *   Currencies supported are native ( CFX ), ERC20, ERC721 tokens.
 *   You can specify currency symbol or smart contract address. Symbols CFX are reserved for native currencies in Conflux mainnet and classic.
 *   Conflux Smart contract address should start from cfx: and contain 42 symbols.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryConfluxCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryConfluxEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract Event Signature */
  | 'signature'
  /** Smart Contract Event Signature Hash */
  | 'signature_hash'
  /** Smart Contract Event Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryConfluxNetwork =
  /** Conflux Hydra */
  | 'conflux_hydra'
  /** Conflux Oceanus */
  | 'conflux_oceanus'
  /** Conflux Tethys */
  | 'conflux_tethys';

export type BitqueryConfluxReferencesFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address value of method or event argument */
export type BitqueryConfluxReferencess = {
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryConfluxAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessCallerArgs = {
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryConfluxReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryConfluxReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryConfluxReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Address value of method or event argument */
export type BitqueryConfluxReferencessTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryConfluxReferencessConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type BitqueryConfluxReferencessMeasureable =
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Conflux smart contract */
export type BitqueryConfluxSmartContract = {
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryConfluxSmartContractCallFilter = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCalls = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryConfluxArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryConfluxAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryConfluxSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsAnyArgs = {
  of: BitqueryConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsCountArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsCountBigIntArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxCallsMeasureable>;
  of: BitqueryConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxCallsMeasureable>;
  of: BitqueryConfluxCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryConfluxSmartContractCallsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

/** Smart Contract Events */
export type BitqueryConfluxSmartContractEvent = {
  any?: Maybe<Scalars['String']['output']>;
  /** Event arguments */
  arguments?: Maybe<Array<BitqueryConfluxArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryConfluxSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** Transaction where event happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventAnyArgs = {
  of: BitqueryConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxEventsMeasureable>;
  of: BitqueryConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxEventsMeasureable>;
  of: BitqueryConfluxEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryConfluxSmartContractEventTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryConfluxSmartContractEventFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitqueryConfluxSmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain smart contract */
export type BitqueryConfluxSmartContractInfo = {
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryConfluxSmartContractInfoWithAttribute = {
  /** Value as address if applicable */
  address?: Maybe<BitqueryConfluxAddressInfo>;
  /** Method name */
  name: Scalars['String']['output'];
  /** Method return type */
  type: Scalars['String']['output'];
  /** Method return value */
  value: Scalars['String']['output'];
};

/** Blockchain smart contract */
export type BitqueryConfluxSmartContractInfoWithAttributes = {
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<BitqueryConfluxSmartContractInfoWithAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

/** Selector of smart contract type */
export type BitqueryConfluxSmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: InputMaybe<Array<BitquerySmartContractType>>;
  /** Smart Contract type is */
  is?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not */
  not?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: InputMaybe<Array<BitquerySmartContractType>>;
};

export type BitqueryConfluxTransactionFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};

/** Blockchain transaction info */
export type BitqueryConfluxTransactionInfo = {
  /** Gas consumed */
  gas: Scalars['Int']['output'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  /** Gas value cost */
  gasValue: Scalars['Float']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction from address */
  txFrom: BitqueryConfluxAddressInfo;
};

/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactions = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Created smart contract */
  creates?: Maybe<BitqueryEthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Error message if any */
  error?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Transaction sender */
  sender?: Maybe<BitqueryEthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction receiver */
  to?: Maybe<BitqueryEthereumAddressInfo>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsAnyArgs = {
  of: BitqueryConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsCreatesArgs = {
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasPriceArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxTransactionsMeasureable>;
  of: BitqueryConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxTransactionsMeasureable>;
  of: BitqueryConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Conflux blockchain */
export type BitqueryConfluxTransactionsToArgs = {
  txTo?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};

export type BitqueryConfluxTransactionsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Gas value */
  | 'gas_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender';

export type BitqueryConfluxTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfers = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryConfluxAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<BitqueryConfluxAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryConfluxTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersAnyArgs = {
  of: BitqueryConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryConfluxCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryConfluxTransfersMeasureable>;
  of: BitqueryConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryConfluxTransfersMeasureable>;
  of: BitqueryConfluxTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryConfluxTransfersTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryConfluxAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryConfluxTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Cosmos Blockchain */
export type BitqueryCosmos = {
  /** Basic information about address */
  address: Array<BitqueryCosmosAddressInfo>;
  /** Cosmos Attributes */
  attributes?: Maybe<Array<BitqueryCosmosAttribute>>;
  /** Cosmos Blocks */
  blocks?: Maybe<Array<BitqueryCosmosBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryCosmosCoinpath>>;
  /** Cosmos Messages */
  messages?: Maybe<Array<BitqueryCosmosMessage>>;
  /** Cosmos Transactions */
  transactions?: Maybe<Array<BitqueryCosmosTransaction>>;
  /** Cosmos Transfers */
  transfers?: Maybe<Array<BitqueryCosmosTransfers>>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosAttributesArgs = {
  any?: InputMaybe<Array<BitqueryCosmosAttributeFilter>>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosBlocksArgs = {
  any?: InputMaybe<Array<BitqueryCosmosBlocksFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryCosmosCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosMessagesArgs = {
  any?: InputMaybe<Array<BitqueryCosmosMessageFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryCosmosTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Cosmos Blockchain */
export type BitqueryCosmosTransfersArgs = {
  any?: InputMaybe<Array<BitqueryCosmosTransferFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};

/** Address detailed information for Cosmos network */
export type BitqueryCosmosAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Tokens Info */
  tokensInfo?: Maybe<Array<BitqueryCosmosTokensInfo>>;
};


/** Address detailed information for Cosmos network */
export type BitqueryCosmosAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttribute = {
  any?: Maybe<Scalars['String']['output']>;
  /** Attribute */
  attribute?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Type of the attribute */
  eventType?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message info */
  message?: Maybe<BitqueryCosmosMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction info where message included */
  transaction?: Maybe<BitqueryCosmosTransactionDimension>;
  /** Attribute value */
  value?: Maybe<Scalars['String']['output']>;
  /** Index of attribute */
  valueIndex: Scalars['Int']['output'];
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeAnyArgs = {
  of: BitqueryCosmosAttributesMeasurable;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeCountArgs = {
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosAttributeUniq>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeCountBigIntArgs = {
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosAttributeUniq>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosAttributesMeasurable>;
  of: BitqueryCosmosAttributesMeasurable;
};


/** Attribute in Cosmos blockchain */
export type BitqueryCosmosAttributeMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosAttributesMeasurable>;
  of: BitqueryCosmosAttributesMeasurable;
};

export type BitqueryCosmosAttributeFilter = {
  attribute?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventType?: InputMaybe<BitqueryStringSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageType?: InputMaybe<BitqueryStringSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryCosmosAttributeUniq =
  /** Unique attributes */
  | 'attributes'
  /** Unique block hashes */
  | 'blockHashes'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique event types */
  | 'eventTypes'
  /** Unique message indices */
  | 'messageIndices'
  /** Unique message senders */
  | 'messageSenders'
  /** Unique message types */
  | 'messageTypes'
  /** Unique time */
  | 'times'
  /** Unique transaction hashes */
  | 'transactionHashes'
  /** Unique transaction indices */
  | 'transactionIndices'
  /** Unique transaction signers */
  | 'transactionSigners'
  /** Unique value indices */
  | 'valueIndices'
  /** Unique values */
  | 'values';

export type BitqueryCosmosAttributesMeasurable =
  /**  attribute  */
  | 'attribute'
  /** Number of block in the blockhains */
  | 'block'
  /** Hash of the block */
  | 'blockHash'
  /** Date */
  | 'date'
  /** Type of attr */
  | 'eventType'
  /** Message index in transaction */
  | 'messageIndex'
  /** Message senders */
  | 'messageSenders'
  /** Message success */
  | 'messageSuccess'
  /** Type of message */
  | 'messageType'
  /** Time */
  | 'time'
  /** Hash of the transaction */
  | 'transactionHash'
  /** Index of the transaction in block */
  | 'transactionIndex'
  /** Transaction Signer */
  | 'transactionSigner'
  /** attributeValue */
  | 'value'
  /** valueIndex */
  | 'valueIndex';

/** Block */
export type BitqueryCosmosBlock = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block Header */
  header?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proposer Address */
  proposer?: Maybe<BitqueryAddress>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Block */
export type BitqueryCosmosBlockAnyArgs = {
  of: BitqueryCosmosBlockMeasurable;
};


/** Block */
export type BitqueryCosmosBlockCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryCosmosBlockUniq>;
};


/** Block */
export type BitqueryCosmosBlockCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryCosmosBlockUniq>;
};


/** Block */
export type BitqueryCosmosBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryCosmosBlockMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosBlockMeasurable>;
  of: BitqueryCosmosBlockMeasurable;
};


/** Block */
export type BitqueryCosmosBlockMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosBlockMeasurable>;
  of: BitqueryCosmosBlockMeasurable;
};

/** Information about block */
export type BitqueryCosmosBlockDimension = {
  /** Block Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

export type BitqueryCosmosBlockMeasurable =
  /** Date */
  | 'date'
  /** Block hash */
  | 'hash'
  /** Block */
  | 'height'
  /** Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type BitqueryCosmosBlockUniq =
  /** Number of block in the blockchains */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Block Hash */
  | 'hashes'
  /** Block proposer */
  | 'proposers'
  /** Unique timestamps count */
  | 'times';

export type BitqueryCosmosBlocksFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Coinpath */
export type BitqueryCosmosCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Message of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValue>;
};


/** Coinpath */
export type BitqueryCosmosCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryCosmosCoinpathAnyArgs = {
  of: BitqueryCosmosCoinpathMeasurable;
};


/** Coinpath */
export type BitqueryCosmosCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosCoinpathMeasurable>;
  of: BitqueryCosmosCoinpathMeasurable;
};


/** Coinpath */
export type BitqueryCosmosCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosCoinpathMeasurable>;
  of: BitqueryCosmosCoinpathMeasurable;
};

export type BitqueryCosmosCoinpathMeasurable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transaction_hash';

/** Currency selector in Cosmos blockchain */
export type BitqueryCosmosCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Message in Cosmos blockchain */
export type BitqueryCosmosMessage = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index in tx */
  index: Scalars['Int']['output'];
  /** Body of message  */
  json?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']['output']>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction info where message included */
  transaction?: Maybe<BitqueryCosmosTransactionDimension>;
  /** Type of the message */
  type?: Maybe<Scalars['String']['output']>;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageAnyArgs = {
  of: BitqueryCosmosMessageMeasurable;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosMessageUniq>;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosMessageUniq>;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosMessageMeasurable>;
  of: BitqueryCosmosMessageMeasurable;
};


/** Message in Cosmos blockchain */
export type BitqueryCosmosMessageMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosMessageMeasurable>;
  of: BitqueryCosmosMessageMeasurable;
};

/** Information about message */
export type BitqueryCosmosMessageDimension = {
  /** Index in tx */
  index: Scalars['Int']['output'];
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']['output']>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the message */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryCosmosMessageFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  senders?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryCosmosMessageMeasurable =
  /** Hash of the block */
  | 'blockHash'
  /** Number of block in the blockhains */
  | 'blockHeight'
  /** Date */
  | 'date'
  /** Message index in transaction */
  | 'index'
  /** Message json */
  | 'json'
  /** Message senders */
  | 'senders'
  /** Message success */
  | 'success'
  /** Time */
  | 'time'
  /** Hash of the transaction */
  | 'transactionHash'
  /** Index of the transaction */
  | 'transactionIndex'
  /** Transaction Signer */
  | 'transactionSigner'
  /** Type of message */
  | 'type';

export type BitqueryCosmosMessageUniq =
  /** Uniq blocks */
  | 'blocks'
  /** Uniq date */
  | 'dates'
  /** Uniq senders */
  | 'senders'
  /** Uniq transaction hashes */
  | 'transactionHashes'
  /** Uniq transaction indices */
  | 'transactionIndices'
  /** Uniq transaction signers */
  | 'transactionSigners'
  /** Uniq types */
  | 'types';

export type BitqueryCosmosNetwork =
  /** Cosmos Hub Network */
  | 'cosmoshub'
  /** Crypto.org Mainnet */
  | 'crypto_mainnet'
  /** Crypto.org Croeseid Testnet */
  | 'crypto_testnet'
  /** Heimdall (Matic Verification Network) */
  | 'heimdall'
  /** Terra Mainnet */
  | 'terra';

/** Tokens Info */
export type BitqueryCosmosTokensInfo = {
  /** Token Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Denom */
  denom?: Maybe<Scalars['String']['output']>;
};

/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransaction = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  /** code */
  code?: Maybe<Scalars['Int']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  feeDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Gas Used */
  gasUsed: Scalars['BitqueryBigInt']['output'];
  /** Gas Wanted */
  gasWanted: Scalars['BitqueryBigInt']['output'];
  /** Hash of the transactions */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction in block */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memo */
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Raw Tx */
  rawTx?: Maybe<Scalars['String']['output']>;
  /** Transaction Signer */
  signer?: Maybe<BitqueryAddress>;
  /** Succeeded or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Type of the transactions */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionAnyArgs = {
  of: BitqueryCosmosTransactionMeasurable;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransactionUniq>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransactionUniq>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionFeeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionFeeDecimalArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionGasUsedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionGasWantedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosTransactionMeasurable>;
  of: BitqueryCosmosTransactionMeasurable;
};


/** Transaction in Cosmos blockchain */
export type BitqueryCosmosTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosTransactionMeasurable>;
  of: BitqueryCosmosTransactionMeasurable;
};

/** Information about transaction */
export type BitqueryCosmosTransactionDimension = {
  /** Hash of the transactions */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction in block */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction Signer */
  signer?: Maybe<BitqueryAddress>;
};

export type BitqueryCosmosTransactionFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  code?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryAmountSelector>;
  gasUsed?: InputMaybe<BitqueryIntegerSelector>;
  gasWanted?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  memo?: InputMaybe<BitqueryStringSelector>;
  signer?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryCosmosTransactionMeasurable =
  /** Hash of the block */
  | 'block_hash'
  /** Number of block in the blockhains */
  | 'block_height'
  /** Transaction Code */
  | 'code'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee'
  /** Hash of the transaction */
  | 'hash'
  /** Transaction Index */
  | 'index'
  /** Transaction Memo */
  | 'memo'
  /** Raw Transaction */
  | 'rawTx'
  /** Transaction Signer */
  | 'signer'
  /** Time */
  | 'time'
  /** Type of the transaction */
  | 'type';

export type BitqueryCosmosTransactionUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique timecodes */
  | 'codes'
  /** Unique date count */
  | 'dates'
  /** Unique hashes */
  | 'hashes'
  /** Unique indices */
  | 'indices'
  /** Unique memos */
  | 'memos'
  /** Unique signers */
  | 'signers'
  /** Unique time */
  | 'times'
  /** Unique types */
  | 'types';

export type BitqueryCosmosTransferFilter = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};

export type BitqueryCosmosTransferUniq =
  /** Unique block hashes */
  | 'blockHashes'
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique dates */
  | 'dates'
  /** Unique message indices */
  | 'messageIndices'
  /** Unique message types */
  | 'messageTypes'
  /** Unique time */
  | 'receiver'
  /** Unique senders (field sender) */
  | 'sender'
  /** Unique senders (field senders) */
  | 'senders'
  /** Unique times */
  | 'times'
  /** Unique transaction hashes */
  | 'transactionHashes'
  /** Unique transaction indices */
  | 'transactionIndices'
  /** Unique transaction signers */
  | 'transactionSigners'
  /** Unique transfer types */
  | 'types';

/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfers = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block info where transaction included */
  block?: Maybe<BitqueryCosmosBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of the transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Is delegated */
  delegated?: Maybe<Scalars['Boolean']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Index in tx */
  messageIndex: Scalars['Int']['output'];
  /** Type of the message */
  messageType?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Message sender(s) */
  senders?: Maybe<Scalars['String']['output']>;
  /** Transaction info where message included */
  transaction?: Maybe<BitqueryCosmosTransactionDimension>;
  /** Type of the Transfer */
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
  valueDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersAnyArgs = {
  of: BitqueryCosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersCountArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransferUniq>;
  value?: InputMaybe<BitqueryAmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersCountBigIntArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  uniq?: InputMaybe<BitqueryCosmosTransferUniq>;
  value?: InputMaybe<BitqueryAmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryCosmosTransfersMeasurable>;
  of: BitqueryCosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryCosmosTransfersMeasurable>;
  of: BitqueryCosmosTransfersMeasurable;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersValueArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};


/** Transfers in Cosmos  blockchain */
export type BitqueryCosmosTransfersValueDecimalArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCosmosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  senders?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSigner?: InputMaybe<BitqueryAddressSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  typeTransfer?: InputMaybe<BitqueryBooleanSelector>;
  value?: InputMaybe<BitqueryAmountSelector>;
};

export type BitqueryCosmosTransfersMeasurable =
  /** Hash of the block */
  | 'blockHash'
  /** Currency Address */
  | 'currency_address'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Message index in transaction */
  | 'messageIndex'
  /** Type of message */
  | 'messageType'
  /** Transfer To */
  | 'receiver'
  /** Transfer From */
  | 'sender'
  /** Message senders */
  | 'senders'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Hash of the transaction */
  | 'transactionHash'
  /** Index of the transaction */
  | 'transactionIndex'
  /** Transaction Signer */
  | 'transactionSigner'
  /** Type of transfer */
  | 'type'
  /** Transfer value */
  | 'value';

/** Crypto currency ( token, coin, currency ) */
export type BitqueryCurrency = {
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Decimals */
  decimals: Scalars['Int']['output'];
  /** Currency name */
  name?: Maybe<Scalars['String']['output']>;
  /** Properties */
  properties?: Maybe<Scalars['String']['output']>;
  /** Currency symbol */
  symbol: Scalars['String']['output'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']['output']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']['output']>;
};

/** Currency selector */
export type BitqueryCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Instruction Data */
export type BitqueryData = {
  base58: Scalars['String']['output'];
  hex: Scalars['String']['output'];
};

/** Date */
export type BitqueryDate = {
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String']['output'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int']['output'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int']['output'];
  /** Month number (1-12) */
  month: Scalars['Int']['output'];
  /**
   * Returns start of date interval ,
   *     date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
   *   starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
   */
  startOfInterval: Scalars['String']['output'];
  /** Year number */
  year: Scalars['Int']['output'];
};


/** Date */
export type BitqueryDateDateArgs = {
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Date */
export type BitqueryDateStartOfIntervalArgs = {
  format?: InputMaybe<Scalars['String']['input']>;
  interval?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  unit: BitqueryDateInterval;
};

export type BitqueryDateInterval =
  /** Day */
  | 'day'
  /** Month */
  | 'month'
  /** Week */
  | 'week'
  /** Year */
  | 'year';

/** Selecting the date in a range, list or just date */
export type BitqueryDateSelector = {
  /** After date */
  after?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Before date */
  before?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Range of dates */
  between?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** In dates */
  in?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Date equals */
  is?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Date not equals */
  not?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Not in dates */
  notIn?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Since date */
  since?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Till date */
  till?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
};

/** Date and Time */
export type BitqueryDateTime = {
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int']['output'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int']['output'];
  /** Hour (0-23) */
  hour: Scalars['Int']['output'];
  /** ISO8601 date time such as '2020-03-02T13:30:41+00:00' */
  iso8601: Scalars['BitqueryISO8601DateTime']['output'];
  /** Minute (0-59) */
  minute: Scalars['Int']['output'];
  /** Month number (1-12) */
  month: Scalars['Int']['output'];
  /** Second (0-59) */
  second: Scalars['Int']['output'];
  /** String date representation with default format as YYYY-MM-DD */
  time: Scalars['String']['output'];
  /** Unix timestamp */
  unixtime: Scalars['Int']['output'];
  /** Year number */
  year: Scalars['Int']['output'];
};


/** Date and Time */
export type BitqueryDateTimeTimeArgs = {
  format?: InputMaybe<Scalars['String']['input']>;
};

/** Selecting the time in a range, list or just time */
export type BitqueryDateTimeSelector = {
  /** After time */
  after?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Before time */
  before?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Range of time */
  between?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** In times */
  in?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Time equals */
  is?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Time not equals */
  not?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Not in times */
  notIn?: InputMaybe<Array<Scalars['BitqueryISO8601DateTime']['input']>>;
  /** Since time */
  since?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
  /** Till time */
  till?: InputMaybe<Scalars['BitqueryISO8601DateTime']['input']>;
};

export type BitqueryDiemNetwork =
  /** Diem Testnet */
  | 'diem_testnet'
  /** Libra Testnet */
  | 'libra_testnet';

/** Elrond Chain */
export type BitqueryElrond = {
  /** Basic information about address */
  address: Array<BitqueryElrondAddressInfoWithBalance>;
  /** Information about validators of the block */
  blockValidators?: Maybe<Array<BitqueryElrondBlockValidator>>;
  /** Information about blocks */
  blocks?: Maybe<Array<BitqueryElrondBlock>>;
  /** Information about calls */
  callResults?: Maybe<Array<BitqueryElrondCallResult>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryElrondCoinpath>>;
  /** Information about Event */
  events?: Maybe<Array<BitqueryElrondEvent>>;
  /** Information about miniblocks */
  miniblocks?: Maybe<Array<BitqueryElrondMiniblock>>;
  /** Information about notarized block */
  notarizedBlock?: Maybe<Array<BitqueryElrondNotarizedBlock>>;
  /** Information about Token Operations */
  operations?: Maybe<Array<BitqueryElrondOperation>>;
  /** Information about transactions */
  transactions?: Maybe<Array<BitqueryElrondTransaction>>;
  /** Information about transactions */
  transfers?: Maybe<Array<BitqueryElrondTransfer>>;
};


/** Elrond Chain */
export type BitqueryElrondAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Elrond Chain */
export type BitqueryElrondBlockValidatorsArgs = {
  any?: InputMaybe<Array<BitqueryElrondBlockValidatorFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  validator?: InputMaybe<BitqueryHashSelector>;
};


/** Elrond Chain */
export type BitqueryElrondBlocksArgs = {
  any?: InputMaybe<Array<BitqueryElrondBlockFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Elrond Chain */
export type BitqueryElrondCallResultsArgs = {
  any?: InputMaybe<Array<BitqueryElrondCallResultFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Elrond Chain */
export type BitqueryElrondEventsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryElrondEventFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultPath?: InputMaybe<BitqueryStringSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  eventType?: InputMaybe<BitqueryEventTypeSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  identifier?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondMiniblocksArgs = {
  any?: InputMaybe<Array<BitqueryElrondMiniblockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  receiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  receiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondNotarizedBlockArgs = {
  any?: InputMaybe<Array<BitqueryElrondNotarizedBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  notarizedBlockHash?: InputMaybe<BitqueryHashSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Elrond Chain */
export type BitqueryElrondOperationsArgs = {
  any?: InputMaybe<Array<BitqueryElrondOperationFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  operationAction?: InputMaybe<BitqueryStringSelector>;
  operationData?: InputMaybe<BitqueryStringSelector>;
  operationIndex?: InputMaybe<BitqueryIntegerSelector>;
  operationReceiver?: InputMaybe<BitqueryAddressSelector>;
  operationSender?: InputMaybe<BitqueryAddressSelector>;
  operationType?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondTransactionsArgs = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitqueryElrondTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Elrond Chain */
export type BitqueryElrondTransfersArgs = {
  action?: InputMaybe<BitqueryActionSelector>;
  any?: InputMaybe<Array<BitqueryElrondTransferFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

/** Blockchain address hash */
export type BitqueryElrondAddressHash = {
  /** String hex address representation */
  hex: Scalars['String']['output'];
};

/** Address detailed information for Elrond network */
export type BitqueryElrondAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Extra information abount address from node */
  extraInfo?: Maybe<BitqueryElrondExtraInfo>;
  /** Staked EGLD */
  staking?: Maybe<Scalars['Float']['output']>;
  /** Tokens Info */
  tokensInfo?: Maybe<Array<BitqueryElrondTokensInfo>>;
};


/** Address detailed information for Elrond network */
export type BitqueryElrondAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Address detailed information for Elrond network */
export type BitqueryElrondAddressInfoWithBalanceStakingArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlock = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  proposer?: Maybe<BitqueryElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']['output']>;
  /** Round */
  round?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Size */
  size?: Maybe<Scalars['Int']['output']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']['output']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockAnyArgs = {
  of: BitqueryElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockCountArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockMaximumArgs = {
  get?: InputMaybe<BitqueryElrondBlocksMeasureable>;
  of: BitqueryElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type BitqueryElrondBlockMinimumArgs = {
  get?: InputMaybe<BitqueryElrondBlocksMeasureable>;
  of: BitqueryElrondBlocksMeasureable;
};

/** Information about block */
export type BitqueryElrondBlockDimension = {
  /** Epoch */
  epoch?: Maybe<Scalars['Int']['output']>;
  /** Hash of the block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  proposer?: Maybe<BitqueryElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']['output']>;
  /** Round */
  round?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Size */
  size?: Maybe<Scalars['Int']['output']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']['output']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']['output']>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

export type BitqueryElrondBlockFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryElrondBlockUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidator = {
  any?: Maybe<Scalars['String']['output']>;
  /** Information about blocks notarized block */
  block?: Maybe<BitqueryElrondBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Hash of validator */
  validator?: Maybe<BitqueryElrondAddressHash>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorAnyArgs = {
  of: BitqueryElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorCountArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorMaximumArgs = {
  get?: InputMaybe<BitqueryElrondBlockValidatorsMeasureable>;
  of: BitqueryElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type BitqueryElrondBlockValidatorMinimumArgs = {
  get?: InputMaybe<BitqueryElrondBlockValidatorsMeasureable>;
  of: BitqueryElrondBlockValidatorsMeasureable;
};

export type BitqueryElrondBlockValidatorFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  validator?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryElrondBlockValidatorUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times'
  /** Unique number of validators */
  | 'validators';

export type BitqueryElrondBlockValidatorsMeasureable =
  /** Date */
  | 'date'
  /** Block epoch */
  | 'epoch'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Block nonce */
  | 'nonce'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Block proposer */
  | 'proposer'
  /** Block public key bitmap */
  | 'public_key_bitmap'
  /** Block round */
  | 'round'
  /** Shard number of block */
  | 'shard'
  /** Block size */
  | 'size'
  /** Block size txs */
  | 'size_txs'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count'
  /** Hash of the validator */
  | 'validator';

export type BitqueryElrondBlocksMeasureable =
  /** Date */
  | 'date'
  /** Block epoch */
  | 'epoch'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Block nonce */
  | 'nonce'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Block proposer */
  | 'proposer'
  /** Block public key bitmap */
  | 'public_key_bitmap'
  /** Block round */
  | 'round'
  /** Shard number of block */
  | 'shard'
  /** Block size */
  | 'size'
  /** Block size txs */
  | 'size_txs'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count';

/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResult = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Call result data */
  data?: Maybe<Scalars['String']['output']>;
  /** Call result data operation */
  dataOperation?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Call result gas limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Call result gas price */
  gasPrice?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the call result */
  hash?: Maybe<Scalars['String']['output']>;
  /** Call result index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Nonce of the call result */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the previous transaction */
  previousTxHash?: Maybe<Scalars['String']['output']>;
  /** Call result receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Call result relayed */
  relayed?: Maybe<Scalars['String']['output']>;
  relayedValue?: Maybe<Scalars['Float']['output']>;
  /** Call result return message */
  returnMessage?: Maybe<Scalars['String']['output']>;
  /** Call result sender */
  sender?: Maybe<BitqueryAddress>;
  /** Information about calls block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Call result type */
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultAnyArgs = {
  of: BitqueryElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultCountArgs = {
  uniq?: InputMaybe<BitqueryElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultDataArgs = {
  callResultData?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultDataOperationArgs = {
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultExpressionArgs = {
  get: Scalars['String']['input'];
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultGasLimitArgs = {
  callResultGasLimit?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultGasPriceArgs = {
  callResultGasPrice?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultHashArgs = {
  callResultHash?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultIndexArgs = {
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultMaximumArgs = {
  get?: InputMaybe<BitqueryElrondCallResultsMeasureable>;
  of: BitqueryElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultMinimumArgs = {
  get?: InputMaybe<BitqueryElrondCallResultsMeasureable>;
  of: BitqueryElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultNonceArgs = {
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultPreviousTxHashArgs = {
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultReceiverArgs = {
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultRelayedArgs = {
  relayed?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultRelayedValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultReturnMessageArgs = {
  returnMessage?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultSenderArgs = {
  callResultSender?: InputMaybe<BitqueryHashSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultTypeArgs = {
  callResultType?: InputMaybe<BitqueryStringSelector>;
};


/** CallResults in Elrond blockchain */
export type BitqueryElrondCallResultValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondCallResultFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultData?: InputMaybe<BitqueryStringSelector>;
  callResultDataOperation?: InputMaybe<BitqueryStringSelector>;
  callResultGasLimit?: InputMaybe<BitqueryFloatSelector>;
  callResultGasPrice?: InputMaybe<BitqueryFloatSelector>;
  callResultHash?: InputMaybe<BitqueryHashSelector>;
  callResultIndex?: InputMaybe<BitqueryIntegerSelector>;
  callResultNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultReceiver?: InputMaybe<BitqueryHashSelector>;
  callResultRelayedValue?: InputMaybe<BitqueryFloatSelector>;
  callResultSender?: InputMaybe<BitqueryHashSelector>;
  callResultType?: InputMaybe<BitqueryStringSelector>;
  callResultValue?: InputMaybe<BitqueryFloatSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousTxHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  relayed?: InputMaybe<BitqueryStringSelector>;
  returnMessage?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondCallResultUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of call results */
  | 'index'
  /** Unique time */
  | 'times'
  /** Unique count of transactions */
  | 'txs';

export type BitqueryElrondCallResultsMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Data of the call result */
  | 'call_result_data'
  /** Hash of the call result */
  | 'call_result_hash'
  /** Index of the call result */
  | 'call_result_index'
  /** Receiver of the call result */
  | 'call_result_receiver'
  /** Sender of the call result */
  | 'call_result_sender'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Previous transaction hash of the call result */
  | 'previous_tx_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

/** Elrond Coinpath */
export type BitqueryElrondCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryElrondTransactionValueDimension>;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathAnyArgs = {
  of: BitqueryElrondCoinpathMeasureable;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryElrondCoinpathMeasureable>;
  of: BitqueryElrondCoinpathMeasureable;
};


/** Elrond Coinpath */
export type BitqueryElrondCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryElrondCoinpathMeasureable>;
  of: BitqueryElrondCoinpathMeasureable;
};

export type BitqueryElrondCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Events in Elrond blockchain */
export type BitqueryElrondEvent = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call Result Path */
  callResultPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Identifier */
  identifier?: Maybe<Scalars['String']['output']>;
  /** Index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Information about calls block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Data */
  topics?: Maybe<Array<Scalars['String']['output']>>;
  /** Information about transactions */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventAnyArgs = {
  of: BitqueryElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventCountArgs = {
  uniq?: InputMaybe<BitqueryElrondEventUniq>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondEventUniq>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventMaximumArgs = {
  get?: InputMaybe<BitqueryElrondEventsMeasureable>;
  of: BitqueryElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventMinimumArgs = {
  get?: InputMaybe<BitqueryElrondEventsMeasureable>;
  of: BitqueryElrondEventsMeasureable;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Events in Elrond blockchain */
export type BitqueryElrondEventValueArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callResultPath?: InputMaybe<BitqueryStringSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  eventType?: InputMaybe<BitqueryEventTypeSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  identifier?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondEventFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  callResultPath?: InputMaybe<BitqueryStringSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  eventType?: InputMaybe<BitqueryEventTypeSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  identifier?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondEventUniq =
  /** Unique date count */
  | 'dates'
  /** Unique count of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times'
  /** Unique count of transactions */
  | 'txs';

export type BitqueryElrondEventsMeasureable =
  /** Address */
  | 'address'
  /** Hash of the the block */
  | 'block_hash'
  /** Call Result Path */
  | 'call_result_path'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Event Index */
  | 'event_index'
  /** Event Type */
  | 'event_type'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Identifier */
  | 'identifier'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

export type BitqueryElrondExtraInfo = {
  /** Root Hash */
  rootHash?: Maybe<Scalars['String']['output']>;
  /** Shard */
  shard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transactions Count */
  txCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblock = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']['output']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']['output']>;
  /** Information about miniblocks block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockAnyArgs = {
  of: BitqueryElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockCountArgs = {
  uniq?: InputMaybe<BitqueryElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockMaximumArgs = {
  get?: InputMaybe<BitqueryElrondMiniblocksMeasureable>;
  of: BitqueryElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type BitqueryElrondMiniblockMinimumArgs = {
  get?: InputMaybe<BitqueryElrondMiniblocksMeasureable>;
  of: BitqueryElrondMiniblocksMeasureable;
};

export type BitqueryElrondMiniblockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  receiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  receiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondMiniblockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type BitqueryElrondMiniblocksMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Hash of the miniblock */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Hash of the miniblocks receiver block */
  | 'receiver_block_hash'
  /** Miniblock receiver shard */
  | 'receiver_shard'
  /** Time */
  | 'time'
  /** Count of transactions */
  | 'transaction_count'
  /** Type of miniblock */
  | 'type';

export type BitqueryElrondNetwork =
  /** Elrond mainnet */
  | 'elrond';

/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** Information about blocks notarized block */
  block?: Maybe<BitqueryElrondBlockDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Hash of the notarized block */
  notarizedBlockHash?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockAnyArgs = {
  of: BitqueryElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockCountArgs = {
  uniq?: InputMaybe<BitqueryElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockMaximumArgs = {
  get?: InputMaybe<BitqueryElrondNotarizedBlocksMeasureable>;
  of: BitqueryElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type BitqueryElrondNotarizedBlockMinimumArgs = {
  get?: InputMaybe<BitqueryElrondNotarizedBlocksMeasureable>;
  of: BitqueryElrondNotarizedBlocksMeasureable;
};

export type BitqueryElrondNotarizedBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  notarizedBlockHash?: InputMaybe<BitqueryHashSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryElrondNotarizedBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique hash of notarized block */
  | 'notarized_block_hash'
  /** Unique time */
  | 'times';

export type BitqueryElrondNotarizedBlocksMeasureable =
  /** Date */
  | 'date'
  /** Block epoch */
  | 'epoch'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Block nonce */
  | 'nonce'
  /** Notarized block hash */
  | 'notarized_block_hash'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Block proposer */
  | 'proposer'
  /** Block public key bitmap */
  | 'public_key_bitmap'
  /** Block round */
  | 'round'
  /** Shard number of block */
  | 'shard'
  /** Block size */
  | 'size'
  /** Block size txs */
  | 'size_txs'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count';

/** Operations in Elrond blockchain */
export type BitqueryElrondOperation = {
  /** Action */
  action?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message */
  message?: Maybe<Scalars['String']['output']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Information about calls block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationAnyArgs = {
  of: BitqueryElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationCountArgs = {
  uniq?: InputMaybe<BitqueryElrondOperationUniq>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondOperationUniq>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationMaximumArgs = {
  get?: InputMaybe<BitqueryElrondOperationsMeasureable>;
  of: BitqueryElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationMinimumArgs = {
  get?: InputMaybe<BitqueryElrondOperationsMeasureable>;
  of: BitqueryElrondOperationsMeasureable;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Operations in Elrond blockchain */
export type BitqueryElrondOperationTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryElrondOperationFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  operationAction?: InputMaybe<BitqueryStringSelector>;
  operationData?: InputMaybe<BitqueryStringSelector>;
  operationIndex?: InputMaybe<BitqueryIntegerSelector>;
  operationReceiver?: InputMaybe<BitqueryAddressSelector>;
  operationSender?: InputMaybe<BitqueryAddressSelector>;
  operationType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondOperationUniq =
  /** Unique date count */
  | 'dates'
  /** Unique count of block in the blockchains */
  | 'height'
  /** Unique count of operations */
  | 'operations'
  /** Unique time */
  | 'times'
  /** Unique count of transactions */
  | 'txs';

export type BitqueryElrondOperationsMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** Operation Action */
  | 'operation_action'
  /** Operation data */
  | 'operation_data'
  /** Operation Index */
  | 'operation_index'
  /** Operation message */
  | 'operation_message'
  /** Operation receiver */
  | 'operation_receiver'
  /** Operation sender */
  | 'operation_sender'
  /** Operation type */
  | 'operation_type'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

/** Tokens Info */
export type BitqueryElrondTokensInfo = {
  /** Token Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Currency Info */
  currency?: Maybe<BitqueryCurrency>;
};

/** Transactions in Elrond blockchain */
export type BitqueryElrondTransaction = {
  /** Transaction Action */
  action?: Maybe<BitqueryElrondTransactionAction>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** Data operation */
  dataOperation?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Tx function */
  function?: Maybe<Scalars['String']['output']>;
  /** Number of gas limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Number of gas price */
  gasPrice?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Number of gas used */
  gasUsed?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about transactions miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** TX  receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the sender */
  sender?: Maybe<BitqueryAddress>;
  /** Information about transactions block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Tx Status */
  status?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionAnyArgs = {
  of: BitqueryElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionCountArgs = {
  uniq?: InputMaybe<BitqueryElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionFeeArgs = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryElrondTransactionsMeasureable>;
  of: BitqueryElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryElrondTransactionsMeasureable>;
  of: BitqueryElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type BitqueryElrondTransactionValueArgs = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

/** Action of transction information */
export type BitqueryElrondTransactionAction = {
  /** Category */
  category?: Maybe<Scalars['String']['output']>;
  /** Description */
  description?: Maybe<Scalars['String']['output']>;
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryElrondTransactionFilter = {
  actionCategory?: InputMaybe<BitqueryStringSelector>;
  actionDescription?: InputMaybe<BitqueryStringSelector>;
  actionName?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  function?: InputMaybe<BitqueryStringSelector>;
  gasLimit?: InputMaybe<BitqueryFloatSelector>;
  gasPrice?: InputMaybe<BitqueryFloatSelector>;
  gasUsed?: InputMaybe<BitqueryFloatSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  txNonce?: InputMaybe<BitqueryIntegerSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txValue?: InputMaybe<BitqueryFloatSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondTransactionUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** Blockchain transaction with value */
export type BitqueryElrondTransactionValueDimension = {
  /** Transaction hash */
  hash: Scalars['String']['output'];
  /** Transaction value */
  value: Scalars['Float']['output'];
};

export type BitqueryElrondTransactionsMeasureable =
  /** Action Category */
  | 'action_category'
  /** Action Description */
  | 'action_description'
  /** Action Name */
  | 'action_name'
  /** Hash of the the block */
  | 'block_hash'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Action Function */
  | 'function'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Transaction hash */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Type of miniblock */
  | 'type'
  /** Value */
  | 'value';

/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransfer = {
  /** Action */
  action?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Entity ID */
  entityId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Esdt Type */
  esdtType?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Information about arguments miniblock */
  miniblock?: Maybe<BitqueryMiniblockElrond>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver account address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender account address */
  sender?: Maybe<BitqueryAddress>;
  /** Information about arguments block */
  senderBlock?: Maybe<BitqueryElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about arguments transaction */
  transaction?: Maybe<BitqueryTransactionElrond>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferAmountArgs = {
  action?: InputMaybe<BitqueryActionSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferAnyArgs = {
  of: BitqueryElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferCountArgs = {
  uniq?: InputMaybe<BitqueryElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferCountBigIntArgs = {
  action?: InputMaybe<BitqueryActionSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferCurrencyArgs = {
  currency?: InputMaybe<BitqueryCurrencySelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferMaximumArgs = {
  get?: InputMaybe<BitqueryElrondTransfersMeasureable>;
  of: BitqueryElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferMiniblockArgs = {
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferMinimumArgs = {
  get?: InputMaybe<BitqueryElrondTransfersMeasureable>;
  of: BitqueryElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferSenderBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type BitqueryElrondTransferTransactionArgs = {
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  txFunction?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryElrondTransferFilter = {
  action?: InputMaybe<BitqueryActionSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockNonce?: InputMaybe<BitqueryIntegerSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  data?: InputMaybe<BitqueryStringSelector>;
  dataOperation?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  epoch?: InputMaybe<BitqueryIntegerSelector>;
  esdtType?: InputMaybe<BitqueryStringSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  miniblockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverBlockHash?: InputMaybe<BitqueryHashSelector>;
  miniblockReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  publicKeyBitmap?: InputMaybe<BitqueryStringSelector>;
  round?: InputMaybe<BitqueryIntegerSelector>;
  shard?: InputMaybe<BitqueryBigIntIdSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  size?: InputMaybe<BitqueryIntegerSelector>;
  sizeTxs?: InputMaybe<BitqueryIntegerSelector>;
  stateRootHash?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
  transferReceiver?: InputMaybe<BitqueryAddressSelector>;
  transferSender?: InputMaybe<BitqueryAddressSelector>;
  transferType?: InputMaybe<BitqueryStringSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txReceiver?: InputMaybe<BitqueryHashSelector>;
  txReceiverShard?: InputMaybe<BitqueryBigIntIdSelector>;
  txSender?: InputMaybe<BitqueryHashSelector>;
  txSenderShard?: InputMaybe<BitqueryBigIntIdSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryElrondTransferUniq =
  /** Unique Number of block in the blockchains */
  | 'block_height'
  /** Unique date count */
  | 'dates'
  /** Unique Transaction Hash */
  | 'signature'
  /** Unique time */
  | 'times'
  /** Unique count of transfers type */
  | 'transferType'
  /** Unique count of transactions */
  | 'txs';

export type BitqueryElrondTransfersMeasureable =
  /** Action */
  | 'action'
  /** Transfer Amount */
  | 'amount'
  /** Hash of the the block */
  | 'block_hash'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Data */
  | 'data'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** ESDT Type */
  | 'esdtType'
  /** Gas Limit */
  | 'gas_limit'
  /** Gas Price */
  | 'gas_price'
  /** Gas Used */
  | 'gas_used'
  /** Number of block in the blockhains */
  | 'height'
  /** Hash of the miniblock */
  | 'miniblock_hash'
  /** Hash of the miniblocks receiver block */
  | 'miniblock_receiver_block_hash'
  /** Miniblock receiver shard */
  | 'miniblock_receiver_shard'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token type */
  | 'token_type'
  /** The block hash of this block`s parent */
  | 'transaction_count'
  /** Transfer Type */
  | 'transferType'
  /** Transaction hash */
  | 'tx_hash'
  /** Receiver hash */
  | 'tx_receiver'
  /** Shard number of the receiver */
  | 'tx_receiver_shard'
  /** Sender hash */
  | 'tx_sender'
  /** Shard number of the sender */
  | 'tx_sender_shard'
  /** Value */
  | 'tx_value'
  /** Type of miniblock */
  | 'type';

/** Entity */
export type BitqueryEntity = {
  /** Entity ID */
  id: Scalars['String']['output'];
  /** Entity number */
  num: Scalars['Int']['output'];
  /** Entity realm ID */
  realmId: Scalars['Int']['output'];
  /** Entity shard ID */
  shardId: Scalars['Int']['output'];
  /** Entity Type */
  type: Scalars['String']['output'];
};


/** Entity */
export type BitqueryEntityIdArgs = {
  entityId?: InputMaybe<Scalars['String']['input']>;
};

/** Selector of entity ID for NFT  tokens */
export type BitqueryEntitySelector = {
  /** EntityID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** EntityID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** EntityID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** EntityID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryEntityTypeEnum =
  /** account */
  | 'account'
  /** contract */
  | 'contract'
  /** file */
  | 'file'
  /** schedule */
  | 'schedule'
  /** token */
  | 'token'
  /** topic */
  | 'topic';

/** Select by entity type */
export type BitqueryEntityTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitqueryEntityTypeEnum>>;
  /** Type is */
  is?: InputMaybe<BitqueryEntityTypeEnum>;
  /** Type not */
  not?: InputMaybe<BitqueryEntityTypeEnum>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitqueryEntityTypeEnum>>;
};

/** EOS Chain */
export type BitqueryEos = {
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryEosAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryEosAddressStats>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryEosBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryEosCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryEosSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryEosTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryEosTransfers>>;
};


/** EOS Chain */
export type BitqueryEosAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** EOS Chain */
export type BitqueryEosAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** EOS Chain */
export type BitqueryEosBlocksArgs = {
  any?: InputMaybe<Array<BitqueryEosBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** EOS Chain */
export type BitqueryEosCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** EOS Chain */
export type BitqueryEosSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryEosSmartContractCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** EOS Chain */
export type BitqueryEosTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryEosTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** EOS Chain */
export type BitqueryEosTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryEosTransferFilter>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Address detailed information for EOS network */
export type BitqueryEosAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEosSmartContractInfo>;
};

/** Address with statistics */
export type BitqueryEosAddressStat = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Call Tx Count */
  callTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Called Tx Count */
  calledTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Other Tx Count */
  otherTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStat */
export type BitqueryEosAddressStats = {
  /** Address With Statistics */
  address?: Maybe<BitqueryEosAddressStat>;
};

export type BitqueryEosBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Blocks in EOS blockchain */
export type BitqueryEosBlocks = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block producer */
  producer?: Maybe<BitqueryAddress>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksAnyArgs = {
  of: BitqueryEosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryEosBlocksMeasureable>;
  of: BitqueryEosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryEosBlocksMeasureable>;
  of: BitqueryEosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksProducerArgs = {
  producer?: InputMaybe<BitqueryAddressSelector>;
};


/** Blocks in EOS blockchain */
export type BitqueryEosBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryEosBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Block Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type BitqueryEosBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique proposer count */
  | 'proposers';

export type BitqueryEosCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Sender */
  | 'tx_sender'
  /** Action To */
  | 'tx_to';

/** Coinpath */
export type BitqueryEosCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryEosCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryEosCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Coinpath */
export type BitqueryEosCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryEosCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEosCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEosCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Eos network */
export type BitqueryEosCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEosSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in EOS blockchain.
 * Token identified by address of contract ( eosio.token for main EOS token )
 */
export type BitqueryEosCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryEosNetwork =
  /** EOS mainnet */
  | 'eos';

/** Eos smart contract */
export type BitqueryEosSmartContract = {
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEosSmartContractCallFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Smart Contract Calls */
export type BitqueryEosSmartContractCalls = {
  /** Actors */
  actors?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Console */
  console?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Error Code */
  errorCode?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Permissions */
  permissions?: Maybe<Scalars['String']['output']>;
  /** Receivers */
  receivers?: Maybe<Scalars['String']['output']>;
  /** True if call scheduled */
  scheduled?: Maybe<Scalars['Boolean']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEosSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsAnyArgs = {
  of: BitqueryEosCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsErrorCodeArgs = {
  errorCode?: InputMaybe<BitqueryIntIdSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryEosCallsMeasureable>;
  of: BitqueryEosCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryEosCallsMeasureable>;
  of: BitqueryEosCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsScheduledArgs = {
  scheduled?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryEosSmartContractCallsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Blockchain smart contract */
export type BitqueryEosSmartContractInfo = {
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEosTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};

/** Transactions in EOS blockchain */
export type BitqueryEosTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  cpuUsageUs?: Maybe<Scalars['Int']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsageWords?: Maybe<Scalars['Int']['output']>;
  /** Success */
  scheduled?: Maybe<Scalars['Boolean']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsAnyArgs = {
  of: BitqueryEosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryEosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryEosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsCpuUsageUsArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryEosTransactionsMeasureable>;
  of: BitqueryEosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryEosTransactionsMeasureable>;
  of: BitqueryEosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsNetUsageWordsArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsScheduledArgs = {
  scheduled?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in EOS blockchain */
export type BitqueryEosTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BitqueryEosTransactionsMeasureable =
  /** Block */
  | 'block'
  /** CPU Usage */
  | 'cpu_usage_us'
  /** Date */
  | 'date'
  /** Net Usage */
  | 'net_usage_words'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryEosTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type BitqueryEosTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfers = {
  /** Actors */
  actors?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memo */
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersAnyArgs = {
  of: BitqueryEosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersCurrencyArgs = {
  currency?: InputMaybe<BitqueryEosCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryEosTransfersMeasureable>;
  of: BitqueryEosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryEosTransfersMeasureable>;
  of: BitqueryEosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEosTransfersTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryEosTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Ethereum Chain */
export type BitqueryEthereum = {
  /** Ethereum Active Addresses */
  activeAddresses?: Maybe<Array<BitqueryEthereumActiveAddress>>;
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryEthereumAddressInfoWithBalance>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryEthereumAddressStats>>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryEthereumArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryEthereumBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryEthereumCoinpath>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<BitqueryEthereumDexTrades>>;
  /** References of Smart Contract Calls and Events */
  references?: Maybe<Array<BitqueryEthereumReferencess>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryEthereumSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryEthereumSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryEthereumTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryEthereumTransfers>>;
};


/** Ethereum Chain */
export type BitqueryEthereumActiveAddressesArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumAddressArgs = {
  address: Array<BitqueryEthereumAddressSelectorIn>;
};


/** Ethereum Chain */
export type BitqueryEthereumAddressStatsArgs = {
  address: BitqueryEthereumAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Ethereum Chain */
export type BitqueryEthereumArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryEthereumArgumentFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumBlocksArgs = {
  any?: InputMaybe<Array<BitqueryEthereumBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryEthereumAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryEthereumAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryEthereumAddressSelector>;
  sender?: InputMaybe<BitqueryEthereumAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumDexTradesArgs = {
  any?: InputMaybe<Array<BitqueryEthereumDexTradeFilter>>;
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumReferencesArgs = {
  any?: InputMaybe<Array<BitqueryEthereumReferencesFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryEthereumSmartContractCallFilter>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumSmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryEthereumSmartContractEventFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ethereum Chain */
export type BitqueryEthereumTransactionsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryEthereumTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Ethereum Chain */
export type BitqueryEthereumTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryEthereumTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2 = {
  /** Attestations in block */
  attestations?: Maybe<Array<BitqueryEthereum2Attestation>>;
  /** Attester Slashings */
  attesterSlashings?: Maybe<Array<BitqueryEthereum2AttesterSlashing>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryEthereum2Blocks>>;
  /** Attestations of blocks */
  deposits?: Maybe<Array<BitqueryEthereum2Deposit>>;
  /** Proposer Slashings */
  proposerSlashings?: Maybe<Array<BitqueryEthereum2ProposerSlashing>>;
  /** Validator Updates */
  validatorUpdates?: Maybe<Array<BitqueryEthereum2ValidatorUpdates>>;
  /** Voluntary Exits */
  voluntaryExits?: Maybe<Array<BitqueryEthereum2VoluntaryExit>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2AttestationsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  committeeIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2AttesterSlashingsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2BlocksArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2DepositsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2ProposerSlashingsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  slashingEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2ValidatorUpdatesArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2ValidatorUpdatesFilter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type BitqueryEthereum2VoluntaryExitsArgs = {
  any?: InputMaybe<Array<BitqueryEthereum2Filter>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2Attestation = {
  aggregationBits: Scalars['String']['output'];
  any?: Maybe<Scalars['String']['output']>;
  attestation: BitqueryEthereum2AttestationInfo;
  /** Attestation Index (0 based ) in block */
  attestationIndex: Scalars['Int']['output'];
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  /** Committee index for attestation */
  committeeIndex: Scalars['Int']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
  /** Sequential index of validator in committee ( 0-based) */
  validatorInCommitteeIndex: Scalars['Int']['output'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationAnyArgs = {
  of: BitqueryEthereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationCountArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  committeeIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttestationsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationCountBigIntArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  committeeIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttestationsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttestationsMeasureable>;
  of: BitqueryEthereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttestationsMeasureable>;
  of: BitqueryEthereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttestationProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** AttestationFieldInfo for Ethereum v 2.0 network */
export type BitqueryEthereum2AttestationFieldInfo = {
  epoch: Scalars['Int']['output'];
  /** Root Hash */
  root: Scalars['String']['output'];
};

/** AttestationInfo for Ethereum v 2.0 network */
export type BitqueryEthereum2AttestationInfo = {
  beaconBlockRoot: Scalars['String']['output'];
  epoch: Scalars['Int']['output'];
  signature: Scalars['String']['output'];
  slot: Scalars['Int']['output'];
  source: BitqueryEthereum2AttestationFieldInfo;
  target: BitqueryEthereum2AttestationFieldInfo;
};

export type BitqueryEthereum2AttestationsMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Committee Index */
  | 'committee'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type BitqueryEthereum2AttestationsUniq =
  /** Unique attestation epochs */
  | 'attestation_epochs'
  /** Unique attestation slots */
  | 'attestation_slots'
  /** Unique attestations */
  | 'attestations'
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique commitees */
  | 'committees'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashing = {
  any?: Maybe<Scalars['String']['output']>;
  attestation: BitqueryEthereum2AttestationInfo;
  /** Attestation slashing sequential number */
  attestationOrder: Scalars['Int']['output'];
  /** Attester Slashing Index (0 based ) in block */
  attesterSlashingIndex: Scalars['Int']['output'];
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
  /** Validator index in slashing sequential numbern */
  validatorInAttestationIndex: Scalars['Int']['output'];
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingAnyArgs = {
  of: BitqueryEthereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingCountArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttesterSlashingsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingCountBigIntArgs = {
  attestationEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  attestationSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2AttesterSlashingsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttesterSlashingMeasureable>;
  of: BitqueryEthereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2AttesterSlashingMeasureable>;
  of: BitqueryEthereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2AttesterSlashingProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export type BitqueryEthereum2AttesterSlashingMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type BitqueryEthereum2AttesterSlashingsUniq =
  /** Unique slashing epochs */
  | 'attestation_epochs'
  /** Unique slashing slots */
  | 'attestation_slots'
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2Blocks = {
  any?: Maybe<Scalars['String']['output']>;
  attestationsCount?: Maybe<Scalars['Int']['output']>;
  attestationsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  attesterSlashingsCount?: Maybe<Scalars['Int']['output']>;
  attesterSlashingsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  depositsCount?: Maybe<Scalars['Int']['output']>;
  depositsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Epoch in blockchain */
  epoch: Scalars['Int']['output'];
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Graffiti */
  graffiti: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  proposerSlashingsCount?: Maybe<Scalars['Int']['output']>;
  proposerSlashingsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Randao Reveal */
  randaoReveal: Scalars['String']['output'];
  /** Block signature */
  signature: Scalars['String']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  voluntaryExitsCount?: Maybe<Scalars['Int']['output']>;
  voluntaryExitsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAnyArgs = {
  of: BitqueryEthereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttestationsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttestationsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttesterSlashingsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksAttesterSlashingsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksDepositsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksDepositsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2BlocksMeasureable>;
  of: BitqueryEthereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2BlocksMeasureable>;
  of: BitqueryEthereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksProposerSlashingsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksProposerSlashingsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksVoluntaryExitsCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type BitqueryEthereum2BlocksVoluntaryExitsCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryEthereum2BlocksMeasureable =
  /** Block */
  | 'block'
  /** Block Miner */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time';

export type BitqueryEthereum2BlocksUniq =
  /** Unique proposers */
  | 'block_proposers'
  /** Unique date count */
  | 'dates';

/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2Deposit = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Deposit Index (0 based ) in block */
  depositIndex: Scalars['Int']['output'];
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  proof: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  signature: Scalars['String']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositAmountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositAnyArgs = {
  of: BitqueryEthereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2DepositsMeasureable>;
  of: BitqueryEthereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2DepositsMeasureable>;
  of: BitqueryEthereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2DepositProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export type BitqueryEthereum2DepositsMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type BitqueryEthereum2DepositsUniq =
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Eth1 attributes for Ethereum v 2.0 network */
export type BitqueryEthereum2Eth1Info = {
  /** Block Eth1 block hash */
  blockHash: Scalars['String']['output'];
  /** Block Eth1 deposit count */
  depositCount: Scalars['Int']['output'];
  /** Block Eth1 deposit root hash */
  depositRootHash: Scalars['String']['output'];
};

export type BitqueryEthereum2Filter = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryEthereum2Network =
  /** Beacon Chain Ethereum 2.0 */
  | 'eth2'
  /** Medalla Ethereum 2.0 Beacon Testnet */
  | 'medalla';

/** Proposer attributes for Ethereum v 2.0 network */
export type BitqueryEthereum2ProposerInfo = {
  /** Proposer Index as Integer */
  index: Scalars['Int']['output'];
  /** Proposer Pub Key */
  pubkey: Scalars['String']['output'];
};

/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashing = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Header slashing sequential numbern */
  headerOrder: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Proposer Slashing Index (0 based ) in block */
  proposerSlashingIndex: Scalars['Int']['output'];
  slashing: BitqueryEthereum2SlashingInfo;
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingAnyArgs = {
  of: BitqueryEthereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  slashingEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  slashingEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  slashingSlot?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2ProposerSlashingMeasureable>;
  of: BitqueryEthereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2ProposerSlashingMeasureable>;
  of: BitqueryEthereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ProposerSlashingProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export type BitqueryEthereum2ProposerSlashingMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Slashed Proposer */
  | 'proposer'
  /** Time */
  | 'time';

export type BitqueryEthereum2ProposerSlashingsUniq =
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique slashing epochs */
  | 'slashing_epochs'
  /** Unique slashing proposers */
  | 'slashing_proposers'
  /** Unique slashing slots */
  | 'slashing_slots';

/** SlashingInfo for Ethereum v 2.0 network */
export type BitqueryEthereum2SlashingInfo = {
  /** Block body hash */
  bodyRoot: Scalars['String']['output'];
  epoch: Scalars['Int']['output'];
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  signature: Scalars['String']['output'];
  slot: Scalars['Int']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
};

/** Validator attributes for Ethereum v 2.0 network */
export type BitqueryEthereum2ValidatorInfo = {
  /** Validator Index as Integer */
  index: Scalars['Int']['output'];
  /** Validator Pub Key */
  pubkey: Scalars['String']['output'];
};

/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdates = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRootHash: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch: Scalars['BitqueryBigInt']['output'];
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRootHash: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ProposerInfo>;
  /** Block state root hash */
  stateRootHash: Scalars['String']['output'];
  /** Time date */
  time?: Maybe<BitqueryDateTime>;
  /** Block validator */
  validator?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Validator activation epoch */
  validatorActivationEpoch: Scalars['BitqueryBigInt']['output'];
  /** Validator balance */
  validatorBalance?: Maybe<Scalars['Float']['output']>;
  /** Validator balance change */
  validatorBalanceChange: Scalars['Float']['output'];
  /** Validator effective balance */
  validatorEffectiveBalance: Scalars['Float']['output'];
  /** Validator exit epoch */
  validatorExitEpoch: Scalars['BitqueryBigInt']['output'];
  /** Validator Slashed */
  validatorSlashed: Scalars['Boolean']['output'];
  /** Validator Status */
  validatorStatus: Scalars['String']['output'];
  /** Validator withdrawable epoch */
  validatorWithdrawableEpoch: Scalars['BitqueryBigInt']['output'];
  /** Validator Withdrawal Credentials */
  validatorWithdrawalCredentials: Scalars['String']['output'];
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesAnyArgs = {
  of: BitqueryEthereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ValidatorUpdatesUniq>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2ValidatorUpdatesUniq>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2ValidatorUpdatesMeasureable>;
  of: BitqueryEthereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2ValidatorUpdatesMeasureable>;
  of: BitqueryEthereum2ValidatorUpdatesMeasureable;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesValidatorBalanceArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesValidatorBalanceChangeArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Validator Updates in Ethereum v2.0 blockchain */
export type BitqueryEthereum2ValidatorUpdatesValidatorEffectiveBalanceArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereum2ValidatorUpdatesFilter = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockProposerPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<Array<BitqueryStringSelector>>;
  eth1BlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  eth1DepositCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  eth1DepositRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  stateRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  validatorActivationEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorBalanceChange?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorEffectiveBalance?: InputMaybe<Array<BitqueryAmountSelector>>;
  validatorExitEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  validatorPubkey?: InputMaybe<Array<BitqueryHashSelector>>;
  validatorSlashed?: InputMaybe<Array<BitqueryBooleanSelector>>;
  validatorStatus?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawableEpoch?: InputMaybe<Array<BitqueryStringSelector>>;
  validatorWithdrawalCredentials?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereum2ValidatorUpdatesMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Epoch */
  | 'epoch'
  /** Eth1 block hash */
  | 'eth1_block_hash'
  /** Eth1 deposit count */
  | 'eth1_deposit_count'
  /** Eth1 deposit root hash */
  | 'eth1_deposit_root_hash'
  /** Parent root hash */
  | 'parent_root_hash'
  /** Proposer index */
  | 'proposer_index'
  /** Proposer pubkey hash */
  | 'proposer_pubkey_hash'
  /** State root hash */
  | 'state_root_hash'
  /** Time */
  | 'time'
  /** Validator activation epoch */
  | 'validator_activation_epoch'
  /** Validator balance */
  | 'validator_balance'
  /** Validator balance change */
  | 'validator_balance_change'
  /** Validator effective balance */
  | 'validator_effective_balance'
  /** Validator exit epoch */
  | 'validator_exit_epoch'
  /** Validator index */
  | 'validator_index'
  /** Validator pubkey hash */
  | 'validator_pubkey_hash'
  /** Validator slashed */
  | 'validator_slashed'
  /** Validator withdrawable epoch */
  | 'validator_withdrawable_epoch';

export type BitqueryEthereum2ValidatorUpdatesUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique epochs */
  | 'epochs'
  /** Unique proposers */
  | 'proposers'
  /** Unique validators */
  | 'validators';

/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExit = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Block root hash */
  blockRoot: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Block Eth1 information */
  eth1: BitqueryEthereum2Eth1Info;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block parent hash */
  parentRoot: Scalars['String']['output'];
  /** Block proposer */
  proposer?: Maybe<BitqueryEthereum2ValidatorInfo>;
  /** Signature */
  signature: Scalars['String']['output'];
  /** Block state root hash */
  stateRoot: Scalars['String']['output'];
  /** Validator */
  validator: BitqueryEthereum2ValidatorInfo;
  voluntaryExitEpoch: Scalars['Int']['output'];
  /** Voluntary Exit Index (0 based ) in block */
  voluntaryExitIndex: Scalars['Int']['output'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitAnyArgs = {
  of: BitqueryEthereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitBlockRootArgs = {
  blockRootHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitCountArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2VoluntaryExitsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitCountBigIntArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  blockRootHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryEthereum2VoluntaryExitsUniq>;
  validatorIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
  voluntaryExitEpoch?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitMaximumArgs = {
  get?: InputMaybe<BitqueryEthereum2VoluntaryExitsMeasureable>;
  of: BitqueryEthereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitMinimumArgs = {
  get?: InputMaybe<BitqueryEthereum2VoluntaryExitsMeasureable>;
  of: BitqueryEthereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type BitqueryEthereum2VoluntaryExitProposerArgs = {
  blockProposerIndex?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export type BitqueryEthereum2VoluntaryExitsMeasureable =
  /** Block */
  | 'block'
  /** Block Proposer */
  | 'block_proposer'
  /** Block hash */
  | 'block_root_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Validator index */
  | 'validator';

export type BitqueryEthereum2VoluntaryExitsUniq =
  /** Unique block proposers */
  | 'block_proposers'
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique validators */
  | 'validators';

/** Address that have been active in transfers */
export type BitqueryEthereumActiveAddress = {
  /** Transfer address */
  address?: Maybe<BitqueryEthereumAddressInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Address that have been active in transfers */
export type BitqueryEthereumActiveAddressCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddress;
};


/** Address that have been active in transfers */
export type BitqueryEthereumActiveAddressCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq: BitqueryActiveAddress;
};

/** Address detailed information for Ethereum network */
export type BitqueryEthereumAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEthereumSmartContractInfo>;
};

/** Blockchain address */
export type BitqueryEthereumAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<BitqueryEthereumBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEthereumSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type BitqueryEthereumAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Blockchain address */
export type BitqueryEthereumAddressInfoWithBalanceBalancesArgs = {
  currency?: InputMaybe<BitqueryEthereumCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelectorRange>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/**
 * Address should start from 0x and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryEthereumAddressSelector = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Not Equal to Address */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Not in the list of Addresses */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * Address should start from 0x and contain hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryEthereumAddressSelectorIn = {
  /** In the list of Addresses */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Equal to Address */
  is?: InputMaybe<Scalars['String']['input']>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type BitqueryEthereumAddressStat = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Call Tx Count */
  callTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Called Tx Count */
  calledTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Amount of paid fee */
  feeAmount?: Maybe<Scalars['Float']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Other Tx Count */
  otherTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStats */
export type BitqueryEthereumAddressStats = {
  /** Address With Statistics */
  address?: Maybe<BitqueryEthereumAddressStat>;
};

export type BitqueryEthereumArgumentFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArguments = {
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryEthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** @deprecated DEPRECATED! Please use ethereum { references } */
  reference?: Maybe<BitqueryEthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<BitqueryArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumArgumentsMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryEthereumArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export type BitqueryEthereumArgumentsConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type BitqueryEthereumArgumentsMeasureable =
  /** Argument */
  | 'argument'
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Balance in a currency */
export type BitqueryEthereumBalance = {
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<BitqueryEthereumBalanceChange>>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Balance in a currency */
export type BitqueryEthereumBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type BitqueryEthereumBalanceChange = {
  /** Block number (height) in blockchain */
  block: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['BitqueryISO8601DateTime']['output']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryEthereumBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocks = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  difficulty?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gasLimit?: Maybe<Scalars['Float']['output']>;
  gasUsed?: Maybe<Scalars['Float']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  /** Block miner */
  miner?: Maybe<BitqueryEthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Block nonce */
  nonce: Scalars['Int']['output'];
  /** Parent block hash */
  parentHash: Scalars['String']['output'];
  reward?: Maybe<Scalars['Float']['output']>;
  /** Currency of reward */
  rewardCurrency?: Maybe<BitqueryCurrency>;
  size?: Maybe<Scalars['Int']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalDifficulty?: Maybe<Scalars['Float']['output']>;
  transactionCount?: Maybe<Scalars['Int']['output']>;
  transactionCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  uncleCount?: Maybe<Scalars['Int']['output']>;
  uncleCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksAnyArgs = {
  of: BitqueryEthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uniq?: InputMaybe<BitqueryEthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksDifficultyArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksGasLimitArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksGasUsedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumBlocksMeasureable>;
  of: BitqueryEthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksMinerArgs = {
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumBlocksMeasureable>;
  of: BitqueryEthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksSizeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTotalDifficultyArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksUncleCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type BitqueryEthereumBlocksUncleCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockReward?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  size?: InputMaybe<Array<BitqueryIntegerSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
  uncleCount?: InputMaybe<Array<BitqueryIntegerSelector>>;
};

export type BitqueryEthereumBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Block Reward */
  | 'block_reward'
  /** Date */
  | 'date'
  /** Block Miner */
  | 'miner'
  /** Time */
  | 'time';

export type BitqueryEthereumBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique miner count */
  | 'miners';

export type BitqueryEthereumCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Coinpath */
export type BitqueryEthereumCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryEthereumCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryEthereumCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryEthereumCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryEthereumCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEthereumCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryEthereumCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Ethereum network */
export type BitqueryEthereumCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryEthereumSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

/**
 * Currency selector in Ethereum blockchain.
 *   Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
 *   You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
 *   Ethereum Smart contract address should start from 0x and contain 40 hex digits.
 *   If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type BitqueryEthereumCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Ethereum DEX attributes */
export type BitqueryEthereumDex = {
  /** Address for DEX exchange identification */
  address: BitqueryAddress;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String']['output'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String']['output'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEthereumDexTradeFilter = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};

/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTrades = {
  /** Trader (maker or taker) */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  /** Base currency */
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlockExtended>;
  buyAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<BitqueryEthereumDex>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Float']['output']>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Trade 'maker' side */
  maker?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']['output']>;
  /** For this metric works you need use "quoteCurrency{ tokenId }" dimension */
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  /** Quote currency */
  quoteCurrency?: Maybe<BitqueryCurrency>;
  /** For this metric works you need use "quoteCurrency{ tokenId }" dimension */
  quotePrice?: Maybe<Scalars['Float']['output']>;
  sellAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<BitqueryTradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<BitqueryAddress>;
  /** Time interval */
  timeInterval?: Maybe<BitqueryTimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']['output']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']['output']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<BitqueryEthereumTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesAddressArgs = {
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesAnyArgs = {
  of: BitqueryEthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBaseAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBuyAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesBuyCurrencyArgs = {
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  uniq?: InputMaybe<BitqueryEthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesExchangeArgs = {
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesGasArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesGasPriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesMakerArgs = {
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumDexTradesMeasureable>;
  of: BitqueryEthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumDexTradesMeasureable>;
  of: BitqueryEthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesPriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesProtocolArgs = {
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesQuoteAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesQuotePriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  makerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  takerSmartContractType?: InputMaybe<Array<BitquerySmartContractTypeSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesSellAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesSellCurrencyArgs = {
  sellCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTakerArgs = {
  taker?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTradeAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in: BitqueryBaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTradeIndexArgs = {
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryEthereumDexTradesTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};

export type BitqueryEthereumDexTradesMeasureable =
  /** Block */
  | 'block'
  /** Buy Amount */
  | 'buy_amount'
  /** Buy Token address */
  | 'buy_currency_address'
  /** Buy Currency symbol */
  | 'buy_currency_symbol'
  /** Date */
  | 'date'
  /** Maker */
  | 'maker'
  /** Price */
  | 'price'
  /** Quote Price */
  | 'quote_price'
  /** Sell Amount */
  | 'sell_amount'
  /** Sell Token address */
  | 'sell_currency_address'
  /** Sell Currency symbol */
  | 'sell_currency_symbol'
  /** Taker */
  | 'taker'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryEthereumDexTradesUniq =
  /** Unique makers & takers count */
  | 'address'
  /** Base currencies count */
  | 'base_currency'
  /** Unique blocks */
  | 'blocks'
  /** Buy currencies count */
  | 'buy_currency'
  /** Unique date count */
  | 'dates'
  /** Unique makers count */
  | 'makers'
  /** Unique protocols count */
  | 'protocols'
  /** Quote currencies count */
  | 'quote_currency'
  /** Sell currencies count */
  | 'sell_currency'
  /** Unique TX senders count */
  | 'senders'
  /** Unique smart contract count */
  | 'smart_contracts'
  /** Unique makers count */
  | 'takers'
  /** Unique transactions count */
  | 'txs';

export type BitqueryEthereumEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract Event Signature */
  | 'signature'
  /** Smart Contract Event Signature Hash */
  | 'signature_hash'
  /** Smart Contract Event Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryEthereumNetwork =
  /** Avalanche C-chain */
  | 'avalanche'
  /** Binance Smart Chain Mainnet */
  | 'bsc'
  /** Binance Smart Chain Testnet */
  | 'bsc_testnet'
  /** Celo Alfajores Testnet */
  | 'celo_alfajores'
  /** Celo Baklava Testnet */
  | 'celo_baklava'
  /** Celo Mainnet */
  | 'celo_mainnet'
  /** DEPRECATED. Use celo_mainnet */
  | 'celo_rc1'
  /** Cronos Mainnet */
  | 'cronos'
  /** Ethereum Classic */
  | 'ethclassic'
  /** Ethereum Classic ( no reorg from block 10904146) */
  | 'ethclassic_reorg'
  /** Ethereum Mainnet */
  | 'ethereum'
  /** Ethereum PoW */
  | 'ethpow'
  /** Fantom Mainnet */
  | 'fantom'
  /** Goerli Ethereum Testnet */
  | 'goerli'
  /** Klaytn Mainnet */
  | 'klaytn'
  /** Matic (Polygon) Mainnet */
  | 'matic'
  /** Moonbeam Mainnet */
  | 'moonbeam'
  /** Velas Mainnet */
  | 'velas'
  /** Velas Testnet */
  | 'velas_testnet';

export type BitqueryEthereumReferencesFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address value of method or event argument */
export type BitqueryEthereumReferencess = {
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryEthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryEthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessCallerArgs = {
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractArgumentsUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  as?: InputMaybe<BitqueryEthereumReferencessConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryEthereumReferencessMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryEthereumReferencessMeasureable;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Array<BitqueryArgumentTypeSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessReferenceArgs = {
  reference?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Address value of method or event argument */
export type BitqueryEthereumReferencessTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereumReferencessConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type BitqueryEthereumReferencessMeasureable =
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Caller */
  | 'caller'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Ethereum smart contract */
export type BitqueryEthereumSmartContract = {
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEthereumSmartContractCallFilter = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCalls = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<BitqueryEthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where call happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsAnyArgs = {
  of: BitqueryEthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsCallerArgs = {
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsCountArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsCountBigIntArgs = {
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  caller?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumCallsMeasureable>;
  of: BitqueryEthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumCallsMeasureable>;
  of: BitqueryEthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryEthereumSmartContractCallsTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

/** Smart Contract Events */
export type BitqueryEthereumSmartContractEvent = {
  any?: Maybe<Scalars['String']['output']>;
  /** Event arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryEthereumSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** Transaction where event happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventAnyArgs = {
  of: BitqueryEthereumEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumEventsMeasureable>;
  of: BitqueryEthereumEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumEventsMeasureable>;
  of: BitqueryEthereumEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryEthereumSmartContractEventTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereumSmartContractEventFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractType?: InputMaybe<BitquerySmartContractTypeSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain smart contract */
export type BitqueryEthereumSmartContractInfo = {
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

/** Blockchain smart contract */
export type BitqueryEthereumSmartContractInfoWithAttributes = {
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<BitquerySmartContractReadonlyAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEthereumTransactionFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};

/** Blockchain transaction info */
export type BitqueryEthereumTransactionInfo = {
  /** Gas consumed */
  gas: Scalars['Int']['output'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  /** Gas value cost */
  gasValue: Scalars['Float']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction from address */
  txFrom: BitqueryEthereumAddressInfo;
};

/** Blockchain Transaction Extended info */
export type BitqueryEthereumTransactionInfoExtended = {
  /** Gas consumed */
  gas: Scalars['Int']['output'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  /** Gas value cost */
  gasValue: Scalars['Float']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Transaction receiver */
  to?: Maybe<BitqueryEthereumAddressInfo>;
  /** Transaction from address */
  txFrom: BitqueryEthereumAddressInfo;
};

/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactions = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Created smart contract */
  creates?: Maybe<BitqueryEthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Error message if any */
  error?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Fee payer */
  feePayer?: Maybe<Scalars['String']['output']>;
  /** Fee ratio */
  feeRatio?: Maybe<Scalars['Int']['output']>;
  gas?: Maybe<Scalars['Float']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Transaction sender */
  sender?: Maybe<BitqueryEthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction receiver */
  to?: Maybe<BitqueryEthereumAddressInfo>;
  /** Transaction type */
  txType?: Maybe<Scalars['String']['output']>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsAnyArgs = {
  of: BitqueryEthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
  uniq?: InputMaybe<BitqueryEthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsCreatesArgs = {
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasPriceArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePayer?: InputMaybe<Array<BitqueryStringSelector>>;
  feeRatio?: InputMaybe<BitqueryTxIndexSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  gasValue?: InputMaybe<Array<BitqueryAmountSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCreates?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txType?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumTransactionsMeasureable>;
  of: BitqueryEthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumTransactionsMeasureable>;
  of: BitqueryEthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsSenderArgs = {
  txSender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Ethereum blockchain */
export type BitqueryEthereumTransactionsToArgs = {
  txTo?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};

export type BitqueryEthereumTransactionsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee payer */
  | 'fee_payer'
  /** Fee ratio */
  | 'fee_ratio'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Gas value */
  | 'gas_value'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Sender */
  | 'tx_sender'
  /** Transaction type */
  | 'tx_type';

export type BitqueryEthereumTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique fee payers count */
  | 'fee_payers'
  /** Unique fee ratios count */
  | 'fee_ratios'
  /** Unique TX receivers count */
  | 'receivers'
  /** Unique TX senders count */
  | 'senders'
  /** Unique TX types count */
  | 'tx_types';

export type BitqueryEthereumTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfers = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryEthereumAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<BitqueryEthereumAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<BitqueryEthereumTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersAnyArgs = {
  of: BitqueryEthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryEthereumCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryEthereumTransfersMeasureable>;
  of: BitqueryEthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryEthereumTransfersMeasureable>;
  of: BitqueryEthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersReceiverArgs = {
  receiver?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersSenderArgs = {
  sender?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryEthereumTransfersTransactionArgs = {
  txFrom?: InputMaybe<Array<BitqueryEthereumAddressSelector>>;
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryEthereumTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

/** Smart contract event */
export type BitqueryEvent = {
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature Hash */
  signatureHash: Scalars['String']['output'];
};

/** Smart contract event. In selector you can use the name, signature or hex hash */
export type BitqueryEventSelector = {
  /** Event signature in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Event signature is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Event signature not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Event signature not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryEventType =
  /** Call Result */
  | 'call_result'
  /** Transaction */
  | 'transaction';

/** Select by event type */
export type BitqueryEventTypeSelector = {
  /** Eventy type in the list */
  in?: InputMaybe<Array<BitqueryEventType>>;
  /** Eventy type is */
  is?: InputMaybe<BitqueryEventType>;
  /** Eventy type not */
  not?: InputMaybe<BitqueryEventType>;
  /** Eventy type not in the list */
  notIn?: InputMaybe<Array<BitqueryEventType>>;
};

/** Everscale Chain */
export type BitqueryEverscale = {
  /** Information about address */
  address: Array<BitqueryEverscaleAddressInfo>;
  /** Everscale Arguments */
  arguments?: Maybe<Array<BitqueryEverscaleArgument>>;
  /** Everscale Blocks */
  blocks?: Maybe<Array<BitqueryEverscaleBlock>>;
  /** Everscale Calls */
  calls?: Maybe<Array<BitqueryEverscaleCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryEverscaleCoinpath>>;
  /** Everscale Events */
  events?: Maybe<Array<BitqueryEverscaleEvent>>;
  /** Everscale Messages */
  messages?: Maybe<Array<BitqueryEverscaleMessage>>;
  /** Everscale Phases */
  phases?: Maybe<Array<BitqueryEverscalePhase>>;
  /** Everscale Transactions */
  transactions?: Maybe<Array<BitqueryEverscaleTransaction>>;
  /** Everscale Transfers */
  transfers?: Maybe<Array<BitqueryEverscaleTransfer>>;
};


/** Everscale Chain */
export type BitqueryEverscaleAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Everscale Chain */
export type BitqueryEverscaleArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleArgumentFilter>>;
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleBlocksArgs = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  any?: InputMaybe<Array<BitqueryEverscaleBlockFilter>>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleCallsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleCallFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleEventsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleEventFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleMessagesArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleMessageFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscalePhasesArgs = {
  any?: InputMaybe<Array<BitqueryEverscalePhaseFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Everscale Chain */
export type BitqueryEverscaleTransfersArgs = {
  any?: InputMaybe<Array<BitqueryEverscaleTransferFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleAccountStateEnum =
  /** The account`s code and data have been initialized as well. */
  | 'Active'
  /** The account`s code and data have been replaced by a hash, but the balance is still stored explicitly. The balance of a frozen account. */
  | 'Frozen'
  /** Initialized account. */
  | 'NonExist'
  /** The account only has a balance; its code and data have not yet been initialized. */
  | 'Uninit';

/** Select by account state */
export type BitqueryEverscaleAccountStateSelector = {
  /** Account state in the list */
  in?: InputMaybe<Array<BitqueryEverscaleAccountStateEnum>>;
  /** Account state is */
  is?: InputMaybe<BitqueryEverscaleAccountStateEnum>;
  /** Account state not */
  not?: InputMaybe<BitqueryEverscaleAccountStateEnum>;
  /** Account state not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleAccountStateEnum>>;
};

/** Address balance information for Everscale network */
export type BitqueryEverscaleAddressBalance = {
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Address balance information for Everscale network */
export type BitqueryEverscaleAddressBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Address detailed information for Everscale network */
export type BitqueryEverscaleAddressInfo = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Current address balances */
  balance?: Maybe<Array<BitqueryEverscaleAddressBalance>>;
};

/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgument = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Argument Field */
  field?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Argument Index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Argument Type */
  type?: Maybe<Scalars['String']['output']>;
  /** Argument Vlaue */
  value?: Maybe<Scalars['String']['output']>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentAnyArgs = {
  of: BitqueryEverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentCountArgs = {
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleArgumentUniq>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentCountBigIntArgs = {
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleArgumentUniq>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleArgumentMeasurable>;
  of: BitqueryEverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleArgumentMeasurable>;
  of: BitqueryEverscaleArgumentMeasurable;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Argument in Everscale blockchain */
export type BitqueryEverscaleArgumentTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleArgumentFilter = {
  argumentField?: InputMaybe<BitqueryStringSelector>;
  argumentIndex?: InputMaybe<BitqueryIntegerSelector>;
  argumentType?: InputMaybe<BitqueryEverscaleArgumentTypeSelector>;
  argumentValue?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleArgumentMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Signature */
  | 'signature'
  /** Signature Hash */
  | 'signature_hash'
  /** Signature Name */
  | 'signature_name'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleArgumentTypeEnum =
  /** Argument of call */
  | 'call'
  /** Argument of event */
  | 'event';

/** Select by argument type */
export type BitqueryEverscaleArgumentTypeSelector = {
  /** Argument type in the list */
  in?: InputMaybe<Array<BitqueryEverscaleArgumentTypeEnum>>;
  /** Argument type is */
  is?: InputMaybe<BitqueryEverscaleArgumentTypeEnum>;
  /** Argument type not */
  not?: InputMaybe<BitqueryEverscaleArgumentTypeEnum>;
  /** Argument type not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleArgumentTypeEnum>>;
};

export type BitqueryEverscaleArgumentUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Unique Number of signatures */
  | 'smart_contract_methods'
  /** Unique Number of smart contracts */
  | 'smart_contracts'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Block in Everscale blockchain */
export type BitqueryEverscaleBlock = {
  /** After Merge */
  afterMerge?: Maybe<Scalars['Boolean']['output']>;
  /** After Split */
  afterSplit?: Maybe<Scalars['Boolean']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Before Split */
  beforeSplit?: Maybe<Scalars['Boolean']['output']>;
  /** Boc */
  boc?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Information about block general */
  general?: Maybe<BitqueryEverscaleGeneralDimension>;
  /** Global Id */
  globalId?: Maybe<Scalars['Int']['output']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Logical Time end */
  logicalTimeEnd?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Logical Time Start */
  logicalTimeStart?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Minimal Reference Masterchain Block */
  minimalReferenceMasterchainBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Random Seed */
  randomSeed?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Status */
  status?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Tx Count */
  txCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  value?: Maybe<BitqueryEverscaleValueDimension>;
  /** Version */
  version?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Vertical Sequence */
  verticalSeqNo?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Want Merge */
  wantMerge?: Maybe<Scalars['Boolean']['output']>;
  /** Want Split */
  wantSplit?: Maybe<Scalars['Boolean']['output']>;
  /** Proposer block hash */
  workchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockAnyArgs = {
  of: BitqueryEverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockCountArgs = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleBlockUniq>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockCountBigIntArgs = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleBlockUniq>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockGeneralArgs = {
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleBlockMeasurable>;
  of: BitqueryEverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleBlockMeasurable>;
  of: BitqueryEverscaleBlockMeasurable;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Block in Everscale blockchain */
export type BitqueryEverscaleBlockValueArgs = {
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
};

export type BitqueryEverscaleBlockFilter = {
  afterMerge?: InputMaybe<BitqueryBooleanSelector>;
  afterSplit?: InputMaybe<BitqueryBooleanSelector>;
  beforeSplit?: InputMaybe<BitqueryBooleanSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  catchainSeqno?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  globalId?: InputMaybe<BitqueryIntegerSelector>;
  logicalTimeEnd?: InputMaybe<BitqueryBigIntegerSelector>;
  logicalTimeStart?: InputMaybe<BitqueryBigIntegerSelector>;
  minimalReferenceMasterchainBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  softwareCapabilities?: InputMaybe<BitqueryStringSelector>;
  softwareVersion?: InputMaybe<BitqueryIntegerSelector>;
  status?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txCount?: InputMaybe<BitqueryIntegerSelector>;
  validatorListHastShort?: InputMaybe<BitqueryIntegerSelector>;
  valueFlowCreated?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowExported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesCollected?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFeesImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowFromPreviousBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowImported?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowMinted?: InputMaybe<BitqueryBigIntegerSelector>;
  valueFlowToNextBlock?: InputMaybe<BitqueryBigIntegerSelector>;
  version?: InputMaybe<BitqueryBigIntegerSelector>;
  verticalSeqNo?: InputMaybe<BitqueryBigIntegerSelector>;
  wantMerge?: InputMaybe<BitqueryBooleanSelector>;
  wantSplit?: InputMaybe<BitqueryBooleanSelector>;
};

export type BitqueryEverscaleBlockMeasurable =
  /** After Merge */
  | 'after_merge'
  /** After Split */
  | 'after_split'
  /** Before Split */
  | 'before_split'
  /** Date */
  | 'date'
  /** Global ID */
  | 'global_id'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Logical Time End */
  | 'logical_time_end'
  /** Logical Time Start */
  | 'logical_time_start'
  /** Minimal Reference Masterchain Block */
  | 'minimal_reference_masterchain_block'
  /** Previous Block */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Status */
  | 'status'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'tx_count'
  /** Value created */
  | 'value_flow_created'
  /** Value Exported */
  | 'value_flow_exported'
  /** Value Fees collected */
  | 'value_flow_fees_collected'
  /** Value Fees imported */
  | 'value_flow_fees_imported'
  /** Value From Previous Block */
  | 'value_flow_from_previous_block'
  /** Value Imported */
  | 'value_flow_imported'
  /** Value minted */
  | 'value_flow_minted'
  /** Value To Previous Block */
  | 'value_flow_to_previous_block'
  /** Version */
  | 'version'
  /** Vertical Sequence */
  | 'vertical_seq_no'
  /** Want Merge */
  | 'want_merge'
  /** Want Split */
  | 'want_split'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleBlockUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times';

/** Call in Everscale blockchain */
export type BitqueryEverscaleCall = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallAnyArgs = {
  of: BitqueryEverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleCallUniq>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleCallUniq>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleCallMeasurable>;
  of: BitqueryEverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleCallMeasurable>;
  of: BitqueryEverscaleCallMeasurable;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Call in Everscale blockchain */
export type BitqueryEverscaleCallTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleCallFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleCallMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Signature */
  | 'signature'
  /** Signature Hash */
  | 'signature_hash'
  /** Signature Name */
  | 'signature_name'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleCallUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Unique Number of signatures */
  | 'smart_contract_methods'
  /** Unique Number of smart contracts */
  | 'smart_contracts'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Everscale Coinpath */
export type BitqueryEverscaleCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathAnyArgs = {
  of: BitqueryEverscaleCoinpathMeasureable;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleCoinpathMeasureable>;
  of: BitqueryEverscaleCoinpathMeasureable;
};


/** Everscale Coinpath */
export type BitqueryEverscaleCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleCoinpathMeasureable>;
  of: BitqueryEverscaleCoinpathMeasureable;
};

export type BitqueryEverscaleCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Event in Everscale blockchain */
export type BitqueryEverscaleEvent = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventAnyArgs = {
  of: BitqueryEverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleEventUniq>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleEventUniq>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleEventMeasurable>;
  of: BitqueryEverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleEventMeasurable>;
  of: BitqueryEverscaleEventMeasurable;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Event in Everscale blockchain */
export type BitqueryEverscaleEventTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleEventFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleEventMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Signature */
  | 'signature'
  /** Signature Hash */
  | 'signature_hash'
  /** Signature Name */
  | 'signature_name'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleEventUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Unique Number of signatures */
  | 'smart_contract_methods'
  /** Unique Number of smart contracts */
  | 'smart_contracts'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** General Block information */
export type BitqueryEverscaleGeneralDimension = {
  /** Catchain Sequence */
  catchainSeqno?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Software capabilities */
  softwareCapabilities?: Maybe<Scalars['String']['output']>;
  /** Software version */
  softwareVersion?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Validator List Hast Short */
  validatorListHashShort?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Message in Everscale blockchain */
export type BitqueryEverscaleMessage = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message boc */
  boc?: Maybe<Scalars['String']['output']>;
  /** Message body */
  body?: Maybe<Scalars['String']['output']>;
  /** Message body hash */
  bodyHash?: Maybe<Scalars['String']['output']>;
  /** Message Bounce */
  bounce?: Maybe<Scalars['Boolean']['output']>;
  /** Message bounced */
  bounced?: Maybe<Scalars['Boolean']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message created logical time */
  createdLogicalTime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message data */
  data?: Maybe<Scalars['String']['output']>;
  /** Message data hash */
  dataHash?: Maybe<Scalars['String']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Message Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Message fwd fee */
  fwdFee?: Maybe<Scalars['Float']['output']>;
  /** Message Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message ihr disabled */
  ihrDisabled?: Maybe<Scalars['Boolean']['output']>;
  /** Message ihr fee */
  ihrFee?: Maybe<Scalars['Float']['output']>;
  /** Message index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Message sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Message Type Name */
  typeName?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageAnyArgs = {
  of: BitqueryEverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleMessageUniq>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleMessageUniq>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleMessageMeasurable>;
  of: BitqueryEverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleMessageMeasurable>;
  of: BitqueryEverscaleMessageMeasurable;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};


/** Message in Everscale blockchain */
export type BitqueryEverscaleMessageValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

/** Information about message */
export type BitqueryEverscaleMessageDimension = {
  /** Message Direction */
  direction?: Maybe<Scalars['String']['output']>;
  /** Message Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Message Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Message Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Message Type */
  typeName?: Maybe<Scalars['String']['output']>;
  /** Message value */
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryEverscaleMessageDirectionEnum =
  /** Inbound message */
  | 'in'
  /** Outbound Message */
  | 'out';

/** Select by message direction */
export type BitqueryEverscaleMessageDirectionSelector = {
  /** Message Direction in the list */
  in?: InputMaybe<Array<BitqueryEverscaleMessageDirectionEnum>>;
  /** Message Direction is */
  is?: InputMaybe<BitqueryEverscaleMessageDirectionEnum>;
  /** Message Direction not */
  not?: InputMaybe<BitqueryEverscaleMessageDirectionEnum>;
  /** Message Direction not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleMessageDirectionEnum>>;
};

export type BitqueryEverscaleMessageFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  messageBoc?: InputMaybe<BitqueryStringSelector>;
  messageBody?: InputMaybe<BitqueryStringSelector>;
  messageBodyHash?: InputMaybe<BitqueryStringSelector>;
  messageBounce?: InputMaybe<BitqueryBooleanSelector>;
  messageBounced?: InputMaybe<BitqueryBooleanSelector>;
  messageCreatedLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  messageData?: InputMaybe<BitqueryStringSelector>;
  messageDataHash?: InputMaybe<BitqueryStringSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageFwdFee?: InputMaybe<BitqueryFloatSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageIhrDisabled?: InputMaybe<BitqueryBooleanSelector>;
  messageIndex?: InputMaybe<BitqueryIntegerSelector>;
  messageIrbFee?: InputMaybe<BitqueryFloatSelector>;
  messageReceiver?: InputMaybe<BitqueryStringSelector>;
  messageSender?: InputMaybe<BitqueryStringSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleMessageMeasurable =
  /** Message boc */
  | 'boc'
  /** Message body */
  | 'body'
  /** Message body hash */
  | 'body_hash'
  /** Message bounce */
  | 'bounce'
  /** Message bounced */
  | 'bounced'
  /** Message created logical time */
  | 'created_logical_time'
  /** Message data */
  | 'data'
  /** Message data hash */
  | 'data_hash'
  /** Date */
  | 'date'
  /** Message fwd fee */
  | 'fwd_fee'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message Ihr Disabled */
  | 'ihr_disabled'
  /** Message ihr fee */
  | 'ihr_fee'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message Index */
  | 'message_index'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message Type Name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleMessageTypeNameEnum =
  /** ExtInt Message */
  | 'ExtInt'
  /** ExtOut Message */
  | 'ExtOut'
  /** Internal Message */
  | 'Internal';

/** Select by message type name */
export type BitqueryEverscaleMessageTypeNameSelector = {
  /** Message type name in the list */
  in?: InputMaybe<Array<BitqueryEverscaleMessageTypeNameEnum>>;
  /** Message type name is */
  is?: InputMaybe<BitqueryEverscaleMessageTypeNameEnum>;
  /** Message type name not */
  not?: InputMaybe<BitqueryEverscaleMessageTypeNameEnum>;
  /** Message type name not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleMessageTypeNameEnum>>;
};

export type BitqueryEverscaleMessageUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of Message Receivers */
  | 'message_receiver'
  /** Unique Number of Message Senders */
  | 'message_sender'
  /** Unique Number of Messages */
  | 'messages'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

export type BitqueryEverscaleNetwork =
  /** Everscale */
  | 'everscale';

/** Phase in Everscale blockchain */
export type BitqueryEverscalePhase = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Phase data */
  data?: Maybe<Scalars['String']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Phase Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseAnyArgs = {
  of: BitqueryEverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscalePhaseUniq>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscalePhaseUniq>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseFeeArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseMaximumArgs = {
  get?: InputMaybe<BitqueryEverscalePhaseMeasurable>;
  of: BitqueryEverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseMinimumArgs = {
  get?: InputMaybe<BitqueryEverscalePhaseMeasurable>;
  of: BitqueryEverscalePhaseMeasurable;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Phase in Everscale blockchain */
export type BitqueryEverscalePhaseTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscalePhaseFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  phaseData?: InputMaybe<BitqueryStringSelector>;
  phaseFee?: InputMaybe<BitqueryFloatSelector>;
  phaseType?: InputMaybe<BitqueryStringSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscalePhaseMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Phase data */
  | 'phase_data'
  /** Phase fee */
  | 'phase_fee'
  /** Phase type */
  | 'phase_type'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscalePhaseUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of phases */
  | 'phases'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Information about sharded block */
export type BitqueryEverscaleShardedBlockDimension = {
  /** Hash of the the master block */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of master block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard master number of block */
  shard?: Maybe<Scalars['String']['output']>;
  /** Workchain master block hash */
  workchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransaction = {
  /** Transaction Aborted */
  aborted?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction Account */
  account?: Maybe<Scalars['String']['output']>;
  accountFees?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Boc */
  boc?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Credit First */
  creditFirst?: Maybe<Scalars['Int']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Transaction Destroyed */
  destroyed?: Maybe<Scalars['Boolean']['output']>;
  /** The end state of an account after a transaction */
  endStatus?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Tx Ext In And Ihr In Fees */
  extInAndIhrInFees?: Maybe<Scalars['Float']['output']>;
  /** Transaction Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Internal Message bounce flag */
  inMessageBounceFlag?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction Logical Time */
  logicalTime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction New Hash */
  newHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Old Hash */
  oldHash?: Maybe<Scalars['String']['output']>;
  /** The initial state of account */
  originalStatus?: Maybe<Scalars['String']['output']>;
  /** Transaction Out Messages count */
  outMessagesCount?: Maybe<Scalars['Int']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Out Messages count */
  previousTxHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Previous Tx Logical Time */
  previousTxLogicalTime?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionAccountFeesArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionAnyArgs = {
  of: BitqueryEverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransactionUniq>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransactionUniq>;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransactionMeasurable>;
  of: BitqueryEverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransactionMeasurable>;
  of: BitqueryEverscaleTransactionMeasurable;
};


/** Transaction in Everscale blockchain */
export type BitqueryEverscaleTransactionShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};

/** Information about transaction */
export type BitqueryEverscaleTransactionDimension = {
  /** Transaction Aborted */
  aborted?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction Account */
  account?: Maybe<Scalars['String']['output']>;
  /** The end state of an account after a transaction */
  endStatus?: Maybe<Scalars['String']['output']>;
  /** Transaction Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** The initial state of account */
  originalStatus?: Maybe<Scalars['String']['output']>;
  /** Transaction Type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryEverscaleTransactionFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  previousTxHash?: InputMaybe<BitqueryStringSelector>;
  previousTxLogicalTime?: InputMaybe<BitqueryBigIntegerSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txAborted?: InputMaybe<BitqueryBooleanSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txAccountFees?: InputMaybe<BitqueryFloatSelector>;
  txCreditFirst?: InputMaybe<BitqueryBooleanSelector>;
  txDestroyed?: InputMaybe<BitqueryBooleanSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txExtInAndIhrInFees?: InputMaybe<BitqueryFloatSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txInMessageBounceFlag?: InputMaybe<BitqueryBooleanSelector>;
  txLogicalTime?: InputMaybe<BitqueryIntegerSelector>;
  txNewHash?: InputMaybe<BitqueryStringSelector>;
  txOldHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txOutMessagesCount?: InputMaybe<BitqueryIntegerSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleTransactionMeasurable =
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Previous Transaction */
  | 'previous_block'
  /** Previous Tx Hash */
  | 'previous_tx_hash'
  /** Previous Tx Logical Time */
  | 'previous_tx_logical_time'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx New Hash */
  | 'tx_new_hash'
  /** Tx Old hash */
  | 'tx_old_hash'
  /** Tx Type */
  | 'tx_type'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleTransactionUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of Transactions */
  | 'txs';

/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransfer = {
  amount?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Shard number of block */
  blockShard?: Maybe<Scalars['String']['output']>;
  /** Proposer block hash */
  blockWorkchain?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** NFT Id */
  entityId: Scalars['BitqueryBigInt']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** messages */
  messages?: Maybe<BitqueryEverscaleMessageDimension>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Previous Block */
  previousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transfer To */
  receiver: BitqueryAddress;
  /** Transfer From */
  sender: BitqueryAddress;
  /** Sharded Block Information */
  shardedBlock?: Maybe<BitqueryEverscaleShardedBlockDimension>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transactions */
  transactions?: Maybe<BitqueryEverscaleTransactionDimension>;
  /** Transfer type */
  transferType: Scalars['String']['output'];
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferAmountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferAmountDecimalArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferAnyArgs = {
  of: BitqueryEverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransferUniq>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryEverscaleTransferUniq>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferMaximumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransferMeasurable>;
  of: BitqueryEverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferMessagesArgs = {
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferMinimumArgs = {
  get?: InputMaybe<BitqueryEverscaleTransferMeasurable>;
  of: BitqueryEverscaleTransferMeasurable;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferShardedBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  shard?: InputMaybe<BitqueryStringIdSelector>;
  workchain?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Transfer in Everscale blockchain */
export type BitqueryEverscaleTransferTransactionsArgs = {
  txAborted?: InputMaybe<BitqueryBigIntIdSelector>;
  txAccount?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryEverscaleTransferFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockHeight?: InputMaybe<BitqueryBlockSelector>;
  blockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  blockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  messageDirection?: InputMaybe<BitqueryEverscaleMessageDirectionSelector>;
  messageHash?: InputMaybe<BitqueryHashSelector>;
  messageReceiver?: InputMaybe<BitqueryAddressSelector>;
  messageSender?: InputMaybe<BitqueryAddressSelector>;
  messageTypeName?: InputMaybe<BitqueryEverscaleMessageTypeNameSelector>;
  messageValue?: InputMaybe<BitqueryFloatSelector>;
  previousBlock?: InputMaybe<BitqueryBlockSelector>;
  shardedBlockHash?: InputMaybe<BitqueryHashSelector>;
  shardedBlockShard?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedBlockWorkchain?: InputMaybe<BitqueryBigIntIdSelector>;
  shardedHeight?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferReceiver?: InputMaybe<BitqueryStringSelector>;
  transferSender?: InputMaybe<BitqueryStringSelector>;
  transferType?: InputMaybe<BitqueryEverscaleTransferTypeSelector>;
  txAborted?: InputMaybe<BitqueryStringSelector>;
  txAccount?: InputMaybe<BitqueryStringSelector>;
  txEndStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txHash?: InputMaybe<BitqueryStringSelector>;
  txOriginalStatus?: InputMaybe<BitqueryEverscaleAccountStateSelector>;
  txType?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryEverscaleTransferMeasurable =
  /** Currency Address */
  | 'currency_address'
  /** Currency Name */
  | 'currency_name'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Hash of the the block */
  | 'hash'
  /** Number of block in the blockhains */
  | 'height'
  /** Message direction */
  | 'message_direction'
  /** Message Hash */
  | 'message_hash'
  /** Message receiver */
  | 'message_receiver'
  /** Message sender */
  | 'message_sender'
  /** Message type name */
  | 'message_type_name'
  /** Message value */
  | 'message_value'
  /** Previous Message */
  | 'previous_block'
  /** Shard of block in the blockhains */
  | 'shard'
  /** Number of sharded block block in the blockhains */
  | 'sharded_block'
  /** Hash of the the sharded block block */
  | 'sharded_block_hash'
  /** Shard of sharded block block in the blockhains */
  | 'sharded_block_shard'
  /** Workchain of sharded block block in the blockhains */
  | 'sharded_block_workchain'
  /** Time */
  | 'time'
  /** Tx Aborted */
  | 'tx_aborted'
  /** Tx Account */
  | 'tx_account'
  /** Tx Hash */
  | 'tx_hash'
  /** Tx Type */
  | 'tx_type'
  /** Value */
  | 'value'
  /** Workchain of block in the blockhains */
  | 'workchain';

export type BitqueryEverscaleTransferTypeEnum =
  /** Token Burn */
  | 'token_burn'
  /** Token Mint */
  | 'token_mint'
  /** Token Transfers */
  | 'token_transfer'
  /** Transaction transfer */
  | 'transaction';

/** Select by message type name */
export type BitqueryEverscaleTransferTypeSelector = {
  /** Transfer type name in the list */
  in?: InputMaybe<Array<BitqueryEverscaleTransferTypeEnum>>;
  /** Transfer type name is */
  is?: InputMaybe<BitqueryEverscaleTransferTypeEnum>;
  /** Transfer type name not */
  not?: InputMaybe<BitqueryEverscaleTransferTypeEnum>;
  /** Transfer type name not in the list */
  notIn?: InputMaybe<Array<BitqueryEverscaleTransferTypeEnum>>;
};

export type BitqueryEverscaleTransferUniq =
  /** Unique Number of Shards in the blockchains */
  | 'block_shard'
  /** Unique Number of workchains in the blockchains */
  | 'block_workchain'
  /** Unique Number of currencies */
  | 'currencies'
  /** Uniq dates count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of messages */
  | 'messages'
  /** Unique Number of receivers */
  | 'receivers'
  /** Unique Number of senders */
  | 'senders'
  /** Unique Number of sharded block shards in the blockchains */
  | 'sharded_block_shards'
  /** Unique Number of sharded block workchains in the blockchains */
  | 'sharded_block_workchains'
  /** Unique Number of sharded blocks in the blockchains */
  | 'sharded_blocks'
  /** Uniq times count */
  | 'times'
  /** Unique Number of transactions */
  | 'txs';

/** Value Block information */
export type BitqueryEverscaleValueDimension = {
  /** Created */
  created?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Exported */
  exported?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Fees Collected */
  feesCollected?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Fees imported */
  feesImported?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** From Previous Block */
  fromPreviousBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Imported */
  imported?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Minted */
  minted?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Value Flow To Next Block */
  toNextBlock?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Filecoin */
export type BitqueryFilecoin = {
  /** Basic information about address */
  address: Array<BitqueryFilecoinAddressInfoWithBalance>;
  /** Filecoin Network Blocks */
  blocks?: Maybe<Array<BitqueryFilecoinBlock>>;
  /** Filecoin Network Calls */
  calls?: Maybe<Array<BitqueryFilecoinCalls>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryFilecoinCoinpath>>;
  /** Filecoin Network Messages ( blocks, transfers, ... ) */
  messages?: Maybe<Array<BitqueryFilecoinMessages>>;
  /** Filecoin Network Currency Transfers */
  transfers?: Maybe<Array<BitqueryFilecoinTransfers>>;
};


/** Filecoin */
export type BitqueryFilecoinAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Filecoin */
export type BitqueryFilecoinBlocksArgs = {
  any?: InputMaybe<Array<BitqueryFilecoinBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinCallsArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  any?: InputMaybe<Array<BitqueryFilecoinCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinMessagesArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  any?: InputMaybe<Array<BitqueryFilecoinMessageFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Filecoin */
export type BitqueryFilecoinTransfersArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  any?: InputMaybe<Array<BitqueryFilecoinTransferFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};

/** Blockchain address */
export type BitqueryFilecoinAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Wallet balance */
  balance?: Maybe<Scalars['Float']['output']>;
};


/** Blockchain address */
export type BitqueryFilecoinAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Block */
export type BitqueryFilecoinBlock = {
  any?: Maybe<Scalars['String']['output']>;
  blockSig?: Maybe<BitqueryNameWithId>;
  blsAggregate?: Maybe<BitqueryNameWithId>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  electionProof?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  forkSignalling?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block round in blockchain */
  height: Scalars['Int']['output'];
  /** Block index on height */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  messageCount?: Maybe<Scalars['Int']['output']>;
  messageCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  messages?: Maybe<Scalars['String']['output']>;
  /** Miner */
  miner?: Maybe<BitqueryAddress>;
  minerTips?: Maybe<Scalars['Float']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  parentMessageReceipts?: Maybe<Scalars['String']['output']>;
  parentStateRoot?: Maybe<Scalars['String']['output']>;
  parentWeight?: Maybe<Scalars['BitqueryBigInt']['output']>;
  reward?: Maybe<Scalars['Float']['output']>;
  ticket?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalReward?: Maybe<Scalars['Float']['output']>;
  winCount?: Maybe<Scalars['Int']['output']>;
  winCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  wincount?: Maybe<Scalars['Int']['output']>;
};


/** Block */
export type BitqueryFilecoinBlockAnyArgs = {
  of: BitqueryFilecoinBlocksMeasureable;
};


/** Block */
export type BitqueryFilecoinBlockCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinBlockUniq>;
};


/** Block */
export type BitqueryFilecoinBlockCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinBlockUniq>;
};


/** Block */
export type BitqueryFilecoinBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryFilecoinBlockHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Block */
export type BitqueryFilecoinBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryFilecoinBlockIndexArgs = {
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinBlocksMeasureable>;
  of: BitqueryFilecoinBlocksMeasureable;
};


/** Block */
export type BitqueryFilecoinBlockMessageCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMessageCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMinerArgs = {
  miner?: InputMaybe<BitqueryAddressSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMinerTipsArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinBlocksMeasureable>;
  of: BitqueryFilecoinBlocksMeasureable;
};


/** Block */
export type BitqueryFilecoinBlockRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockTotalRewardArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockWinCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryFilecoinBlockWinCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryFilecoinBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  blockIndex?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryFilecoinBlockUniq =
  /** Unique block count */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique block height count */
  | 'heights'
  /** Miner */
  | 'miners';

export type BitqueryFilecoinBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Block Miner */
  | 'miner'
  /** Time */
  | 'time';

export type BitqueryFilecoinCallFilter = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCalls = {
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer Message is included */
  block?: Maybe<BitqueryBlock>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']['output']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  exitCode?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  gasFeeCap?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasPremium?: Maybe<Scalars['Float']['output']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message Method */
  messageMethod?: Maybe<BitqueryNameWithId>;
  /** Method */
  method?: Maybe<BitqueryNameWithId>;
  minedBlock?: Maybe<BitqueryFilecoinMinedBlock>;
  minimum?: Maybe<Scalars['String']['output']>;
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Message receiver */
  receiver?: Maybe<BitqueryAddressWithAccount>;
  returnValue?: Maybe<Scalars['String']['output']>;
  /** Message sender */
  sender?: Maybe<BitqueryAddressWithAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsAmountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsAmountDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsAnyArgs = {
  of: BitqueryFilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsCountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsCountBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsGasArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsHashArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinCallsMeasureable>;
  of: BitqueryFilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMessageMethodArgs = {
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMethodArgs = {
  method?: InputMaybe<BitqueryIntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinCallsMeasureable>;
  of: BitqueryFilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Calls in Filecoin blockchain */
export type BitqueryFilecoinCallsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BitqueryFilecoinCallsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas limit */
  | 'gas_limit'
  /** Gas value */
  | 'gas_value'
  /** Message hash */
  | 'message_hash'
  /** Time */
  | 'time';

/** Coinpath */
export type BitqueryFilecoinCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message of transfer happened */
  message?: Maybe<BitqueryTransactionHashValue>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryFilecoinCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

export type BitqueryFilecoinMessageFilter = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessages = {
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  baseFeeBurn?: Maybe<Scalars['Float']['output']>;
  baseFeeBurnDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Block where transfer Message is included */
  block?: Maybe<BitqueryBlock>;
  burned?: Maybe<Scalars['Float']['output']>;
  burnedDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  exitCode?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  gasBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasFeeCap?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  gasPremium?: Maybe<Scalars['Float']['output']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Method */
  method?: Maybe<BitqueryNameWithId>;
  minedBlock?: Maybe<BitqueryFilecoinMinedBlock>;
  minerPenalty?: Maybe<Scalars['Float']['output']>;
  minerPenaltyDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  minerTip?: Maybe<Scalars['Float']['output']>;
  minerTipDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  overEstimationBurn?: Maybe<Scalars['Float']['output']>;
  overEstimationBurnDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Message receiver */
  receiver?: Maybe<BitqueryAddressWithAccount>;
  refund?: Maybe<Scalars['Float']['output']>;
  refundDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  returnValue?: Maybe<Scalars['String']['output']>;
  /** Message sender */
  sender?: Maybe<BitqueryAddressWithAccount>;
  signature?: Maybe<Scalars['String']['output']>;
  signatureType?: Maybe<Scalars['String']['output']>;
  /** Signed Message hash */
  signedHash?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  totalCost?: Maybe<Scalars['Float']['output']>;
  totalCostDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesAmountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesAmountDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesAnyArgs = {
  of: BitqueryFilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBaseFeeBurnArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBaseFeeBurnDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBurnedArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesBurnedDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesCountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesCountBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesGasArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesGasBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesHashArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinMessagesMeasureable>;
  of: BitqueryFilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMethodArgs = {
  method?: InputMaybe<BitqueryIntegerSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerPenaltyArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerPenaltyDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerTipArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinerTipDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinMessagesMeasureable>;
  of: BitqueryFilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesOverEstimationBurnArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesOverEstimationBurnDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesRefundArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesRefundDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesTotalCostArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type BitqueryFilecoinMessagesTotalCostDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryFilecoinMessagesMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas limit */
  | 'gas_limit'
  /** Gas value */
  | 'gas_value'
  /** Message hash */
  | 'message_hash'
  /** Time */
  | 'time';

export type BitqueryFilecoinMessagesUniq =
  /** Unique block heights */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique Message receivers */
  | 'receivers'
  /** Unique Message senders */
  | 'senders';

/** Filecoin Mined Block */
export type BitqueryFilecoinMinedBlock = {
  /** Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index on height */
  index?: Maybe<Scalars['Int']['output']>;
  /** Miner */
  miner?: Maybe<BitqueryAddress>;
};

export type BitqueryFilecoinNetwork =
  /** Filecoin Mainnet */
  | 'filecoin';

export type BitqueryFilecoinTransferFilter = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};

export type BitqueryFilecoinTransferType =
  /** Burn */
  | 'burn'
  /** Genesis */
  | 'genesis'
  /** Miner Tip */
  | 'miner'
  /** Rebalance */
  | 'rebalance'
  /** Reward */
  | 'reward'
  /** Send (transfer) */
  | 'send';

/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfers = {
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer Transfer is included */
  block?: Maybe<BitqueryBlockExtended>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']['output']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Message Method */
  messageMethod?: Maybe<BitqueryNameWithId>;
  /** Method */
  method?: Maybe<BitqueryNameWithId>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transfer timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Type of transfer */
  transferType?: Maybe<BitqueryFilecoinTransferType>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersAmountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersAmountDecimalArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersAnyArgs = {
  of: BitqueryFilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersCountArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersCountBigIntArgs = {
  amount?: InputMaybe<BitqueryAmountSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
  method?: InputMaybe<BitqueryIntegerSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
  uniq?: InputMaybe<BitqueryFilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersHashArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryFilecoinTransfersMeasureable>;
  of: BitqueryFilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMessageMethodArgs = {
  messageMethod?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMethodArgs = {
  method?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryFilecoinTransfersMeasureable>;
  of: BitqueryFilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type BitqueryFilecoinTransfersTransferTypeArgs = {
  transferType?: InputMaybe<BitqueryTransferTypeSelector>;
};

export type BitqueryFilecoinTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Currency Name */
  | 'currency_name'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Message hash */
  | 'message_hash'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type';

/** Select by number */
export type BitqueryFloatSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['Float']['input']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['Float']['input']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['Float']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['Float']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Float']['input']>;
  /** not */
  not?: InputMaybe<Scalars['Float']['input']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

/** Flow Chain */
export type BitqueryFlow = {
  /** Basic information about address */
  address: Array<BitqueryFlowAddressInfoWithBalance>;
  /** The outermost portion of the transaction, which contains the payload and envelope signatures */
  arguments?: Maybe<Array<BitqueryFlowArgument>>;
  /**
   * A block seal is an attestation that the execution result of a specific block has
   *                    been verified and approved by a quorum of verification nodes.
   */
  blockSeals?: Maybe<Array<BitqueryFlowBlockSeal>>;
  /** Full block information. */
  blocks?: Maybe<Array<BitqueryFlowBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryFlowCoinpath>>;
  /** A collection is a batch of transactions that have been includes in a block. */
  collections?: Maybe<Array<BitqueryFlowCollection>>;
  /** Event fields */
  eventFields?: Maybe<Array<BitqueryFlowEventField>>;
  /**
   * An event is emitted as the result of a transaction execution.
   *         Events are either user-defined events originating from a Cadence smart contract, or built-in Flow system events.
   */
  events?: Maybe<Array<BitqueryFlowEvent>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitqueryFlowInput>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitqueryFlowOutput>>;
  /** List of transaction authorizers */
  transactionAuthorizers?: Maybe<Array<BitqueryFlowTransactionAuthorizer>>;
  /** The outermost portion of the transaction, which contains the payload and envelope signatures */
  transactionEnvelopeSignatures?: Maybe<Array<BitqueryFlowTransactionEnvelopeSignature>>;
  /**
   * The transaction authorization envelope contains both the
   *                    transaction payload and the payload signatures.
   */
  transactionPayloadSignatures?: Maybe<Array<BitqueryFlowTransactionPayloadSignature>>;
  /** A transaction represents a unit of computation that is submitted to the Flow network. */
  transactions?: Maybe<Array<BitqueryFlowTransaction>>;
};


/** Flow Chain */
export type BitqueryFlowAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Flow Chain */
export type BitqueryFlowArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryFlowArgumentFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueAsFix?: InputMaybe<BitqueryIntegerSelector>;
  valueAsInt?: InputMaybe<BitqueryIntegerSelector>;
};


/** Flow Chain */
export type BitqueryFlowBlockSealsArgs = {
  any?: InputMaybe<Array<BitqueryFlowBlockSealFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  blockSealId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  executionReceiptId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Flow Chain */
export type BitqueryFlowBlocksArgs = {
  any?: InputMaybe<Array<BitqueryFlowBlockFilter>>;
  collectionsCount?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  id?: InputMaybe<BitqueryHashSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentBlockId?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Flow Chain */
export type BitqueryFlowCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Flow Chain */
export type BitqueryFlowCollectionsArgs = {
  any?: InputMaybe<Array<BitqueryFlowCollectionFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Flow Chain */
export type BitqueryFlowEventFieldsArgs = {
  any?: InputMaybe<Array<BitqueryFlowEventFieldFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsFix?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsInt?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowEventsArgs = {
  any?: InputMaybe<Array<BitqueryFlowEventFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowInputsArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitqueryFlowInputFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowOutputsArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitqueryFlowOutputFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionAuthorizersArgs = {
  any?: InputMaybe<Array<BitqueryFlowTransactionAuthorizerFilter>>;
  authorizer?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionEnvelopeSignaturesArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryFlowTransactionEnvelopeSignatureFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionPayloadSignaturesArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryFlowTransactionPayloadSignatureFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};


/** Flow Chain */
export type BitqueryFlowTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryFlowTransactionFilter>>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain address */
export type BitqueryFlowAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** FLOW currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
};


/** Blockchain address */
export type BitqueryFlowAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Arguments in Flow blockchain */
export type BitqueryFlowArgument = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index of the argument inside transaction */
  index: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
  /** Value */
  value: Scalars['String']['output'];
  valueAsFix?: Maybe<Scalars['Float']['output']>;
  /** Value converted to integer */
  valueAsInt: Scalars['Int']['output'];
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentAnyArgs = {
  of: BitqueryFlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentCountArgs = {
  uniq?: InputMaybe<BitqueryFlowArgumentUniq>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowArgumentUniq>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryFlowArgumentMeasureable>;
  of: BitqueryFlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryFlowArgumentMeasureable>;
  of: BitqueryFlowArgumentMeasureable;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};


/** Arguments in Flow blockchain */
export type BitqueryFlowArgumentValueAsFixArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueAsFix?: InputMaybe<BitqueryIntegerSelector>;
  valueAsInt?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowArgumentFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  value?: InputMaybe<BitqueryStringSelector>;
  valueAsFix?: InputMaybe<BitqueryIntegerSelector>;
  valueAsInt?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowArgumentMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'transaction_id'
  /** Type */
  | 'type'
  /** Value */
  | 'value'
  /** Value with UFix64 type and converted to integer */
  | 'value_as_fix';

export type BitqueryFlowArgumentUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions';

/** Block in Flow blockchain */
export type BitqueryFlowBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** 	BLS signatures of consensus nodes */
  blockSignatures?: Maybe<Array<Scalars['String']['output']>>;
  /** Count of collections */
  collectionsCount?: Maybe<Scalars['Int']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Height of the block in the chain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** SHA3-256 hash of the entire block payload */
  id?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** ID of the previous block in the chain */
  parentBlockId?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions */
  transactionsCount?: Maybe<Scalars['Int']['output']>;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockAnyArgs = {
  of: BitqueryFlowBlockMeasureable;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockCountArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockUniq>;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockUniq>;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockMaximumArgs = {
  get?: InputMaybe<BitqueryFlowBlockMeasureable>;
  of: BitqueryFlowBlockMeasureable;
};


/** Block in Flow blockchain */
export type BitqueryFlowBlockMinimumArgs = {
  get?: InputMaybe<BitqueryFlowBlockMeasureable>;
  of: BitqueryFlowBlockMeasureable;
};

export type BitqueryFlowBlockDimension = {
  /** Height of the block in the chain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** SHA3-256 hash of the entire block payload */
  id?: Maybe<Scalars['String']['output']>;
};

export type BitqueryFlowBlockFilter = {
  collectionsCount?: InputMaybe<BitqueryIntegerSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  id?: InputMaybe<BitqueryHashSelector>;
  parentBlockId?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowBlockMeasureable =
  /** Count of collections */
  | 'collections_count'
  /** Date */
  | 'date'
  /** Height of the block in the chain */
  | 'height'
  /** SHA3-256 hash of the entire block payload */
  | 'id'
  /** ID of the previous block in the chain */
  | 'parent_block_id'
  /** Time */
  | 'time'
  /** Count of transactions */
  | 'transactions_count';

/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSeal = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** ID execution receipt being sealed */
  executionReceiptId?: Maybe<Scalars['String']['output']>;
  /** BLS signatures of verification nodes on the execution receipt contents */
  executionReceiptSignatures?: Maybe<Array<Scalars['String']['output']>>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Index inside block */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** BLS signatures of verification nodes on the result approval contents */
  resultApprovalSignatures?: Maybe<Array<Scalars['String']['output']>>;
  /** ID of the block being sealed */
  sealId?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealAnyArgs = {
  of: BitqueryFlowBlockSealsMeasureable;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealCountArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockSealUniq>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowBlockSealUniq>;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealMaximumArgs = {
  get?: InputMaybe<BitqueryFlowBlockSealsMeasureable>;
  of: BitqueryFlowBlockSealsMeasureable;
};


/** Block seals in Flow blockchain */
export type BitqueryFlowBlockSealMinimumArgs = {
  get?: InputMaybe<BitqueryFlowBlockSealsMeasureable>;
  of: BitqueryFlowBlockSealsMeasureable;
};

export type BitqueryFlowBlockSealFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  blockSealId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  executionReceiptId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryFlowBlockSealUniq =
  /** Unique number of sealed blocks */
  | 'block_seal_id'
  /** Unique date count */
  | 'dates'
  /** ID execution receipt being sealed */
  | 'execution_receipt_id'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type BitqueryFlowBlockSealsMeasureable =
  /** SHA3-256 hash of the entire block payload */
  | 'block_id'
  /** ID of the block being sealed */
  | 'block_seal_id'
  /** Date */
  | 'date'
  /** ID execution receipt being sealed */
  | 'execution_receipt_id'
  /** Height of the block in the chain */
  | 'height'
  /** Time */
  | 'time';

export type BitqueryFlowBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** FlowCoinpath */
export type BitqueryFlowCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryFlowTransactionHashIndexValues>;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** FlowCoinpath */
export type BitqueryFlowCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Collections in Flow blockchain */
export type BitqueryFlowCollection = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** SHA3-256 hash of the collection contents */
  id?: Maybe<Scalars['String']['output']>;
  /** Index of collection inside block */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** BLS signatures of the collection nodes guaranteeing the collection */
  signatures?: Maybe<Array<Scalars['String']['output']>>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions inside collection */
  transactionsCount?: Maybe<Scalars['Int']['output']>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionAnyArgs = {
  of: BitqueryFlowCollectionsMeasureable;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionCountArgs = {
  uniq?: InputMaybe<BitqueryFlowCollectionUniq>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowCollectionUniq>;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionMaximumArgs = {
  get?: InputMaybe<BitqueryFlowCollectionsMeasureable>;
  of: BitqueryFlowCollectionsMeasureable;
};


/** Collections in Flow blockchain */
export type BitqueryFlowCollectionMinimumArgs = {
  get?: InputMaybe<BitqueryFlowCollectionsMeasureable>;
  of: BitqueryFlowCollectionsMeasureable;
};

export type BitqueryFlowCollectionFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionsCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowCollectionUniq =
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Index of collection inside block */
  | 'collection_index'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

export type BitqueryFlowCollectionsMeasureable =
  /** SHA3-256 hash of the entire block payload */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Index of collection inside block */
  | 'collection_index'
  /** Date */
  | 'date'
  /** Height of the block in the chain */
  | 'height'
  /** Time */
  | 'time'
  /** Count of transactions inside collection */
  | 'transactions_count';

export type BitqueryFlowDirection =
  /** Inbound transfers */
  | 'inbound'
  /** Outbound transfers */
  | 'outbound';

/** Events in Flow blockchain */
export type BitqueryFlowEvent = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  index: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** Events in Flow blockchain */
export type BitqueryFlowEventAnyArgs = {
  of: BitqueryFlowEventMeasureable;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventCountArgs = {
  uniq?: InputMaybe<BitqueryFlowEventUniq>;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowEventUniq>;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Events in Flow blockchain */
export type BitqueryFlowEventMaximumArgs = {
  get?: InputMaybe<BitqueryFlowEventMeasureable>;
  of: BitqueryFlowEventMeasureable;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventMinimumArgs = {
  get?: InputMaybe<BitqueryFlowEventMeasureable>;
  of: BitqueryFlowEventMeasureable;
};


/** Events in Flow blockchain */
export type BitqueryFlowEventTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

/** EventFields in Flow blockchain */
export type BitqueryFlowEventField = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Index of event inside transaction */
  eventIndex: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Field */
  field: Scalars['String']['output'];
  /** Field as fix */
  fieldAsFix: Scalars['String']['output'];
  /** Field as fix */
  fieldAsInt: Scalars['String']['output'];
  /** Index of field inside event */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldAnyArgs = {
  of: BitqueryFlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldCountArgs = {
  uniq?: InputMaybe<BitqueryFlowEventFieldUniq>;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowEventFieldUniq>;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldExpressionArgs = {
  get: Scalars['String']['input'];
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldMaximumArgs = {
  get?: InputMaybe<BitqueryFlowEventFieldMeasureable>;
  of: BitqueryFlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldMinimumArgs = {
  get?: InputMaybe<BitqueryFlowEventFieldMeasureable>;
  of: BitqueryFlowEventFieldMeasureable;
};


/** EventFields in Flow blockchain */
export type BitqueryFlowEventFieldTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowEventFieldFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsFix?: InputMaybe<BitqueryIntegerSelector>;
  fieldAsInt?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryFlowEventFieldMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code';

export type BitqueryFlowEventFieldUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions';

export type BitqueryFlowEventFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryFlowEventMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code';

export type BitqueryFlowEventUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions';

export type BitqueryFlowFullTransactionDimension = {
  /** Error message */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Count of events inside transaction */
  eventsCount?: Maybe<Scalars['Int']['output']>;
  /** Gas Limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ID of the transaction */
  id?: Maybe<Scalars['String']['output']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']['output']>;
  /** The account paying for the transaction fees */
  payer?: Maybe<Scalars['String']['output']>;
  /** ID of proposal key on the proposal account */
  proposalKeyId?: Maybe<Scalars['Int']['output']>;
  /** Sequence number for the proposal key */
  proposalKeySequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** The account that specifies a proposal key */
  proposer?: Maybe<Scalars['String']['output']>;
  /** Block ID used to determine transaction expiry */
  referenceBlockId?: Maybe<Scalars['String']['output']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']['output']>;
};

/** Inputs in Flow blockchain */
export type BitqueryFlowInput = {
  /** Address */
  address: BitqueryAddress;
  amount?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** NFT Id */
  entityId: Scalars['BitqueryBigInt']['output'];
  /** Index of event inside transaction */
  eventIndex: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee */
  transferReason: Scalars['String']['output'];
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputAmountArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputAmountDecimalArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputAnyArgs = {
  of: BitqueryFlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputCountArgs = {
  uniq?: InputMaybe<BitqueryFlowInputUniq>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputCountBigIntArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryFlowInputUniq>;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputMaximumArgs = {
  get?: InputMaybe<BitqueryFlowInputMeasureable>;
  of: BitqueryFlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputMinimumArgs = {
  get?: InputMaybe<BitqueryFlowInputMeasureable>;
  of: BitqueryFlowInputMeasureable;
};


/** Inputs in Flow blockchain */
export type BitqueryFlowInputTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowInputFilter = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryFlowInputMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Hash of the the block */
  | 'block_id'
  /** Currency address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Index of event inside transaction */
  | 'event_index'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code'
  /** Type */
  | 'type';

export type BitqueryFlowInputUniq =
  /** Unique Number of symbol currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions'
  /** Unique Number of types */
  | 'types';

export type BitqueryFlowMinorTransactionDimension = {
  /** ID of the transaction */
  id?: Maybe<Scalars['String']['output']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']['output']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']['output']>;
};

export type BitqueryFlowNetwork =
  /** Flow mainnet */
  | 'flow';

/** Outputs in Flow blockchain */
export type BitqueryFlowOutput = {
  /** Address */
  address: BitqueryAddress;
  amount?: Maybe<Scalars['Float']['output']>;
  /** Input value as decimal */
  amountDecimal?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** NFT Id */
  entityId: Scalars['BitqueryBigInt']['output'];
  /** Index of event inside transaction */
  eventIndex: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction information */
  transaction: BitqueryFlowMinorTransactionDimension;
  /** Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee */
  transferReason: Scalars['String']['output'];
  /** Type of field, e.g. UInt64, String, Bool, etc.. */
  type: Scalars['String']['output'];
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputAmountArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputAmountDecimalArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputAnyArgs = {
  of: BitqueryFlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputCountArgs = {
  uniq?: InputMaybe<BitqueryFlowOutputUniq>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputCountBigIntArgs = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryFlowOutputUniq>;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputMaximumArgs = {
  get?: InputMaybe<BitqueryFlowOutputMeasureable>;
  of: BitqueryFlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputMinimumArgs = {
  get?: InputMaybe<BitqueryFlowOutputMeasureable>;
  of: BitqueryFlowOutputMeasureable;
};


/** Outputs in Flow blockchain */
export type BitqueryFlowOutputTransactionArgs = {
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryFlowOutputFilter = {
  address?: InputMaybe<BitqueryStringSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryBigIntIdSelector>;
  eventIndex?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryStringSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
  transactionIndexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  transactionStatusCode?: InputMaybe<BitqueryIntegerSelector>;
  transferReason?: InputMaybe<BitqueryFlowTransferReasonSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryFlowOutputMeasureable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Hash of the the block */
  | 'block_id'
  /** Currency address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Entity ID */
  | 'entity_id'
  /** Index of event inside transaction */
  | 'event_index'
  /** Number of block in the blockhains */
  | 'height'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** ID transaction */
  | 'tx_id'
  /** Index of transaction inside collection */
  | 'tx_index_in_collection'
  /** TX status code */
  | 'tx_status_code'
  /** Type */
  | 'type';

export type BitqueryFlowOutputUniq =
  /** Unique Number of symbol currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique Number of events */
  | 'events'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique Number of smart contract methods */
  | 'smart_contract_methods'
  /** Unique Number of smart contract */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Number of transactions */
  | 'transactions'
  /** Unique Number of types */
  | 'types';

/** Transactions in Flow  blockchain */
export type BitqueryFlowTransaction = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Error message */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Count of events inside transaction */
  eventsCount?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Gas Limit */
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ID of the transaction */
  id?: Maybe<Scalars['String']['output']>;
  /** Transaction Index inside collection */
  indexInCollection?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The account paying for the transaction fees */
  payer?: Maybe<BitqueryAddress>;
  /** ID of proposal key on the proposal account */
  proposalKeyId?: Maybe<Scalars['Int']['output']>;
  /** Sequence number for the proposal key */
  proposalKeySequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** The account that specifies a proposal key */
  proposer?: Maybe<BitqueryAddress>;
  /** Block ID used to determine transaction expiry */
  referenceBlockId?: Maybe<Scalars['String']['output']>;
  /** Raw source code for a Cadence script, encoded as UTF-8 bytes */
  script?: Maybe<Scalars['String']['output']>;
  /** Status code of transaction where 0 is success and 1 is failure */
  statusCode?: Maybe<Scalars['Int']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionAnyArgs = {
  of: BitqueryFlowTransactionMeasureable;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionUniq>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionUniq>;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionMeasureable>;
  of: BitqueryFlowTransactionMeasureable;
};


/** Transactions in Flow  blockchain */
export type BitqueryFlowTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionMeasureable>;
  of: BitqueryFlowTransactionMeasureable;
};

/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizer = {
  any?: Maybe<Scalars['String']['output']>;
  /** Account authorizing the transaction to mutate their state. */
  authorizer?: Maybe<BitqueryAddress>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about transaction */
  transaction: BitqueryFlowFullTransactionDimension;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerAnyArgs = {
  of: BitqueryFlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionAuthorizerUniq>;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionAuthorizerUniq>;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerExpressionArgs = {
  get: Scalars['String']['input'];
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionAuthorizerMeasureable>;
  of: BitqueryFlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionAuthorizerMeasureable>;
  of: BitqueryFlowTransactionAuthorizerMeasureable;
};


/** TransactionAuthorizers in Flow blockchain */
export type BitqueryFlowTransactionAuthorizerTransactionArgs = {
  errorMessage?: InputMaybe<BitqueryStringSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryHashSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  referenceBlockId?: InputMaybe<BitqueryHashSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionAuthorizerFilter = {
  authorizer?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionAuthorizerMeasureable =
  /** Account authorizing the transaction to mutate their state. */
  | 'authorizer'
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type BitqueryFlowTransactionAuthorizerUniq =
  /** Unique Number of authorizers */
  | 'authorizers'
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignature = {
  /** Address of the account for this signature */
  address: BitqueryAddress;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** ID of the account key */
  keyId: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Raw signature data */
  signature: Scalars['String']['output'];
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about transaction */
  transaction: BitqueryFlowFullTransactionDimension;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureAnyArgs = {
  of: BitqueryFlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureUniq>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureUniq>;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureExpressionArgs = {
  get: Scalars['String']['input'];
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureMeasureable>;
  of: BitqueryFlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionEnvelopeSignatureMeasureable>;
  of: BitqueryFlowTransactionEnvelopeSignatureMeasureable;
};


/** TransactionEnvelopeSignature in Flow blockchain */
export type BitqueryFlowTransactionEnvelopeSignatureTransactionArgs = {
  errorMessage?: InputMaybe<BitqueryStringSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryHashSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  referenceBlockId?: InputMaybe<BitqueryHashSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionEnvelopeSignatureFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionEnvelopeSignatureMeasureable =
  /** Address of the account for this signature */
  | 'address'
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** ID of account key */
  | 'key_id'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Raw signature data */
  | 'signature'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type BitqueryFlowTransactionEnvelopeSignatureUniq =
  /** The address and key ID fields declare the account key that generated the signature */
  | 'addresses'
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type BitqueryFlowTransactionFilter = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

/** Blockchain transaction */
export type BitqueryFlowTransactionHashIndexValues = {
  /** Hash hex representation */
  id: Scalars['String']['output'];
  /** Transaction value in input */
  valueIn: Scalars['Float']['output'];
  /** Transaction value in input */
  valueInDecimal: Scalars['BitqueryDecimalNumber']['output'];
  /** Transaction value in output */
  valueOut: Scalars['Float']['output'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['BitqueryDecimalNumber']['output'];
};

export type BitqueryFlowTransactionMeasureable =
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignature = {
  /** Address of the account for this signature */
  address: BitqueryAddress;
  any?: Maybe<Scalars['String']['output']>;
  /** Block information */
  block: BitqueryFlowBlockDimension;
  /** SHA3-256 hash of the collection contents */
  collectionId: Scalars['String']['output'];
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** ID of the account key */
  keyId: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Raw signature data */
  signature: Scalars['String']['output'];
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Information about transaction */
  transaction: BitqueryFlowFullTransactionDimension;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureAnyArgs = {
  of: BitqueryFlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureBlockArgs = {
  blockId?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureCountArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionPayloadSignatureUniq>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryFlowTransactionPayloadSignatureUniq>;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureExpressionArgs = {
  get: Scalars['String']['input'];
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureMaximumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionPayloadSignatureMeasureable>;
  of: BitqueryFlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureMinimumArgs = {
  get?: InputMaybe<BitqueryFlowTransactionPayloadSignatureMeasureable>;
  of: BitqueryFlowTransactionPayloadSignatureMeasureable;
};


/** TransactionPayloadSignature in Flow blockchain */
export type BitqueryFlowTransactionPayloadSignatureTransactionArgs = {
  errorMessage?: InputMaybe<BitqueryStringSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryHashSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryHashSelector>;
  referenceBlockId?: InputMaybe<BitqueryHashSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionPayloadSignatureFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  blockId?: InputMaybe<BitqueryHashSelector>;
  collectionId?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  eventsCount?: InputMaybe<BitqueryIntegerSelector>;
  gasLimit?: InputMaybe<BitqueryIntegerSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  indexInCollection?: InputMaybe<BitqueryIntegerSelector>;
  keyId?: InputMaybe<BitqueryIntegerSelector>;
  payer?: InputMaybe<BitqueryAddressSelector>;
  proposalKeyId?: InputMaybe<BitqueryIntegerSelector>;
  proposalKeySequenceNumber?: InputMaybe<BitqueryIntegerSelector>;
  proposer?: InputMaybe<BitqueryAddressSelector>;
  referenceBlockId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  statusCode?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryFlowTransactionPayloadSignatureMeasureable =
  /** Address of the account for this signature */
  | 'address'
  /** Hash of the the block */
  | 'block_id'
  /** SHA3-256 hash of the collection contents */
  | 'collection_id'
  /** Date */
  | 'date'
  /** Error message in transaction */
  | 'error_message'
  /** Count of events inside transactions */
  | 'events_count'
  /** Gas Limit */
  | 'gas_limit'
  /** Number of block in the blockhains */
  | 'height'
  /** ID of account key */
  | 'key_id'
  /** The account paying for the transaction fees */
  | 'payer'
  /** Proposer key sequence number */
  | 'proposal_key_sequence_number'
  /** The account that specifies a proposal key */
  | 'proposer'
  /** Proposer Key ID */
  | 'proposer_key_id'
  /** Reference block hash */
  | 'reference_block_id'
  /** Raw signature data */
  | 'signature'
  /** Status code of transaction */
  | 'status_code'
  /** Time */
  | 'time'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type BitqueryFlowTransactionPayloadSignatureUniq =
  /** The address and key ID fields declare the account key that generated the signature */
  | 'addresses'
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type BitqueryFlowTransactionUniq =
  /** Unique Number of collection */
  | 'collection_id'
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** The account paying for the transaction fees */
  | 'payers'
  /** The account that specifies a proposal key */
  | 'proposers'
  /** Reference block hash */
  | 'reference_block_id'
  /** Unique time */
  | 'times'
  /** Transaction ID */
  | 'tx_id'
  /** Transaction index inside collection */
  | 'tx_index_in_collection';

export type BitqueryFlowTransferReasonEnum =
  /** Fee paid */
  | 'fee'
  /** Currency transfer */
  | 'fungible_token_transfer'
  /** NFT Transfer */
  | 'nft_transfer';

/** Select by transfer reason */
export type BitqueryFlowTransferReasonSelector = {
  /** Reason in the list */
  in?: InputMaybe<Array<BitqueryFlowTransferReasonEnum>>;
  /** Reason is */
  is?: InputMaybe<BitqueryFlowTransferReasonEnum>;
  /** Reason not */
  not?: InputMaybe<BitqueryFlowTransferReasonEnum>;
  /** Reason not in the list */
  notIn?: InputMaybe<Array<BitqueryFlowTransferReasonEnum>>;
};

/** Select transactions by group */
export type BitqueryGroupSelector = {
  /** Transaction group in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Transaction group is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Transaction group not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Transaction group not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Harmony Chain */
export type BitqueryHarmony = {
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<BitqueryHarmonyArguments>>;
  /** Harmony Blocks */
  blocks?: Maybe<Array<BitqueryHarmonyBlocks>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryHarmonySmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryHarmonySmartContractEvents>>;
  /** Harmony Staking Transactions */
  stakingTransactions?: Maybe<Array<BitqueryHarmonyStakingTransactions>>;
  /** Harmony Transactions */
  transactions?: Maybe<Array<BitqueryHarmonyTransactions>>;
  /** Harmony Transfers */
  transfers?: Maybe<Array<BitqueryHarmonyTransfers>>;
};


/** Harmony Chain */
export type BitqueryHarmonyArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyArgumentsFilter>>;
  argument?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryHashSelector>;
  smartContractId?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyBlocksArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyBlocksFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonySmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonySmartContractCallsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonySmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonySmartContractEventsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyStakingTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyStakingTransactionsFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  shardId?: InputMaybe<BitqueryBigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyTransactionsFilter>>;
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Harmony Chain */
export type BitqueryHarmonyTransfersArgs = {
  any?: InputMaybe<Array<BitqueryHarmonyTransfersFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryIntIdSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sender?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferFrom?: InputMaybe<BitqueryAddressSelector>;
  transferTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArguments = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Argument Index */
  argIndex?: Maybe<Scalars['String']['output']>;
  /** Argument Type */
  argType?: Maybe<Scalars['String']['output']>;
  /** Argument */
  argument?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Value */
  external?: Maybe<Scalars['Int']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Number */
  number?: Maybe<Scalars['String']['output']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']['output']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Signature ID */
  signatureId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Address of the smart contract */
  smartContractAddress?: Maybe<Scalars['String']['output']>;
  /** Id of the smart contract */
  smartContractId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** To Shard ID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Value */
  value?: Maybe<Scalars['String']['output']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsAnyArgs = {
  of: BitqueryHarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsArgumentArgs = {
  argument?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyArgumentsUniq>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyArgumentsMeasureable>;
  of: BitqueryHarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyArgumentsMeasureable>;
  of: BitqueryHarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsReceiverArgs = {
  receiver?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsSenderArgs = {
  sender?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsSmartContractAddressArgs = {
  smartContractAddress?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryHarmonyArgumentsSmartContractIdArgs = {
  smartContractAddress?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryHarmonyArgumentsFilter = {
  argument?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryHashSelector>;
  smartContractId?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
};

export type BitqueryHarmonyArgumentsMeasureable =
  /** Address */
  | 'address'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Epoch */
  | 'epoch'
  /** Nonce */
  | 'nonce'
  /** Address of  the receive */
  | 'receiver'
  /** Address of the sender */
  | 'sender'
  /** Shard ID */
  | 'shard_id'
  /** Signature */
  | 'signature'
  /** Hash of the signature */
  | 'signature_hash'
  /** Name of the signature */
  | 'signature_name'
  /** Address of the smart contract */
  | 'smart_contract_address'
  /** Id of the smart contract */
  | 'smart_contract_id'
  /** Time */
  | 'time'
  /** TO Shard ID */
  | 'to_shard_id'
  /** TX Index */
  | 'tx_index'
  /** Value */
  | 'value';

export type BitqueryHarmonyArgumentsUniq =
  /** Unique addresses */
  | 'address'
  /** Unique block hash count */
  | 'block_hash'
  /** Unique date count */
  | 'dates'
  /** Unique ledger count */
  | 'ledger'
  /** Unique address of the receiver */
  | 'receiver'
  /** Unique address of the sender */
  | 'sender'
  /** Unique smart contract address */
  | 'smart_contract_address'
  /** Unique time */
  | 'times'
  /** Unique transaction hash */
  | 'txs';

/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocks = {
  any?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['String']['output']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** The “extra data” field of this block */
  extraData?: Maybe<Scalars['String']['output']>;
  gasLimit?: Maybe<Scalars['Float']['output']>;
  gasUsed?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The bloom filter for the logs of the block. null when its pending block */
  logsBloom?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  miner?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Mix Hash */
  mixHash?: Maybe<Scalars['String']['output']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Parent hash */
  parentHash?: Maybe<Scalars['String']['output']>;
  /** Receipts Root */
  receiptsRoot?: Maybe<Scalars['String']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Integer the size of this block in bytes */
  size?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Staking Transaction Count */
  stakingTransactionsCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The root of the final state trie of the block */
  stateRoot?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction Count */
  transactionCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The root of the transaction trie of the block */
  transactionsRoot?: Maybe<Scalars['String']['output']>;
  /** Count of ucles hashes */
  unclesCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** View ID */
  viewId?: Maybe<Scalars['String']['output']>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksAnyArgs = {
  of: BitqueryHarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksGasLimitArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksGasUsedArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyBlocksMeasureable>;
  of: BitqueryHarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksMinerArgs = {
  miner?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyBlocksMeasureable>;
  of: BitqueryHarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksParentHashArgs = {
  parentHash?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksSizeArgs = {
  size?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksStakingTransactionsCountArgs = {
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksUnclesCountArgs = {
  unclesCount?: InputMaybe<BitqueryHashSelector>;
};


/** Blocks in Harmony blockchain */
export type BitqueryHarmonyBlocksViewIdArgs = {
  viewId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyBlocksFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  difficulty?: InputMaybe<BitqueryHashSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  miner?: InputMaybe<BitqueryHashSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  parentHash?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  size?: InputMaybe<BitqueryBigIntegerSelector>;
  stakingTransactionsCount?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionCount?: InputMaybe<BitqueryHashSelector>;
  unclesCount?: InputMaybe<BitqueryHashSelector>;
  viewId?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyBlocksMeasureable =
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Gas limit */
  | 'gas_limit'
  /** Gas Used */
  | 'gas_used'
  /** Parent hash */
  | 'paret_hash'
  /** Time */
  | 'time'
  /** Transaction Count */
  | 'transaction_count';

export type BitqueryHarmonyBlocksUniq =
  /** Unique block hash count */
  | 'block_hash'
  /** Unique date count */
  | 'dates'
  /** Unique ledger count */
  | 'ledger'
  /** Unique miner count */
  | 'miner'
  /** Unique mix hash count */
  | 'mix_hash'
  /** Unique parent hash count */
  | 'parent_hash'
  /** Unique receipts root count */
  | 'receipts_root'
  /** Unique state root count */
  | 'state_root'
  /** Unique time */
  | 'times'
  /** Unique transactions root count */
  | 'transactions_root';

export type BitqueryHarmonyEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Nonce */
  | 'nonce'
  /** Shard ID */
  | 'shard_id'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** To Shard ID */
  | 'to_shard_id'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Index */
  | 'tx_index'
  /** Action To */
  | 'tx_to';

export type BitqueryHarmonyNetwork =
  /** Harmony Mainnat */
  | 'harmony'
  /** Harmony Testnet */
  | 'harmony_testnet';

/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCalls = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callPath?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Gas unit price */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Tx index */
  txIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction Sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsAnyArgs = {
  of: BitqueryHarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryHarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryHarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsGasPriceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonySmartContractCallsMeasureable>;
  of: BitqueryHarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonySmartContractCallsMeasureable>;
  of: BitqueryHarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsNonceArgs = {
  nonce?: InputMaybe<BitqueryIntegerSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxSenderArgs = {
  txSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryHarmonySmartContractCallsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryHarmonySmartContractCallsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryHarmonySmartContractCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_path'
  /** Date */
  | 'date'
  /** External */
  | 'external'
  /** Nonce */
  | 'nonce'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Shard ID */
  | 'shard_id'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** To Shard ID */
  | 'to_shard_id'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Index */
  | 'tx_index';

export type BitqueryHarmonySmartContractCallsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique smart contract methods count */
  | 'smart_contract_methods'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** Unique transaction senders */
  | 'tx_from'
  /** Unique transactions senders */
  | 'tx_sender'
  /** Unique callers count */
  | 'tx_to'
  /** Unique transactions count */
  | 'txs';

/** Smart Contract Events */
export type BitqueryHarmonySmartContractEvents = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Transaction hash where transfer happened */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Smart contract address */
  smartContractAddress?: Maybe<BitqueryAddress>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Tx index */
  txIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsAnyArgs = {
  of: BitqueryHarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsCountArgs = {
  uniq?: InputMaybe<BitquerySmartContractEventsUniq>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySmartContractEventsUniq>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsEpochArgs = {
  epoch?: InputMaybe<BitqueryIntegerSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyEventsMeasureable>;
  of: BitqueryHarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyEventsMeasureable>;
  of: BitqueryHarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsNonceArgs = {
  nonce?: InputMaybe<BitqueryIntegerSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Events */
export type BitqueryHarmonySmartContractEventsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryHarmonySmartContractEventsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryBigIntegerSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Delegator Address */
  delegatorAddress?: Maybe<Scalars['String']['output']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']['output']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']['output']>;
  /** Validator Address */
  validatorAddress?: Maybe<Scalars['String']['output']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']['output']>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsAnyArgs = {
  of: BitqueryHarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsDelegatorAddressArgs = {
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyStakingTransactionsMeasureable>;
  of: BitqueryHarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyStakingTransactionsMeasureable>;
  of: BitqueryHarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsStatusArgs = {
  status?: InputMaybe<Scalars['Boolean']['input']>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsTransactionTypeArgs = {
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type BitqueryHarmonyStakingTransactionsValidatorAddressArgs = {
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyStakingTransactionsFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  delegatorAddress?: InputMaybe<BitqueryHashSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  nonce?: InputMaybe<BitqueryBigIntIdSelector>;
  shardId?: InputMaybe<BitqueryBigIntIdSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionType?: InputMaybe<BitqueryStakingTransactionsTypeSelector>;
  validatorAddress?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyStakingTransactionsMeasureable =
  /** Date */
  | 'date'
  /** Deligator Address */
  | 'deligator_address'
  /** Gas provided by the sender */
  | 'gas'
  /** Gas price provided by the sender */
  | 'gasPrice'
  /** Gas price provided by the sender */
  | 'gas_price'
  /** Time */
  | 'time'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Validator Address */
  | 'validator_address'
  /** Value transferred in ATTO */
  | 'value';

export type BitqueryHarmonyStakingTransactionsUniq =
  /** Unique date count */
  | 'dates'
  /** Unique delegator validator */
  | 'delegator_address'
  /** Unique block */
  | 'ledger'
  /** Unique smart contract addresses */
  | 'smart_contract_address'
  /** Unique time */
  | 'times'
  /** Unique transaction hash */
  | 'txs'
  /** Unique address validator */
  | 'validator_address';

/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction creates */
  creates?: Maybe<Scalars['String']['output']>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Float']['output']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']['output']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']['output']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** ToShardID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']['output']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']['output']>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsAnyArgs = {
  of: BitqueryHarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsCreatesArgs = {
  creates?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransactionsMeasureable>;
  of: BitqueryHarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransactionsMeasureable>;
  of: BitqueryHarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsReceiverArgs = {
  receiver?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsSenderArgs = {
  sender?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsStatusArgs = {
  status?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Harmony blockchain */
export type BitqueryHarmonyTransactionsTransactionIndexArgs = {
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyTransactionsFilter = {
  creates?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  epoch?: InputMaybe<BitqueryBigIntegerSelector>;
  ledger?: InputMaybe<BitqueryBigIntIdSelector>;
  nonce?: InputMaybe<BitqueryBigIntegerSelector>;
  receiver?: InputMaybe<BitqueryHashSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  shardId?: InputMaybe<BitqueryBigIntegerSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  toShardId?: InputMaybe<BitqueryBigIntegerSelector>;
  transactionHash?: InputMaybe<BitqueryStringSelector>;
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyTransactionsMeasureable =
  /** Date */
  | 'date'
  /** Gas provided by the sender */
  | 'gas'
  /** Gas price provided by the sender */
  | 'gasPrice'
  /** Gas value provided by the sender */
  | 'gasValue'
  /** Gas price provided by the sender */
  | 'gas_price'
  /** Deligator Address */
  | 'receiver'
  /** Validator Address */
  | 'sender'
  /** Shard ID */
  | 'shardId'
  /** Status */
  | 'status'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** To Shard ID */
  | 'toShardId'
  /** Transaction Hash */
  | 'transactionHash'
  /** Transaction Index */
  | 'transactionIndex'
  /** Value transferred in ATTO */
  | 'value';

export type BitqueryHarmonyTransactionsUniq =
  /** Unique date count */
  | 'dates'
  /** Unique block */
  | 'ledger'
  /** Unique receiver */
  | 'receiver'
  /** Unique sender */
  | 'sender'
  /** Unique time */
  | 'times';

/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfers = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Data */
  data?: Maybe<Scalars['String']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entityId?: Maybe<Scalars['Int']['output']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']['output']>;
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Staking Tx Type */
  stakingTxType?: Maybe<Scalars['String']['output']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']['output']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** TO Shard ID */
  toShardId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']['output']>;
  /** Address of the payer */
  transferFrom?: Maybe<BitqueryAddress>;
  /** Address of the receiver */
  transferTo?: Maybe<BitqueryAddress>;
  /** Address of transaction sender */
  txSender?: Maybe<Scalars['String']['output']>;
  /** Address of transaction receiver */
  txTo?: Maybe<Scalars['String']['output']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']['output']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersAnyArgs = {
  of: BitqueryHarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersCountArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersCurrencyArgs = {
  currency?: InputMaybe<BitqueryCurrencySelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersGasValueArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferFrom?: InputMaybe<BitqueryAddressSelector>;
  transferTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersLedgerArgs = {
  ledger?: InputMaybe<BitqueryBlockSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransfersMeasureable>;
  of: BitqueryHarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryHarmonyTransfersMeasureable>;
  of: BitqueryHarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersStatusArgs = {
  status?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransactionIndexArgs = {
  transactionIndex?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransferFromArgs = {
  transferFrom?: InputMaybe<BitqueryHashSelector>;
};


/** Transfers in Harmony blockchain */
export type BitqueryHarmonyTransfersTransferToArgs = {
  transferTo?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHarmonyTransfersFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryIntIdSelector>;
  ledger?: InputMaybe<BitqueryBlockSelector>;
  sender?: InputMaybe<BitqueryHashSelector>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferFrom?: InputMaybe<BitqueryAddressSelector>;
  transferTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryHarmonyTransfersMeasureable =
  /** Block Hash */
  | 'block_hash'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Tx To */
  | 'entity_id'
  /** Gas provided by the sender */
  | 'gas'
  /** Gas price provided by the sender */
  | 'gas_price'
  /** Gas value provided by the sender */
  | 'gas_value'
  /** Block */
  | 'ledger'
  /** Validator Address */
  | 'sender'
  /** Staking Tx Type */
  | 'staking_tx_type'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token type */
  | 'token_type'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Token From */
  | 'transfer_from'
  /** Token To */
  | 'transfer_to'
  /** Tx Sender */
  | 'tx_sender'
  /** Tx To */
  | 'tx_to'
  /** Value transferred in ATTO */
  | 'value';

export type BitqueryHarmonyTransfersUniq =
  /** Unique date count */
  | 'dates'
  /** Unique block */
  | 'ledger'
  /** Unique sender */
  | 'sender'
  /** Unique time */
  | 'times'
  /** Unique transfer from */
  | 'transfer_from'
  /** Unique transfer to */
  | 'transfer_to'
  /** Unique transaction hash */
  | 'txs';

/** Select by hash */
export type BitqueryHashSelector = {
  /** Hash in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Hash is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Hash not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Hash not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Hedera Chain */
export type BitqueryHedera = {
  /** Basic information about address */
  address: Array<BitqueryHederaAddressInfoWithBalance>;
  /** Blockchain Arguments */
  arguments?: Maybe<Array<BitqueryHederaArgument>>;
  /** Blockhain Calls */
  calls?: Maybe<Array<BitqueryHederaCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryHederaCoinpath>>;
  /** Blockhain Inputs */
  inputs?: Maybe<Array<BitqueryHederaInput>>;
  /** Blockhain Messages */
  messages?: Maybe<Array<BitqueryHederaMessage>>;
  /** Blockchain Outputs */
  outputs?: Maybe<Array<BitqueryHederaOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryHederaTransaction>>;
};


/** Hedera Chain */
export type BitqueryHederaAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Hedera Chain */
export type BitqueryHederaArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryHederaArgumentFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Hedera Chain */
export type BitqueryHederaCallsArgs = {
  any?: InputMaybe<Array<BitqueryHederaCallFilter>>;
  callInput?: InputMaybe<BitqueryHashSelector>;
  callResult?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Hedera Chain */
export type BitqueryHederaCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Hedera Chain */
export type BitqueryHederaInputsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryHederaInputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Hedera Chain */
export type BitqueryHederaMessagesArgs = {
  any?: InputMaybe<Array<BitqueryHederaMessageFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Hedera Chain */
export type BitqueryHederaOutputsArgs = {
  any?: InputMaybe<Array<BitqueryHederaOutputFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Hedera Chain */
export type BitqueryHederaTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryHederaTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

/** Address detailed information for Hedera network */
export type BitqueryHederaAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Native currency balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token balances */
  tokenBalances?: Maybe<Array<BitqueryHederaBalance>>;
};


/** Address detailed information for Hedera network */
export type BitqueryHederaAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Arguments in Hedera blockchain */
export type BitqueryHederaArgument = {
  any?: Maybe<Scalars['String']['output']>;
  /** Argument type */
  argtype?: Maybe<Scalars['String']['output']>;
  /** Argument */
  argument?: Maybe<Scalars['String']['output']>;
  chargedTxFee?: Maybe<Scalars['BitqueryBigInt']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<BitqueryAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionBytes?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
  /** Value */
  value?: Maybe<Scalars['String']['output']>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentAnyArgs = {
  of: BitqueryHederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentCountArgs = {
  uniq?: InputMaybe<BitqueryHederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryHederaArgumentsMeasureable>;
  of: BitqueryHederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryHederaArgumentsMeasureable>;
  of: BitqueryHederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Arguments in Hedera blockchain */
export type BitqueryHederaArgumentValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaArgumentFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHederaArgumentsMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type BitqueryHederaArgumentsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique node account */
  | 'smart_contract_entity'
  /** Unique time */
  | 'times'
  /** Unique transaction hash */
  | 'txs';

/** Token Balance */
export type BitqueryHederaBalance = {
  /** Staking Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token ID */
  tokenId?: Maybe<Scalars['String']['output']>;
};

/** Calls in Hedera blockchain */
export type BitqueryHederaCall = {
  any?: Maybe<Scalars['String']['output']>;
  /** Call input */
  callInput?: Maybe<Scalars['String']['output']>;
  /** Call input */
  callResult?: Maybe<Scalars['String']['output']>;
  chargedTxFee?: Maybe<Scalars['BitqueryBigInt']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  gas?: Maybe<Scalars['Int']['output']>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<BitqueryAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionBytes?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallAnyArgs = {
  of: BitqueryHederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCallInputArgs = {
  callInput?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCallResultArgs = {
  callResult?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCountArgs = {
  uniq?: InputMaybe<BitqueryHederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callInput?: InputMaybe<BitqueryHashSelector>;
  callResult?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallMaximumArgs = {
  get?: InputMaybe<BitqueryHederaCallsMeasureable>;
  of: BitqueryHederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallMinimumArgs = {
  get?: InputMaybe<BitqueryHederaCallsMeasureable>;
  of: BitqueryHederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Calls in Hedera blockchain */
export type BitqueryHederaCallValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaCallFilter = {
  callInput?: InputMaybe<BitqueryHashSelector>;
  callResult?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  smartContractEntity?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHederaCallsMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type BitqueryHederaCallsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique node account */
  | 'smart_contract_entity'
  /** Unique time */
  | 'times'
  /** Unique transaction hash */
  | 'txs';

/** Coinpath */
export type BitqueryHederaCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<BitqueryCoinpathEntry>>;
};


/** Coinpath */
export type BitqueryHederaCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryHederaCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryHederaCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryHederaCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Currency selector in Hedera blockchain. */
export type BitqueryHederaCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Inputs in Hedera blockchain */
export type BitqueryHederaInput = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar time */
  time?: Maybe<BitqueryDateTime>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  /** Transfer Account */
  transferEntity?: Maybe<BitqueryAccount>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputAnyArgs = {
  of: BitqueryHederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputCountArgs = {
  uniq?: InputMaybe<BitqueryHederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputCurrencyArgs = {
  currency?: InputMaybe<BitqueryHederaCurrencySelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputInitialBalanceArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputMaxFeeArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputMaximumArgs = {
  get?: InputMaybe<BitqueryHederaInputMeasureable>;
  of: BitqueryHederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputMinimumArgs = {
  get?: InputMaybe<BitqueryHederaInputMeasureable>;
  of: BitqueryHederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputTransactionFeeArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Inputs in Hedera blockchain */
export type BitqueryHederaInputValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaInputFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryHederaInputMeasureable =
  /** Amount */
  | 'amount'
  /** Currency Address */
  | 'currency_address'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type BitqueryHederaInputsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times'
  /** Unique transaction hash */
  | 'txs';

/** Messages in Hedera blockchain */
export type BitqueryHederaMessage = {
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar date time */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction running hash */
  topicRunningHash?: Maybe<Scalars['String']['output']>;
  /** Transaction running hash */
  topicSequenceNumber?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageAnyArgs = {
  of: BitqueryHederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageCountArgs = {
  uniq?: InputMaybe<BitqueryHederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageMaximumArgs = {
  get?: InputMaybe<BitqueryHederaMessageMeasureable>;
  of: BitqueryHederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageMinimumArgs = {
  get?: InputMaybe<BitqueryHederaMessageMeasureable>;
  of: BitqueryHederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTopicRunningHashArgs = {
  topicRunningHash?: InputMaybe<BitqueryStringSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTopicSequenceNumberArgs = {
  topicSequenceNumber?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Messages in Hedera blockchain */
export type BitqueryHederaMessageValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaMessageFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionRunningHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHederaMessageMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type BitqueryHederaMessagesUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times'
  /** Unique transaction hash */
  | 'txs';

export type BitqueryHederaNetwork =
  /** The Hedera mainnet */
  | 'hedera'
  /** The Hedera testnets */
  | 'hedera_testnets';

/** Outputs in Hedera blockchain */
export type BitqueryHederaOutput = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar time */
  time?: Maybe<BitqueryDateTime>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  /** Transfer Account */
  transferEntity?: Maybe<BitqueryAccount>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputAnyArgs = {
  of: BitqueryHederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputCountArgs = {
  uniq?: InputMaybe<BitqueryHederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputCurrencyArgs = {
  currency?: InputMaybe<BitqueryHederaCurrencySelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputMaximumArgs = {
  get?: InputMaybe<BitqueryHederaOutputMeasureable>;
  of: BitqueryHederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputMinimumArgs = {
  get?: InputMaybe<BitqueryHederaOutputMeasureable>;
  of: BitqueryHederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Outputs in Hedera blockchain */
export type BitqueryHederaOutputValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaOutputFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transferEntity?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryHederaOutputMeasureable =
  /** Amount */
  | 'amount'
  /** Currency Address */
  | 'currency_address'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type BitqueryHederaOutputUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times'
  /** Unique Transfer entity */
  | 'transfer_entity'
  /** Unique transaction hash */
  | 'txs';

/** Transactions in Hedera blockchain */
export type BitqueryHederaTransaction = {
  any?: Maybe<Scalars['String']['output']>;
  consensusTimestamp?: Maybe<BitqueryTimestamp>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Entity */
  entity?: Maybe<BitqueryEntity>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Currency of transfer */
  feeCurrency?: Maybe<BitqueryCurrency>;
  initialBalance?: Maybe<Scalars['Float']['output']>;
  maxFee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  memo?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /**
   * Used to reference a specific
   *       account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<BitqueryAccount>;
  /**
   * Used to
   *       reference a specific account in transactions
   */
  payerAccount?: Maybe<BitqueryAccount>;
  /** Transaction result */
  result?: Maybe<BitqueryTransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Calendar time */
  time?: Maybe<BitqueryDateTime>;
  transactionBytes?: Maybe<Scalars['String']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Type */
  transactionType?: Maybe<Scalars['String']['output']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']['output']>;
  validStart?: Maybe<BitqueryTimestamp>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionAnyArgs = {
  of: BitqueryHederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionCountArgs = {
  uniq?: InputMaybe<BitqueryHederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitqueryHederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionEntityArgs = {
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionInitialBalanceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionMaxFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryHederaTransactionMeasureable>;
  of: BitqueryHederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryHederaTransactionMeasureable>;
  of: BitqueryHederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionResultArgs = {
  result?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionTransactionFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionTransactionHashArgs = {
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transactions in Hedera blockchain */
export type BitqueryHederaTransactionValidStartArgs = {
  nanoseconds?: InputMaybe<Scalars['BitqueryBigInt']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryHederaTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  entityType?: InputMaybe<BitqueryEntityTypeSelector>;
  nodeAccount?: InputMaybe<BitqueryStringSelector>;
  payerAccount?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryHederaTransactionMeasureable =
  /** Date */
  | 'date'
  /** Max Fee */
  | 'max_fee'
  /** Time */
  | 'time'
  /** Charged Fee */
  | 'transaction_fee'
  /** Transaction Hash */
  | 'transaction_hash'
  /** Valid duration */
  | 'valid_duration'
  /** Valid start */
  | 'valid_start';

export type BitqueryHederaTransactionsUniq =
  /** Unique consensus time */
  | 'consensus_times'
  /** Unique date count */
  | 'dates'
  /** Unique entity id */
  | 'entity_id'
  /** Unique entity type */
  | 'entity_type'
  /** Unique initial balance */
  | 'initial_balance'
  /** Unique node account */
  | 'node_account'
  /** Unique payer account */
  | 'payer_account'
  /** Unique time */
  | 'times'
  /** Unique transaction type */
  | 'transaction_type';

/** Input Script Type of UTXO transaction input */
export type BitqueryInputScript = {
  /** Script annotation */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Long script pattern */
  pattern: Scalars['String']['output'];
  /** Short script pattern */
  shortPattern: Scalars['String']['output'];
  /** Simple script pattern */
  simplePattern: Scalars['String']['output'];
  /** Script type */
  type?: Maybe<Scalars['String']['output']>;
};

/** Solana Instruction */
export type BitqueryInstruction = {
  action?: Maybe<BitqueryAction>;
  callPath?: Maybe<Scalars['String']['output']>;
  external?: Maybe<Scalars['Boolean']['output']>;
  program?: Maybe<BitqueryProgram>;
};

/** Solana Instruction */
export type BitqueryInstructionWithExternals = {
  action?: Maybe<BitqueryAction>;
  callPath?: Maybe<Scalars['String']['output']>;
  external?: Maybe<Scalars['Boolean']['output']>;
  externalAction?: Maybe<BitqueryAction>;
  externalProgram?: Maybe<BitqueryProgram>;
  program?: Maybe<BitqueryProgram>;
};

/** Select by ID */
export type BitqueryIntIdSelector = {
  /** ID in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ID greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** ID greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ID is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** ID less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** ID less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** ID not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Select limited upper number */
export type BitqueryIntegerLimitedSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
};

/** Select by number */
export type BitqueryIntegerSelector = {
  /** in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Libra */
export type BitqueryLibra = {
  /** Libra Network Blocks */
  blocks?: Maybe<Array<BitqueryLibraBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryLibraCoinpath>>;
  /** Libra Network Currency Minting */
  mints?: Maybe<Array<BitqueryLibraMints>>;
  /** Libra Network Transactions */
  transactions?: Maybe<Array<BitqueryLibraTransactions>>;
  /** Libra Network Currency Transfers */
  transfers?: Maybe<Array<BitqueryLibraTransfers>>;
};


/** Libra */
export type BitqueryLibraBlocksArgs = {
  any?: InputMaybe<Array<BitqueryLibraBlockFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Libra */
export type BitqueryLibraCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Libra */
export type BitqueryLibraMintsArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryLibraMintFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Libra */
export type BitqueryLibraTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryLibraTransactionFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Libra */
export type BitqueryLibraTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryLibraTransferFilter>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Block */
export type BitqueryLibraBlock = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gasUsed?: Maybe<Scalars['Float']['output']>;
  /** Block round in blockchain */
  height: Scalars['Int']['output'];
  /** Key */
  key?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proposer */
  proposer?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Version of transaction for this block */
  version: Scalars['Int']['output'];
  /** Version hash of transaction for this block */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Block */
export type BitqueryLibraBlockAnyArgs = {
  of: BitqueryLibraBlocksMeasureable;
};


/** Block */
export type BitqueryLibraBlockCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraBlockUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryLibraBlockCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraBlockUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryLibraBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block */
export type BitqueryLibraBlockGasUsedArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block */
export type BitqueryLibraBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block */
export type BitqueryLibraBlockMaximumArgs = {
  get?: InputMaybe<BitqueryLibraBlocksMeasureable>;
  of: BitqueryLibraBlocksMeasureable;
};


/** Block */
export type BitqueryLibraBlockMetadataArgs = {
  metadata?: InputMaybe<BitqueryStringSelector>;
};


/** Block */
export type BitqueryLibraBlockMinimumArgs = {
  get?: InputMaybe<BitqueryLibraBlocksMeasureable>;
  of: BitqueryLibraBlocksMeasureable;
};


/** Block */
export type BitqueryLibraBlockProposerArgs = {
  proposer?: InputMaybe<BitqueryAddressSelector>;
};


/** Block */
export type BitqueryLibraBlockTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Block */
export type BitqueryLibraBlockVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryLibraBlockFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  metadata?: InputMaybe<BitqueryStringSelector>;
  proposer?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryLibraBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Proposer */
  | 'proposer';

export type BitqueryLibraBlocksMeasureable =
  /** Block round */
  | 'block'
  /** Date */
  | 'date'
  /** Gas Used */
  | 'gas_used'
  /** Proposer */
  | 'proposer'
  /** Time */
  | 'time'
  /** Version */
  | 'version';

/** Coinpath */
export type BitqueryLibraCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryLibraTransactionValue>;
};


/** Coinpath */
export type BitqueryLibraCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryLibraCoinpathAnyArgs = {
  of: BitqueryLibraCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryLibraCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryLibraCoinpathMeasureable>;
  of: BitqueryLibraCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryLibraCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryLibraCoinpathMeasureable>;
  of: BitqueryLibraCoinpathMeasureable;
};

export type BitqueryLibraCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'version';

/**
 * Currency selector in Libra blockchain.
 * Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
 * Use name of currency for selection
 */
export type BitqueryLibraCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryLibraMintFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Mints in Libra blockchain */
export type BitqueryLibraMints = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Minter */
  minter?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Mint timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int']['output'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsAnyArgs = {
  of: BitqueryLibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraMintsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  minter?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryLibraMintsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsMaximumArgs = {
  get?: InputMaybe<BitqueryLibraMintsMeasureable>;
  of: BitqueryLibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsMinimumArgs = {
  get?: InputMaybe<BitqueryLibraMintsMeasureable>;
  of: BitqueryLibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsMinterArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Mints in Libra blockchain */
export type BitqueryLibraMintsVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryLibraMintsMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Minter */
  | 'minter'
  /** Time */
  | 'time'
  /** Version */
  | 'version'
  /** Mint version hash */
  | 'version_hash';

export type BitqueryLibraMintsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique minters */
  | 'minters'
  /** Unique versions */
  | 'versions';

export type BitqueryLibraTransactionFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Blockchain transaction with value */
export type BitqueryLibraTransactionValue = {
  /** Transaction value */
  value: Scalars['Float']['output'];
  /** Transaction version */
  version: Scalars['Int']['output'];
};

/** Transactions in Libra blockchain */
export type BitqueryLibraTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Expiration Time */
  expirationTime?: Maybe<BitqueryDateTime>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas unit price */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']['output']>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']['output']>;
  /** Script Type */
  scriptType?: Maybe<BitqueryScriptTypeSelectorSelector>;
  /** Transaction sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int']['output'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsAnyArgs = {
  of: BitqueryLibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryLibraTransactionsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryLibraTransactionsUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasPriceArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsGasValueArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryLibraTransactionsMeasureable>;
  of: BitqueryLibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryLibraTransactionsMeasureable>;
  of: BitqueryLibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsScriptHashArgs = {
  scriptHash?: InputMaybe<BitqueryStringSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsSenderArgs = {
  txSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type BitqueryLibraTransactionsVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryLibraTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Script Hash */
  | 'script_hash'
  /** Time */
  | 'time'
  /** Transaction Sender */
  | 'tx_sender'
  /** Version */
  | 'version';

export type BitqueryLibraTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Unique transaction script hashes */
  | 'scripts'
  /** Unique transaction senders */
  | 'senders'
  /** Unique versions */
  | 'versions';

export type BitqueryLibraTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};

/** Transfers in Libra blockchain */
export type BitqueryLibraTransfers = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Expiration Time */
  expirationTime?: Maybe<BitqueryDateTime>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  gas?: Maybe<Scalars['Int']['output']>;
  /** Currency of gas */
  gasCurrency?: Maybe<BitqueryCurrency>;
  /** Gas price */
  gasPrice: Scalars['Float']['output'];
  gasValue?: Maybe<Scalars['Float']['output']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']['output']>;
  /** Script Type */
  scriptType?: Maybe<BitqueryScriptTypeSelectorSelector>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']['output']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transfer timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction sender */
  txSender?: Maybe<BitqueryAddress>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int']['output'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String']['output'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']['output']>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersAnyArgs = {
  of: BitqueryLibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersCurrencyArgs = {
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersGasArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersGasCurrencyArgs = {
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersGasValueArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  gasCurrency?: InputMaybe<Array<BitqueryLibraCurrencySelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  scriptHash?: InputMaybe<BitqueryStringSelector>;
  scriptType?: InputMaybe<BitqueryScriptTypeSelectorSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txSender?: InputMaybe<BitqueryAddressSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryLibraTransfersMeasureable>;
  of: BitqueryLibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryLibraTransfersMeasureable>;
  of: BitqueryLibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersScriptHashArgs = {
  scriptHash?: InputMaybe<BitqueryStringSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersTxSenderArgs = {
  txSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfers in Libra blockchain */
export type BitqueryLibraTransfersVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryLibraTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Gas used */
  | 'gas'
  /** Gas price */
  | 'gas_price'
  /** Gas value */
  | 'gas_value'
  /** Block */
  | 'height'
  /** Receiver */
  | 'receiver'
  /** Script Hash */
  | 'script_hash'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transfer Sender */
  | 'tx_sender'
  /** Version */
  | 'version'
  /** Version hash */
  | 'version_hash';

/** Limit by definition */
export type BitqueryLimitByOption = {
  /** Take limit for each combination of the field */
  each: Scalars['String']['input'];
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
};

/** Solana Log */
export type BitqueryLog = {
  consumed: Scalars['BitqueryBigInt']['output'];
  instruction: Scalars['String']['output'];
  logs: Scalars['String']['output'];
  result: Scalars['String']['output'];
  totalGas: Scalars['BitqueryBigInt']['output'];
};

/** Blockchain message */
export type BitqueryMessageHash = {
  /** Message hash hex representation */
  messageHash: Scalars['String']['output'];
};

/** Smart contract method */
export type BitqueryMethod = {
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
  /** Signature */
  signature?: Maybe<Scalars['String']['output']>;
  /** Signature Hash */
  signatureHash: Scalars['String']['output'];
};

/** Smart contract method. In selector you can use the name, signature or hex hash */
export type BitqueryMethodSelector = {
  /** Method signature in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Method signature is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Method signature not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Method signature not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Query metric object */
export type BitqueryMetric = {
  /** Metric cost */
  cost: Scalars['Float']['output'];
  /** Metric divider */
  divider: Scalars['BitqueryBigInt']['output'];
  /** Metric maximum */
  max: Scalars['BitqueryBigInt']['output'];
  /** Metric maximum unit */
  maxUnit: Scalars['Float']['output'];
  /** Metric minimum */
  min: Scalars['BitqueryBigInt']['output'];
  /** Metric minimum unit */
  minUnit: Scalars['Float']['output'];
  /** Metric name */
  name: Scalars['String']['output'];
  /** Metric price */
  price: Scalars['Float']['output'];
  /** Metric value */
  value: Scalars['BitqueryBigInt']['output'];
  /** Metric value unit */
  valueUnit: Scalars['Float']['output'];
};

/** Query metrics */
export type BitqueryMetrics = {
  /** Graphql query ID */
  id: Scalars['String']['output'];
  /** Metrics */
  list: Array<BitqueryMetric>;
  /** Points */
  points: Scalars['Float']['output'];
  /** SQL requests count */
  sqlRequestsCount: Scalars['Int']['output'];
};

/** Information about miniblock */
export type BitqueryMiniblockElrond = {
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']['output']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']['output']>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']['output']>;
};

/** Name with an identifier */
export type BitqueryNameWithId = {
  /** ID */
  id?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Name */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryNetwork =
  /** Algorand Mainnet (ALGO) */
  | 'algorand'
  /** Algorand Betanet */
  | 'algorand_betanet'
  /** Algorand Testnet */
  | 'algorand_testnet'
  /** Avalanche C-chain */
  | 'avalanche'
  /** Binance DEX */
  | 'binance'
  /** Bitcoin Cash ( BCH ) */
  | 'bitcash'
  /** Bitcoin ( BTC ) */
  | 'bitcoin'
  /** Bitcoin SV ( BSV ) */
  | 'bitcoinsv'
  /** Binance Smart Chain Mainnet */
  | 'bsc'
  /** Binance Smart Chain Testnet */
  | 'bsc_testnet'
  /** Cardano ( ADA ) */
  | 'cardano'
  /** Celo Alfajores Testnet */
  | 'celo_alfajores'
  /** Celo Baklava Testnet */
  | 'celo_baklava'
  /** Celo Mainnet */
  | 'celo_mainnet'
  /** DEPRECATED. Use celo_mainnet */
  | 'celo_rc1'
  /** Conflux Hydra */
  | 'conflux_hydra'
  /** Conflux Oceanus */
  | 'conflux_oceanus'
  /** Conflux Tethys */
  | 'conflux_tethys'
  /** Cosmos Hub */
  | 'cosmoshub'
  /** Cronos Mainnet */
  | 'cronos'
  /** Crypto.org Mainnet */
  | 'crypto_mainnet'
  /** Crypto.org Croeseid Testnet */
  | 'crypto_testnet'
  /** Dash ( DASH ) */
  | 'dash'
  /** Diem Testnet */
  | 'diem_testnet'
  /** Dogecoin ( DOGE ) */
  | 'dogecoin'
  /** Elrond Mainnet */
  | 'elrond'
  /** EOS Mainnet */
  | 'eos'
  /** Beacon Chain Ethereum 2.0 */
  | 'eth2'
  /** Ethereum Classic */
  | 'ethclassic'
  /** Ethereum Classic ( no reorg from block 10904146) */
  | 'ethclassic_reorg'
  /** Ethereum Mainnet */
  | 'ethereum'
  /** Ethereum PoW */
  | 'ethpow'
  /** Everscale */
  | 'everscale'
  /** Fantom Mainnet */
  | 'fantom'
  /** Filecoin Mainnet */
  | 'filecoin'
  /** Flow Mainnet */
  | 'flow'
  /** Goerli Ethereum Testnet */
  | 'goerli'
  /** Harmony Mainnet */
  | 'harmony'
  /** Harmony Testnet */
  | 'harmony_testnet'
  /** Hedera Hashgraph */
  | 'hedera'
  /** Heimdall (Matic Verification Network) */
  | 'heimdall'
  /** Klaytn Mainnet */
  | 'klaytn'
  /** Libra Testnet */
  | 'libra_testnet'
  /** Litecoin ( LTC ) */
  | 'litecoin'
  /** Matic (Polygon) Mainnet */
  | 'matic'
  /** Medalla Ethereum 2.0 Beacon Testnet */
  | 'medalla'
  /** Moonbeam Mainnet */
  | 'moonbeam'
  /** Ripple XRP Ledger */
  | 'ripple'
  /** Solana Mainnet */
  | 'solana'
  /** Stellar Ledger */
  | 'stellar'
  /** Terra Mainnet */
  | 'terra'
  /** Tezos */
  | 'tezos'
  /** TRON Mainnet */
  | 'tron'
  /** Velas Mainnet */
  | 'velas'
  /** Velas Testnet */
  | 'velas_testnet'
  /** Zcash ( ZEC ) */
  | 'zcash';

/** Blockchain operation */
export type BitqueryOperationIndexed = {
  /** Operation index */
  index: Scalars['Int']['output'];
  /** Operation name */
  name: Scalars['String']['output'];
};

/** Blockchain operation */
export type BitqueryOperationIndexedWithAccount = {
  /** Operation index */
  index: Scalars['Int']['output'];
  /** Operation name */
  name: Scalars['String']['output'];
  /** Operation account */
  sourceAccount: BitqueryAddress;
};

/** Select order by ID */
export type BitqueryOrderIdSelector = {
  /** Order ID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Order ID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Order ID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Order ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Select by order side */
export type BitqueryOrderSideSelector = {
  /** Order Side in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderSide>>;
  /** Order Side is */
  is?: InputMaybe<BitqueryBinanceOrderSide>;
  /** Order Side not */
  not?: InputMaybe<BitqueryBinanceOrderSide>;
  /** Order Side not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderSide>>;
};

/** Select by order status */
export type BitqueryOrderStatusSelector = {
  /** Order Status in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderStatus>>;
  /** Order Status is */
  is?: InputMaybe<BitqueryBinanceOrderStatus>;
  /** Order Status not */
  not?: InputMaybe<BitqueryBinanceOrderStatus>;
  /** Order Status not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderStatus>>;
};

/** Select by order time in force */
export type BitqueryOrderTimeInForceSelector = {
  /** Order TimeInForce in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderTimeInForce>>;
  /** Order TimeInForce is */
  is?: InputMaybe<BitqueryBinanceOrderTimeInForce>;
  /** Order TimeInForce not */
  not?: InputMaybe<BitqueryBinanceOrderTimeInForce>;
  /** Order TimeInForce not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderTimeInForce>>;
};

/** Select by order type */
export type BitqueryOrderTypeSelector = {
  /** Order Type in the list */
  in?: InputMaybe<Array<BitqueryBinanceOrderType>>;
  /** Order Type is */
  is?: InputMaybe<BitqueryBinanceOrderType>;
  /** Order Type not */
  not?: InputMaybe<BitqueryBinanceOrderType>;
  /** Order Type not in the list */
  notIn?: InputMaybe<Array<BitqueryBinanceOrderType>>;
};

/** Select by output index ( o based ) */
export type BitqueryOutputIndexSelector = {
  /** Output index in range */
  between?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Output index greater than */
  gt?: InputMaybe<Scalars['Int']['input']>;
  /** Output index greater or equal than */
  gteq?: InputMaybe<Scalars['Int']['input']>;
  /** Output index in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Output index is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Output index less than */
  lt?: InputMaybe<Scalars['Int']['input']>;
  /** Output index less or equal than */
  lteq?: InputMaybe<Scalars['Int']['input']>;
  /** Output index not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Output index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Output Script Type of UTXO transaction output */
export type BitqueryOutputScript = {
  /** Script annotation */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Long script pattern */
  pattern: Scalars['String']['output'];
  /** Short script pattern */
  short: Scalars['String']['output'];
  /** Simple script pattern */
  simplePattern: Scalars['String']['output'];
  /** Script type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryPriceAggregateFunction =
  /** Any value */
  | 'any'
  /** Last value */
  | 'anyLast'
  /** Average */
  | 'average'
  /** Maximum */
  | 'maximum'
  /** Median */
  | 'median'
  /** Minimum */
  | 'minimum'
  /** Aggregated over interval */
  | 'sum';

/** Solana Program */
export type BitqueryProgram = {
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  parsed: Scalars['Boolean']['output'];
  parsedName: Scalars['String']['output'];
};

export type BitqueryProtocol =
  /** Algorand */
  | 'algorand'
  /** Binance DEX */
  | 'binance'
  /** Bitcoin */
  | 'bitcoin'
  /** Cardano */
  | 'cardano'
  /** Conflux */
  | 'conflux'
  /** Cosmos */
  | 'cosmos'
  /** Elrond */
  | 'elrond'
  /** EOS */
  | 'eos'
  /** Ethereum */
  | 'ethereum'
  /** Everscale */
  | 'everscale'
  /** Filecoin */
  | 'filecoin'
  /** Flow */
  | 'flow'
  /** Harmony */
  | 'harmony'
  /** Hedera Hashgraph */
  | 'hedera'
  /** Libra */
  | 'libra'
  /** Ripple XRP Ledger */
  | 'ripple'
  /** Solana */
  | 'solana'
  /** Stellar Ledger */
  | 'stellar'
  /** Tezos */
  | 'tezos'
  /** Tron */
  | 'tron';

/** Blockchain Unified GraphQL API */
export type BitqueryQuery = {
  /** Algorand Chains Dataset */
  algorand?: Maybe<BitqueryAlgorand>;
  /** Binance DEX Chain Dataset */
  binance?: Maybe<BitqueryBinance>;
  /** Bitcoin and other UTXO Chains Dataset */
  bitcoin?: Maybe<BitqueryBitcoin>;
  /** Cardano Chain Dataset */
  cardano?: Maybe<BitqueryCardano>;
  /** Conflux Chains Dataset */
  conflux?: Maybe<BitqueryConflux>;
  /** Cosmos Dataset */
  cosmos?: Maybe<BitqueryCosmos>;
  /** Diem ( former Libra ) Testnet Dataset */
  diem?: Maybe<BitqueryLibra>;
  /** Elrond Dataset */
  elrond?: Maybe<BitqueryElrond>;
  /** EOS Mainnet Dataset */
  eos?: Maybe<BitqueryEos>;
  /** Ethereum Mainnet / Classic Chain Datasets */
  ethereum?: Maybe<BitqueryEthereum>;
  /** Ethereum v2.0 Beacon Chain Datasets */
  ethereum2?: Maybe<BitqueryEthereum2>;
  /** Everscale Dataset */
  everscale?: Maybe<BitqueryEverscale>;
  /** Filecoin Dataset */
  filecoin?: Maybe<BitqueryFilecoin>;
  /** Flow Dataset */
  flow?: Maybe<BitqueryFlow>;
  /** Harmony Dataset */
  harmony?: Maybe<BitqueryHarmony>;
  /** Hedera Dataset */
  hedera?: Maybe<BitqueryHedera>;
  /**
   * Query metrics
   * @deprecated DEPRECATED! Please use utilities { metrics }
   */
  metrics?: Maybe<BitqueryMetrics>;
  /** Ripple Dataset */
  ripple?: Maybe<BitqueryRipple>;
  /** Search by query string */
  search?: Maybe<Array<BitqueryResult>>;
  /** Solana Dataset */
  solana?: Maybe<BitquerySolana>;
  /** Stellar Dataset */
  stellar?: Maybe<BitqueryStellar>;
  /** Tezos Dataset */
  tezos?: Maybe<BitqueryTezos>;
  /** Tron Mainnet Dataset */
  tron?: Maybe<BitqueryTron>;
  /** Utilities */
  utilities?: Maybe<BitqueryUtilities>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryAlgorandArgs = {
  network?: InputMaybe<BitqueryAlgorandNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryBitcoinArgs = {
  network?: InputMaybe<BitqueryBitcoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryCardanoArgs = {
  network?: InputMaybe<BitqueryCardanoNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryConfluxArgs = {
  network?: InputMaybe<BitqueryConfluxNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryCosmosArgs = {
  network?: InputMaybe<BitqueryCosmosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryDiemArgs = {
  network?: InputMaybe<BitqueryDiemNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryElrondArgs = {
  network?: InputMaybe<BitqueryElrondNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEosArgs = {
  network?: InputMaybe<BitqueryEosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEthereumArgs = {
  network?: InputMaybe<BitqueryEthereumNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEthereum2Args = {
  network?: InputMaybe<BitqueryEthereum2Network>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryEverscaleArgs = {
  network?: InputMaybe<BitqueryEverscaleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryFilecoinArgs = {
  network?: InputMaybe<BitqueryFilecoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryFlowArgs = {
  network?: InputMaybe<BitqueryFlowNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryHarmonyArgs = {
  network?: InputMaybe<BitqueryHarmonyNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryHederaArgs = {
  network?: InputMaybe<BitqueryHederaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryMetricsArgs = {
  options?: InputMaybe<BitquerySeedOptions>;
  queryId: Scalars['String']['input'];
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryRippleArgs = {
  network?: InputMaybe<BitqueryRippleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQuerySearchArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  network?: InputMaybe<BitqueryNetwork>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  string: Scalars['String']['input'];
};


/** Blockchain Unified GraphQL API */
export type BitqueryQuerySolanaArgs = {
  network?: InputMaybe<BitquerySolanaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryStellarArgs = {
  network?: InputMaybe<BitqueryStellarNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryTezosArgs = {
  network?: InputMaybe<BitqueryTezosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type BitqueryQueryTronArgs = {
  network?: InputMaybe<BitqueryTronNetwork>;
};

/** Limits, Ordering, Constraints */
export type BitqueryQueryOptions = {
  /** Ordering field(s) for ascending */
  asc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for ascending */
  ascByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Ordering field(s) for descending */
  desc?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Converting field(s) to integer datatype and then ordering field(s) for descending */
  descByInteger?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Limit number of results */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** Limit number of results by specific field */
  limitBy?: InputMaybe<BitqueryLimitByOption>;
  /** Offset of results, starting from 0 */
  offset?: InputMaybe<Scalars['Int']['input']>;
};

/** Solana Receiver */
export type BitqueryReceiver = {
  address: Scalars['String']['output'];
  mintAccount: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** Search result item */
export type BitqueryResult = {
  /** Blockchain where result is found */
  network: BitqueryBlockchainNetwork;
  /** Subject in blockchain */
  subject: BitquerySubject;
};

/** Select by reward type */
export type BitqueryRewardTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitquerySolanaRewardType>>;
  /** Type is */
  is?: InputMaybe<BitquerySolanaRewardType>;
  /** Type not */
  not?: InputMaybe<BitquerySolanaRewardType>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitquerySolanaRewardType>>;
};

/** Ripple Chain */
export type BitqueryRipple = {
  /** Ripple Account Roots */
  accountRoots?: Maybe<Array<BitqueryRippleAccountRoot>>;
  /** Basic information about address */
  address: Array<BitqueryRippleAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryRippleAddressStats>>;
  /** Ripple Balances */
  balances?: Maybe<Array<BitqueryRippleBalance>>;
  /** Ripple Blocks */
  blocks?: Maybe<Array<BitqueryRippleBlock>>;
  /** Ripple Checks */
  checks?: Maybe<Array<BitqueryRippleCheck>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryRippleCoinpath>>;
  /** Ripple Escrows */
  escrows?: Maybe<Array<BitqueryRippleEscrow>>;
  /** Ripple NFTokenOffers */
  nftokenOffers?: Maybe<Array<BitqueryRippleNfTokenOffer>>;
  /** Ripple Offers */
  offers?: Maybe<Array<BitqueryRippleOffer>>;
  /** Ripple Payments */
  payments?: Maybe<Array<BitqueryRipplePayment>>;
  /** Ripple Ripple States */
  rippleStates?: Maybe<Array<BitqueryRippleRippleState>>;
  /** Ripple Transactions */
  transactions?: Maybe<Array<BitqueryRippleTransaction>>;
  /** Ripple Transfers */
  transfers?: Maybe<Array<BitqueryRippleTransfer>>;
};


/** Ripple Chain */
export type BitqueryRippleAccountRootsArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleAccountRootFilter>>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Ripple Chain */
export type BitqueryRippleAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Ripple Chain */
export type BitqueryRippleAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Ripple Chain */
export type BitqueryRippleBalancesArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleBalanceFilter>>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleBlocksArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  any?: InputMaybe<Array<BitqueryRippleBlockFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};


/** Ripple Chain */
export type BitqueryRippleChecksArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleCheckFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currencyFrom?: InputMaybe<BitqueryCurrencySelector>;
  currencyTo?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Ripple Chain */
export type BitqueryRippleEscrowsArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryRippleEscrowFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleNftokenOffersArgs = {
  any?: InputMaybe<Array<BitqueryRippleNftokenOfferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationAccount?: InputMaybe<BitqueryAddressSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  fromAccount?: InputMaybe<BitqueryAddressSelector>;
  mount?: InputMaybe<BitqueryFloatSelector>;
  nftokenAmount?: InputMaybe<BitqueryFloatSelector>;
  nftokenCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleOffersArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleOfferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRipplePaymentsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRipplePaymentFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Ripple Chain */
export type BitqueryRippleRippleStatesArgs = {
  any?: InputMaybe<Array<BitqueryRippleRippleStateFilter>>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleTransactionsArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryRippleTransactionFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple Chain */
export type BitqueryRippleTransfersArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryRippleTransferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRoot = {
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Domain */
  domain?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  ownerCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  prevBalance?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
  transferRate?: Maybe<Scalars['BitqueryBigInt']['output']>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootAnyArgs = {
  of: BitqueryRippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
  uniq?: InputMaybe<BitqueryRippleAccountRootUniq>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
  uniq?: InputMaybe<BitqueryRippleAccountRootUniq>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootMaximumArgs = {
  get?: InputMaybe<BitqueryRippleAccountRootMeasurable>;
  of: BitqueryRippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootMinimumArgs = {
  get?: InputMaybe<BitqueryRippleAccountRootMeasurable>;
  of: BitqueryRippleAccountRootMeasurable;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootOwnerCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootPrevBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};


/** Account root in Ripple blockchain */
export type BitqueryRippleAccountRootTransferRateArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryRippleAccountRootFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  domain?: InputMaybe<BitqueryStringSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  ownerCount?: InputMaybe<BitqueryBigIntIdSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  transferRate?: InputMaybe<BitqueryBigIntIdSelector>;
};

export type BitqueryRippleAccountRootMeasurable =
  /** Account */
  | 'account'
  /** Balance */
  | 'balance'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Domain */
  | 'domain'
  /** Flags */
  | 'flags'
  /** Operation */
  | 'operation'
  /** Owner count */
  | 'ownerCount'
  /** Prev balance */
  | 'prevBalance'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Sequence */
  | 'sequence'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType'
  /** Transfer rate */
  | 'transferRate';

export type BitqueryRippleAccountRootUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq domains count */
  | 'domains'
  /** Uniq flags count */
  | 'flags'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Address detailed information for Ripple network */
export type BitqueryRippleAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** XRP balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token Balances */
  tokenBalances?: Maybe<Array<BitqueryRippleTokenBalances>>;
};


/** Address detailed information for Ripple network */
export type BitqueryRippleAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type BitqueryRippleAddressStat = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStat */
export type BitqueryRippleAddressStats = {
  /** Address With Statistics */
  address?: Maybe<BitqueryRippleAddressStat>;
};

/** Balance in Ripple blockchain */
export type BitqueryRippleBalance = {
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['Float']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  prevBalance?: Maybe<Scalars['Float']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceAnyArgs = {
  of: BitqueryRippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleBalanceUniq>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleBalanceUniq>;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceMaximumArgs = {
  get?: InputMaybe<BitqueryRippleBalanceMeasurable>;
  of: BitqueryRippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalanceMinimumArgs = {
  get?: InputMaybe<BitqueryRippleBalanceMeasurable>;
  of: BitqueryRippleBalanceMeasurable;
};


/** Balance in Ripple blockchain */
export type BitqueryRippleBalancePrevBalanceArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleBalanceFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleBalanceMeasurable =
  /** Account */
  | 'account'
  /** Balance */
  | 'balance'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Flags */
  | 'flags'
  /** Issuer */
  | 'issuer'
  /** Operation */
  | 'operation'
  /** Prev balance */
  | 'prevBalance'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type BitqueryRippleBalanceUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq flags count */
  | 'flags'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Block in Ripple blockchain */
export type BitqueryRippleBlock = {
  /** Account hash */
  accountHash?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalCoins?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']['output']>;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockAnyArgs = {
  of: BitqueryRippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockCountArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryRippleBlockUniq>;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockCountBigIntArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryRippleBlockUniq>;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockMaximumArgs = {
  get?: InputMaybe<BitqueryRippleBlockMeasurable>;
  of: BitqueryRippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockMinimumArgs = {
  get?: InputMaybe<BitqueryRippleBlockMeasurable>;
  of: BitqueryRippleBlockMeasurable;
};


/** Block in Ripple blockchain */
export type BitqueryRippleBlockTotalCoinsArgs = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryRippleBlockFilter = {
  accountHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryRippleBlockMeasurable =
  /** Account hash */
  | 'accountHash'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Hash */
  | 'hash'
  /** Time */
  | 'time'
  /** Total coins */
  | 'totalCoins'
  /** Transaction hash */
  | 'transactionHash';

export type BitqueryRippleBlockUniq =
  /** Uniq account hashes count */
  | 'accountHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq transaction hashes count */
  | 'transactionHashes';

/** Check in Ripple blockchain */
export type BitqueryRippleCheck = {
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination */
  destination?: Maybe<BitqueryAddress>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Expiration */
  expiration?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Invoice */
  invoiceId?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  sendMax?: Maybe<Scalars['Float']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckAnyArgs = {
  of: BitqueryRippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleCheckUniq>;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleCheckUniq>;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckMaximumArgs = {
  get?: InputMaybe<BitqueryRippleCheckMeasurable>;
  of: BitqueryRippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckMinimumArgs = {
  get?: InputMaybe<BitqueryRippleCheckMeasurable>;
  of: BitqueryRippleCheckMeasurable;
};


/** Check in Ripple blockchain */
export type BitqueryRippleCheckSendMaxArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleCheckFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoiceId?: InputMaybe<BitqueryStringSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sendMax?: InputMaybe<BitqueryFloatSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleCheckMeasurable =
  /** Account */
  | 'account'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Destination */
  | 'destination'
  /** Destination tag */
  | 'destinationTag'
  /** Expiration */
  | 'expiration'
  /** Flags */
  | 'flags'
  /** Invoice */
  | 'invoiceId'
  /** Operation */
  | 'operation'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Send max */
  | 'sendMax'
  /** Sequence */
  | 'sequence'
  /** Source tag */
  | 'sourceTag'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type BitqueryRippleCheckUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq destination tags count */
  | 'destinationTags'
  /** Uniq destinations count */
  | 'destinations'
  /** Uniq expirations count */
  | 'expirations'
  /** Uniq flags count */
  | 'flags'
  /** Uniq invoice ids count */
  | 'invoiceIds'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq source tags count */
  | 'sourceTags'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Ripple Coinpath */
export type BitqueryRippleCoinpath = {
  /** Summary of transfered value from */
  amountFrom?: Maybe<Scalars['Float']['output']>;
  /** Summary of transfered value to */
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency From of transfer */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency To of transfer */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['String']['output']>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryStellarTransactionCoinpathDimension>;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathAmountFromArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathAmountToArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathAnyArgs = {
  of: BitqueryRippleCoinpathMeasureable;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryRippleCoinpathMeasureable>;
  of: BitqueryRippleCoinpathMeasureable;
};


/** Ripple Coinpath */
export type BitqueryRippleCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryRippleCoinpathMeasureable>;
  of: BitqueryRippleCoinpathMeasureable;
};

export type BitqueryRippleCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrow = {
  /** Account */
  account?: Maybe<BitqueryAddress>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Cancel after */
  cancelAfter?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Condition */
  condition?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination */
  destination?: Maybe<BitqueryAddress>;
  /** Destination tag */
  destinationTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Finish after */
  finishAfter?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowAnyArgs = {
  of: BitqueryRippleEscrowMeasurable;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleEscrowUniq>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleEscrowUniq>;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowMaximumArgs = {
  get?: InputMaybe<BitqueryRippleEscrowMeasurable>;
  of: BitqueryRippleEscrowMeasurable;
};


/** Escrow in Ripple blockchain */
export type BitqueryRippleEscrowMinimumArgs = {
  get?: InputMaybe<BitqueryRippleEscrowMeasurable>;
  of: BitqueryRippleEscrowMeasurable;
};

export type BitqueryRippleEscrowFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  cancelAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  condition?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destination?: InputMaybe<BitqueryStringSelector>;
  destinationTag?: InputMaybe<BitqueryBigIntIdSelector>;
  finishAfter?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleEscrowMeasurable =
  /** Account */
  | 'account'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Cancel after */
  | 'cancelAfter'
  /** Condition */
  | 'condition'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Destination */
  | 'destination'
  /** Destination tag */
  | 'destinationTag'
  /** Finish after */
  | 'finishAfter'
  /** Flags */
  | 'flags'
  /** Operation */
  | 'operation'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Source tag */
  | 'sourceTag'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type BitqueryRippleEscrowUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq cancel afters count */
  | 'cancelAfters'
  /** Uniq conditions count */
  | 'conditions'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq destination tags count */
  | 'destinationTags'
  /** Uniq destinations count */
  | 'destinations'
  /** Uniq finish afters count */
  | 'finishAfters'
  /** Uniq flags count */
  | 'flags'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq source tags count */
  | 'sourceTags'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOffer = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Book directory */
  bookDirectory?: Maybe<Scalars['String']['output']>;
  /** Book node */
  bookNode?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Taker pays currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination Account */
  destinationAccount?: Maybe<BitqueryAddress>;
  /** Expiration */
  expiration?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** From Account */
  fromAccount?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  nftokenAmount?: Maybe<Scalars['Float']['output']>;
  /** NFToken Buy Offer */
  nftokenBuyOffer?: Maybe<Scalars['String']['output']>;
  /** Taker gets currency */
  nftokenCurrency?: Maybe<BitqueryCurrency>;
  /** NFToken Sell Offer */
  nftokenSellOffer?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferAnyArgs = {
  of: BitqueryRippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferMaximumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferMinimumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** NFTokenOffer in Ripple blockchain */
export type BitqueryRippleNfTokenOfferNftokenAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleNetwork =
  /** Ripple XRP Ledger */
  | 'ripple';

export type BitqueryRippleNftokenOfferFilter = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationAccount?: InputMaybe<BitqueryAddressSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  fromAccount?: InputMaybe<BitqueryAddressSelector>;
  mount?: InputMaybe<BitqueryFloatSelector>;
  nftokenAmount?: InputMaybe<BitqueryFloatSelector>;
  nftokenCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

/** Offer in Ripple blockchain */
export type BitqueryRippleOffer = {
  /** Account */
  account?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Book directory */
  bookDirectory?: Maybe<Scalars['String']['output']>;
  /** Book node */
  bookNode?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Expiration */
  expiration?: Maybe<Scalars['BitqueryBigInt']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  preTakerGetsAmount?: Maybe<Scalars['Float']['output']>;
  preTakerPaysAmount?: Maybe<Scalars['Float']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  takerGetsAmount?: Maybe<Scalars['Float']['output']>;
  /** Taker gets currency */
  takerGetsCurrency?: Maybe<BitqueryCurrency>;
  takerPaysAmount?: Maybe<Scalars['Float']['output']>;
  /** Taker pays currency */
  takerPaysCurrency?: Maybe<BitqueryCurrency>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferAnyArgs = {
  of: BitqueryRippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferCountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferCountBigIntArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleOfferUniq>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferMaximumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferMinimumArgs = {
  get?: InputMaybe<BitqueryRippleOfferMeasurable>;
  of: BitqueryRippleOfferMeasurable;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferPreTakerGetsAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferPreTakerPaysAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferTakerGetsAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Offer in Ripple blockchain */
export type BitqueryRippleOfferTakerPaysAmountArgs = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleOfferFilter = {
  account?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  bookDirectory?: InputMaybe<BitqueryStringSelector>;
  bookNode?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  expiration?: InputMaybe<BitqueryBigIntIdSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  preTakerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  preTakerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryBigIntIdSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  takerGetsAmount?: InputMaybe<BitqueryFloatSelector>;
  takerGetsCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  takerPaysAmount?: InputMaybe<BitqueryFloatSelector>;
  takerPaysCurrencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleOfferMeasurable =
  /** Account */
  | 'account'
  /** Block */
  | 'block'
  /** Book directory */
  | 'bookDirectory'
  /** Book node */
  | 'bookNode'
  /** Date */
  | 'date'
  /** Expiration */
  | 'expiration'
  /** Flags */
  | 'flags'
  /** Operation */
  | 'operation'
  /** Pre taker gets amount */
  | 'preTakerGetsAmount'
  /** Pre taker pays amount */
  | 'preTakerPaysAmount'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Sequence */
  | 'sequence'
  /** Taker gets amount */
  | 'takerGetsAmount'
  /** Taker gets currency name */
  | 'takerGetsCurrencyName'
  /** Taker gets currency symbol */
  | 'takerGetsCurrencySymbol'
  /** Taker pays amount */
  | 'takerPaysAmount'
  /** Taker pays currency name */
  | 'takerPaysCurrencyName'
  /** Taker pays currency symbol */
  | 'takerPaysCurrencySymbol'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type BitqueryRippleOfferUniq =
  /** Uniq accounts count */
  | 'accounts'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq book directories count */
  | 'bookDirectories'
  /** Uniq book nodes count */
  | 'bookNodes'
  /** Uniq dates count */
  | 'dates'
  /** Uniq expirations count */
  | 'expirations'
  /** Uniq flags count */
  | 'flags'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq taker gets currency names count */
  | 'takerGetsCurrencyNames'
  /** Uniq taker gets currency symbols count */
  | 'takerGetsCurrencySymbols'
  /** Uniq taker pays currency names count */
  | 'takerPaysCurrencyNames'
  /** Uniq taker pays currency symbols count */
  | 'takerPaysCurrencySymbols'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Payment in Ripple blockchain */
export type BitqueryRipplePayment = {
  amount?: Maybe<Scalars['Float']['output']>;
  /** Amount currency */
  amountCurrency?: Maybe<BitqueryCurrency>;
  /** Amount issuer */
  amountIssuer?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  deliverMinAmount?: Maybe<Scalars['Float']['output']>;
  /** Deliver min currency */
  deliverMinCurrency?: Maybe<BitqueryCurrency>;
  /** Deliver min issuer */
  deliverMinIssuer?: Maybe<BitqueryAddress>;
  deliveredAmount?: Maybe<Scalars['Float']['output']>;
  /** Delivered currency */
  deliveredCurrency?: Maybe<BitqueryCurrency>;
  /** Delivered issuer */
  deliveredIssuer?: Maybe<BitqueryAddress>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Invoice */
  invoice?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Partial */
  partial?: Maybe<Scalars['Boolean']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  sendMaxAmount?: Maybe<Scalars['Float']['output']>;
  /** Send max currency */
  sendMaxCurrency?: Maybe<BitqueryCurrency>;
  /** Send max issuer */
  sendMaxIssuer?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Tag */
  tag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionHashIndexDimension>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentAnyArgs = {
  of: BitqueryRipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryRipplePaymentUniq>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryRipplePaymentUniq>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentDeliverMinAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentDeliveredAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentMaximumArgs = {
  get?: InputMaybe<BitqueryRipplePaymentMeasurable>;
  of: BitqueryRipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentMinimumArgs = {
  get?: InputMaybe<BitqueryRipplePaymentMeasurable>;
  of: BitqueryRipplePaymentMeasurable;
};


/** Payment in Ripple blockchain */
export type BitqueryRipplePaymentSendMaxAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryRipplePaymentFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  amountCurrency?: InputMaybe<BitqueryCurrencySelector>;
  amountIssuer?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  deliverMinAmount?: InputMaybe<BitqueryFloatSelector>;
  deliverMinCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliverMinIssuer?: InputMaybe<BitqueryAddressSelector>;
  deliveredAmount?: InputMaybe<BitqueryFloatSelector>;
  deliveredCurrency?: InputMaybe<BitqueryCurrencySelector>;
  deliveredIssuer?: InputMaybe<BitqueryAddressSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  invoice?: InputMaybe<BitqueryStringSelector>;
  partial?: InputMaybe<BitqueryBooleanSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sendMaxAmount?: InputMaybe<BitqueryFloatSelector>;
  sendMaxCurrency?: InputMaybe<BitqueryCurrencySelector>;
  sendMaxIssuer?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  tag?: InputMaybe<BitqueryBigIntIdSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitqueryRipplePaymentMeasurable =
  /** Amount */
  | 'amount'
  /** Amount currency name */
  | 'amountCurrencyName'
  /** Amount currency symbol */
  | 'amountCurrencySymbol'
  /** Amount issuer */
  | 'amountIssuer'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Deliver min amount */
  | 'deliverMinAmount'
  /** Deliver min currency name */
  | 'deliverMinCurrencyName'
  /** Deliver min currency symbol */
  | 'deliverMinCurrencySymbol'
  /** Deliver min issuer */
  | 'deliverMinIssuer'
  /** Delivered amount */
  | 'deliveredAmount'
  /** Delivered currency name */
  | 'deliveredCurrencyName'
  /** Delivered currency symbol */
  | 'deliveredCurrencySymbol'
  /** Delivered issuer */
  | 'deliveredIssuer'
  /** Flags */
  | 'flags'
  /** Invoice */
  | 'invoice'
  /** Partial */
  | 'partial'
  /** Receiver */
  | 'receiver'
  /** Send max amount */
  | 'sendMaxAmount'
  /** Send max currency name */
  | 'sendMaxCurrencyName'
  /** Send max currency symbol */
  | 'sendMaxCurrencySymbol'
  /** Send max issuer */
  | 'sendMaxIssuer'
  /** Sender */
  | 'sender'
  /** Tag */
  | 'tag'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex';

export type BitqueryRipplePaymentUniq =
  /** Uniq amount currency names count */
  | 'amountCurrencyNames'
  /** Uniq amount currency symbols count */
  | 'amountCurrencySymbols'
  /** Uniq amount issuers count */
  | 'amountIssuers'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq deliver min currency names count */
  | 'deliverMinCurrencyNames'
  /** Uniq deliver min currency symbols count */
  | 'deliverMinCurrencySymbols'
  /** Uniq deliver min issuers count */
  | 'deliverMinIssuers'
  /** Uniq delivered currency names count */
  | 'deliveredCurrencyNames'
  /** Uniq delivered currency symbols count */
  | 'deliveredCurrencySymbols'
  /** Uniq delivered issuers count */
  | 'deliveredIssuers'
  /** Uniq flags count */
  | 'flags'
  /** Uniq invoices count */
  | 'invoices'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq send max currency names count */
  | 'sendMaxCurrencyNames'
  /** Uniq send max currency symbols count */
  | 'sendMaxCurrencySymbols'
  /** Uniq send max issuers count */
  | 'sendMaxIssuers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq tags count */
  | 'tags'
  /** Uniq time count */
  | 'time'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices';

/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleState = {
  any?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['Float']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** High account */
  highAccount?: Maybe<BitqueryAddress>;
  /** Low account */
  lowAccount?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  prevBalance?: Maybe<Scalars['Float']['output']>;
  /** Prev ledger sequence */
  prevLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Prev txn */
  prevTxnId?: Maybe<Scalars['String']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateAnyArgs = {
  of: BitqueryRippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateBalanceArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateCountArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleRippleStateUniq>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateCountBigIntArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleRippleStateUniq>;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateMaximumArgs = {
  get?: InputMaybe<BitqueryRippleRippleStateMeasurable>;
  of: BitqueryRippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStateMinimumArgs = {
  get?: InputMaybe<BitqueryRippleRippleStateMeasurable>;
  of: BitqueryRippleRippleStateMeasurable;
};


/** Ripple state in Ripple blockchain */
export type BitqueryRippleRippleStatePrevBalanceArgs = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleRippleStateFilter = {
  balance?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencySymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  highAccount?: InputMaybe<BitqueryAddressSelector>;
  lowAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  prevBalance?: InputMaybe<BitqueryFloatSelector>;
  prevLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  prevTxnId?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleRippleStateMeasurable =
  /** Balance */
  | 'balance'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Flags */
  | 'flags'
  /** High account */
  | 'highAccount'
  /** Low account */
  | 'lowAccount'
  /** Operation */
  | 'operation'
  /** Pre balance */
  | 'prevBalance'
  /** Prev ledger sequence */
  | 'prevLedgerSequence'
  /** Prev txn */
  | 'prevTxnId'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type BitqueryRippleRippleStateUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq flags count */
  | 'flags'
  /** Uniq high accounts count */
  | 'highAccounts'
  /** Uniq low accounts count */
  | 'lowAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq prev ledger sequences count */
  | 'prevLedgerSequences'
  /** Uniq prev txn ids count */
  | 'prevTxnIds'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Token Balance */
export type BitqueryRippleTokenBalances = {
  /** The unique Address of the counterparty to this trust line. */
  account?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Currency */
  currency?: Maybe<Scalars['String']['output']>;
};

/** Transaction in Ripple blockchain */
export type BitqueryRippleTransaction = {
  /** Account txn id */
  accountTxnId?: Maybe<Scalars['String']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Flags */
  flags?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index */
  index?: Maybe<Scalars['Int']['output']>;
  /** Last ledger sequence */
  lastLedgerSequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memos */
  memos?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Result */
  result?: Maybe<Scalars['String']['output']>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Source tag */
  sourceTag?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Tx signers */
  txSigners?: Maybe<Scalars['String']['output']>;
  /** Type */
  type?: Maybe<Scalars['String']['output']>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionAnyArgs = {
  of: BitqueryRippleTransactionMeasurable;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionCountArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransactionUniq>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionCountBigIntArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransactionUniq>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionFeeArgs = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryRippleTransactionMeasurable>;
  of: BitqueryRippleTransactionMeasurable;
};


/** Transaction in Ripple blockchain */
export type BitqueryRippleTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryRippleTransactionMeasurable>;
  of: BitqueryRippleTransactionMeasurable;
};

/** Ripple transaction */
export type BitqueryRippleTransactionDimension = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block */
  index: Scalars['Int']['output'];
  /** Transaction sender */
  sender?: Maybe<Scalars['String']['output']>;
  /** Transaction type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryRippleTransactionFilter = {
  accountTxnId?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  flags?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  lastLedgerSequence?: InputMaybe<BitqueryBigIntIdSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  result?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryBigIntIdSelector>;
  sourceTag?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  type?: InputMaybe<BitqueryStringSelector>;
};

/** Ripple transaction with hash and index */
export type BitqueryRippleTransactionHashIndexDimension = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block */
  index: Scalars['Int']['output'];
};

export type BitqueryRippleTransactionMeasurable =
  /** Account txn id */
  | 'accountTxnId'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee */
  | 'fee'
  /** Flags */
  | 'flags'
  /** Hash */
  | 'hash'
  /** Index */
  | 'index'
  /** Last ledger sequence */
  | 'lastLedgerSequence'
  /** Memos */
  | 'memos'
  /** Result */
  | 'result'
  /** Sender */
  | 'sender'
  /** Sequence */
  | 'sequence'
  /** Source tag */
  | 'sourceTag'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Type */
  | 'type';

export type BitqueryRippleTransactionUniq =
  /** Uniq account txn id bins count */
  | 'accountTxnIds'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq flags count */
  | 'flags'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq indices count */
  | 'indices'
  /** Uniq last ledger sequences count */
  | 'lastLedgerSequences'
  /** Uniq results count */
  | 'results'
  /** Uniq senders count */
  | 'senders'
  /** Uniq sequences count */
  | 'sequences'
  /** Uniq source tags count */
  | 'sourceTags'
  /** Uniq types count */
  | 'types';

/** Transfer in Ripple blockchain */
export type BitqueryRippleTransfer = {
  amountFrom?: Maybe<Scalars['Float']['output']>;
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency from */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency to */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryRippleTransactionDimension>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferAmountFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferAmountToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferAnyArgs = {
  of: BitqueryRippleTransferMeasurable;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferCountArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransferUniq>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferCountBigIntArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryRippleTransferUniq>;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferMaximumArgs = {
  get?: InputMaybe<BitqueryRippleTransferMeasurable>;
  of: BitqueryRippleTransferMeasurable;
};


/** Transfer in Ripple blockchain */
export type BitqueryRippleTransferMinimumArgs = {
  get?: InputMaybe<BitqueryRippleTransferMeasurable>;
  of: BitqueryRippleTransferMeasurable;
};

export type BitqueryRippleTransferFilter = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  currencyFromSymbol?: InputMaybe<BitqueryCurrencySelector>;
  currencyToSymbol?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  transactionType?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryRippleTransferMeasurable =
  /** Amount from */
  | 'amountFrom'
  /** Amount to */
  | 'amountTo'
  /** Block */
  | 'block'
  /** Currency from name */
  | 'currencyFromName'
  /** Currency from symbol */
  | 'currencyFromSymbol'
  /** Currency to name */
  | 'currencyToName'
  /** Currency to symbol */
  | 'currencyToSymbol'
  /** Date */
  | 'date'
  /** Direction */
  | 'direction'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender'
  /** Transaction type */
  | 'transactionType';

export type BitqueryRippleTransferUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies from name count */
  | 'currencyFromNames'
  /** Uniq currencies from symbol count */
  | 'currencyFromSymbols'
  /** Uniq currencies to name count */
  | 'currencyToNames'
  /** Uniq currencies to symbol count */
  | 'currencyToSymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq directions count */
  | 'directions'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders'
  /** Uniq transaction types count */
  | 'transactionTypes';

/** Smart contract crypto currency ( token, coin, currency ) */
export type BitqueryScCurrency = {
  /** Decimals */
  decimals: Scalars['Int']['output'];
  /** Currency name */
  name?: Maybe<Scalars['String']['output']>;
  /** Currency symbol */
  symbol: Scalars['String']['output'];
  /** Token Type */
  tokenType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryScriptTypeSelectorSelector =
  /** Peer-to-peer */
  | 'peer_to_peer_transaction'
  /** Unknown Transaction */
  | 'unknown_transaction';

export type BitquerySeedOptions = {
  /** Invalidating cache seed */
  seed?: InputMaybe<Scalars['Int']['input']>;
};

/** Solana Sender */
export type BitquerySender = {
  address: Scalars['String']['output'];
  mintAccount: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** Smart contract method or event */
export type BitquerySignature = BitqueryEvent | BitqueryMethod;

export type BitquerySignatureTypeSelector =
  /** Smart contract event */
  | 'Event'
  /** Smart contract method */
  | 'Function';

/** Blockchain smart contract */
export type BitquerySmartContract = {
  /** String address representation */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract Type */
  contractType: BitquerySmartContractType;
  /** Smart Contract Protocol Type */
  protocol?: Maybe<Scalars['String']['output']>;
};

export type BitquerySmartContractArgumentsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique callers count */
  | 'callers'
  /** Calls or events */
  | 'calls'
  /** Unique date count */
  | 'dates'
  /** Unique transaction senders */
  | 'senders'
  /** Unique signatures count */
  | 'signatures'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** Unique transactions count */
  | 'txs'
  /** Unique values */
  | 'values';

export type BitquerySmartContractCallsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique callers count */
  | 'callers'
  /** Calls */
  | 'calls'
  /** Unique date count */
  | 'dates'
  /** Unique transaction senders */
  | 'senders'
  /** Unique smart contract methods count */
  | 'smart_contract_methods'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** Unique transactions count */
  | 'txs';

export type BitquerySmartContractEventsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates'
  /** Shard ID */
  | 'shard_id'
  /** Unique smart contract methods count */
  | 'smart_contract_methods'
  /** Unique smart contracts count */
  | 'smart_contracts'
  /** To Shard ID */
  | 'to_shard_id'
  /** Unique transaction senders */
  | 'tx_from'
  /** Unique callers count */
  | 'tx_to'
  /** Unique transactions count */
  | 'txs';

/** Blockchain smart contract */
export type BitquerySmartContractInfo = {
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitquerySmartContractReadonlyAttribute = {
  /** Value as address if applicable */
  address?: Maybe<BitqueryEthereumAddressInfo>;
  /** Method name */
  name: Scalars['String']['output'];
  /** Method return type */
  type: Scalars['String']['output'];
  /** Method return value */
  value: Scalars['String']['output'];
};

export type BitquerySmartContractType =
  /** Decentralized exchange */
  | 'DEX'
  /** General Purpose Smart contract */
  | 'Generic'
  /** Smart contract for token derivatives */
  | 'MarginPositionToken'
  /** Multi signature wallet */
  | 'Multisig'
  /** Not A Smart contract */
  | 'None'
  /** Transaction Execution Approval Language */
  | 'TEAL'
  /** Token */
  | 'Token'
  /** Token Sale */
  | 'TokenSale';

/** Selector of smart contract type */
export type BitquerySmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: InputMaybe<Array<BitquerySmartContractType>>;
  /** Smart Contract type is */
  is?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not */
  not?: InputMaybe<BitquerySmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: InputMaybe<Array<BitquerySmartContractType>>;
};

/** Solana Chain */
export type BitquerySolana = {
  /** Basic information about address */
  address: Array<BitquerySolanaAddressInfoWithBalance>;
  /** BlockRewards of Smart Contract Calls and Events */
  blockRewards?: Maybe<Array<BitquerySolanaBlockReward>>;
  /** Solana Blocks */
  blocks?: Maybe<Array<BitquerySolanaBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitquerySolanaCoinpath>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   *         that should be passed to the program.
   */
  instructionAccounts?: Maybe<Array<BitquerySolanaInstructionAccount>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   *         that should be passed to the program.
   */
  instructions?: Maybe<Array<BitquerySolanaInstruction>>;
  /** Solana Transaction */
  transactions?: Maybe<Array<BitquerySolanaTransaction>>;
  /** Currency transfers from/to addresses in crypto currencies */
  transfers?: Maybe<Array<BitquerySolanaTransfer>>;
};


/** Solana Chain */
export type BitquerySolanaAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Solana Chain */
export type BitquerySolanaBlockRewardsArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitquerySolanaBlockRewardFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};


/** Solana Chain */
export type BitquerySolanaBlocksArgs = {
  any?: InputMaybe<Array<BitquerySolanaBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  rewards?: InputMaybe<BitqueryAmountSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Solana Chain */
export type BitquerySolanaInstructionAccountsArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  accountIndex?: InputMaybe<BitqueryIntegerSelector>;
  accountOwner?: InputMaybe<BitqueryStringSelector>;
  accountType?: InputMaybe<BitqueryStringSelector>;
  any?: InputMaybe<Array<BitquerySolanaInstructionAccountFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaInstructionsArgs = {
  any?: InputMaybe<Array<BitquerySolanaInstructionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaTransactionsArgs = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
  any?: InputMaybe<Array<BitquerySolanaTransactionFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentSlot?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionFee?: InputMaybe<BitqueryAmountSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Solana Chain */
export type BitquerySolanaTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitquerySolanaTransferFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};

/** Solana Account */
export type BitquerySolanaAccount = {
  index: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  owner: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** Blockchain address */
export type BitquerySolanaAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitquerySmartContractInfo>;
};


/** Blockchain address */
export type BitquerySolanaAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Block in Solana  blockchain */
export type BitquerySolanaBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** The slot index of this block`s parent */
  parentSlot?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  rewards?: Maybe<Scalars['Float']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['Int']['output']>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockAnyArgs = {
  of: BitquerySolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockBlockHashArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockCountArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockUniq>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockUniq>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockMaximumArgs = {
  get?: InputMaybe<BitquerySolanaBlockMeasureable>;
  of: BitquerySolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockMinimumArgs = {
  get?: InputMaybe<BitquerySolanaBlockMeasureable>;
  of: BitquerySolanaBlockMeasureable;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockParentSlotArgs = {
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockPreviousBlockHashArgs = {
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockRewardsArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  rewards?: InputMaybe<BitqueryAmountSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Block in Solana  blockchain */
export type BitquerySolanaBlockTransactionCountArgs = {
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  rewards?: InputMaybe<BitqueryAmountSelector>;
  transactionCount?: InputMaybe<BitqueryIntegerSelector>;
};

/** Solana Block Info */
export type BitquerySolanaBlockInfo = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  parentSlot?: Maybe<Scalars['BitqueryBigInt']['output']>;
  previousBlockHash?: Maybe<Scalars['String']['output']>;
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};

export type BitquerySolanaBlockMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** The slot index of this block`s parent */
  | 'parent_slot'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Number of reward lamports credited or debited by the account */
  | 'rewards'
  /** Time */
  | 'time'
  /** Count of transactions in this block */
  | 'transaction_count';

/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockReward = {
  /** Account */
  account?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where  transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  postBalance?: Maybe<Scalars['Float']['output']>;
  /** Type of reward */
  rewardType?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  time?: Maybe<BitqueryDateTime>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardAccountArgs = {
  account?: InputMaybe<BitqueryHashSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardAmountArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardAnyArgs = {
  of: BitquerySolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentSlot?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardCountArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockRewardUniq>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaBlockRewardUniq>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardExpressionArgs = {
  get: Scalars['String']['input'];
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardMaximumArgs = {
  get?: InputMaybe<BitquerySolanaBlockRewardMeasureable>;
  of: BitquerySolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardMinimumArgs = {
  get?: InputMaybe<BitquerySolanaBlockRewardMeasureable>;
  of: BitquerySolanaBlockRewardMeasureable;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardPostBalanceArgs = {
  account?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};


/** BlockReward in Solana  blockchain */
export type BitquerySolanaBlockRewardRewardTypeArgs = {
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};

export type BitquerySolanaBlockRewardFilter = {
  account?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentSlot?: InputMaybe<BitqueryIntegerSelector>;
  postBalance?: InputMaybe<BitqueryAmountSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  reward?: InputMaybe<BitqueryAmountSelector>;
  rewardType?: InputMaybe<BitqueryRewardTypeSelector>;
};

export type BitquerySolanaBlockRewardMeasureable =
  /** Account */
  | 'account'
  /** Number of reward lamports credited or debited by the account */
  | 'amount'
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** The slot index of this block`s parent */
  | 'parent_slot'
  /** Account balances after the transaction was processed */
  | 'post_balance'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Time */
  | 'time';

export type BitquerySolanaBlockRewardUniq =
  /** Unique accounts */
  | 'account'
  /** Unique hash of the the block */
  | 'block_hash'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique time */
  | 'times';

export type BitquerySolanaBlockUniq =
  /** Unique date count */
  | 'dates'
  /** Unique Number of block in the blockchains */
  | 'height'
  /** Unique time */
  | 'times';

/** Solana Coinpath */
export type BitquerySolanaCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  signature?: Maybe<BitquerySolanaSignatureValueDimension>;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathAnyArgs = {
  of: BitquerySolanaCoinpathMeasureable;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathMaximumArgs = {
  get?: InputMaybe<BitquerySolanaCoinpathMeasureable>;
  of: BitquerySolanaCoinpathMeasureable;
};


/** Solana Coinpath */
export type BitquerySolanaCoinpathMinimumArgs = {
  get?: InputMaybe<BitquerySolanaCoinpathMeasureable>;
  of: BitquerySolanaCoinpathMeasureable;
};

export type BitquerySolanaCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Signature */
  | 'signature'
  /** Time */
  | 'time';

/** Crypto currency ( token, coin, currency ) */
export type BitquerySolanaCryptoCurrency = {
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Decimals */
  decimals: Scalars['Int']['output'];
  /** Currency name */
  name?: Maybe<Scalars['String']['output']>;
  /** Currency symbol */
  symbol: Scalars['String']['output'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']['output']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']['output']>;
};

/** Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol */
export type BitquerySolanaCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Instruction in Solana  blockchain */
export type BitquerySolanaInstruction = {
  /** Accounts count */
  accountsCount?: Maybe<Scalars['Int']['output']>;
  /** Action */
  action?: Maybe<BitqueryAction>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where  transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Instruction Data */
  data?: Maybe<BitqueryData>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** External Action */
  externalAction?: Maybe<BitqueryAction>;
  /** External Program */
  externalProgram?: Maybe<BitqueryProgram>;
  log?: Maybe<BitqueryLog>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Program */
  program?: Maybe<BitqueryProgram>;
  /** Transaction where instruction is included */
  transaction?: Maybe<BitquerySolanaTransactionInfo>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionActionArgs = {
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionAnyArgs = {
  of: BitquerySolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionCallPathArgs = {
  callPath?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionCountArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionUniq>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionUniq>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionDataArgs = {
  dataBase58?: InputMaybe<BitqueryStringSelector>;
  dataHex?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExternalArgs = {
  external?: InputMaybe<BitqueryBooleanSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExternalActionArgs = {
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionExternalProgramArgs = {
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  externalProgramName?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionMaximumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionMeasureable>;
  of: BitquerySolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionMinimumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionMeasureable>;
  of: BitquerySolanaInstructionMeasureable;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionProgramArgs = {
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  programName?: InputMaybe<BitqueryStringSelector>;
};


/** Instruction in Solana  blockchain */
export type BitquerySolanaInstructionTransactionArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
};

/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccount = {
  /** Information about account */
  account?: Maybe<BitquerySolanaAccount>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Instruction */
  instruction?: Maybe<BitqueryInstruction>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Transaction */
  transaction?: Maybe<BitquerySolanaTransactionInfo>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountAccountArgs = {
  accountIndex?: InputMaybe<BitqueryIntegerSelector>;
  accountName?: InputMaybe<BitqueryStringSelector>;
  accountOwner?: InputMaybe<BitqueryStringSelector>;
  accountType?: InputMaybe<BitqueryStringSelector>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountAnyArgs = {
  of: BitquerySolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountBlockArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountCountArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionAccountUniq>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaInstructionAccountUniq>;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountExpressionArgs = {
  get: Scalars['String']['input'];
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountMaximumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionAccountMeasureable>;
  of: BitquerySolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountMinimumArgs = {
  get?: InputMaybe<BitquerySolanaInstructionAccountMeasureable>;
  of: BitquerySolanaInstructionAccountMeasureable;
};


/** InstructionAccount in Solana  blockchain */
export type BitquerySolanaInstructionAccountTransactionArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaInstructionAccountFilter = {
  account?: InputMaybe<BitqueryStringSelector>;
  accountIndex?: InputMaybe<BitqueryIntegerSelector>;
  accountOwner?: InputMaybe<BitqueryStringSelector>;
  accountType?: InputMaybe<BitqueryStringSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaInstructionAccountMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time';

export type BitquerySolanaInstructionAccountUniq =
  /** Account name */
  | 'account_name'
  /** Unique date count */
  | 'dates'
  /** Number of block in the blockchains */
  | 'height'
  /** Transaction Hash */
  | 'signature'
  /** Unique time */
  | 'times';

export type BitquerySolanaInstructionFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryIntegerSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaInstructionMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time';

export type BitquerySolanaInstructionUniq =
  /** Unique date count */
  | 'dates'
  /** Number of block in the blockchains */
  | 'height'
  /** Transaction Hash */
  | 'signature'
  /** Unique time */
  | 'times';

export type BitquerySolanaNetwork =
  /** Solana Mainnat */
  | 'solana';

export type BitquerySolanaRewardType =
  /** fee type */
  | 'Fee'
  /** rent type */
  | 'Rent'
  /** staking type */
  | 'Staking'
  /** voing type */
  | 'Voting';

/** Blockchain transaction with value */
export type BitquerySolanaSignatureValueDimension = {
  /** Transaction hash */
  hash: Scalars['String']['output'];
  /** Transaction value */
  value: Scalars['Float']['output'];
};

/** Transaction in Solana  blockchain */
export type BitquerySolanaTransaction = {
  /** Count of inner instructions */
  accountsCount?: Maybe<Scalars['Int']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where  transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Error */
  error?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Fee Payer */
  feePayer?: Maybe<Scalars['String']['output']>;
  /** Count of inner instructions */
  innerInstructionsCount?: Maybe<Scalars['Int']['output']>;
  /** Count of instructions */
  instructionsCount?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Recent blockhash prevents duplication and to give transactions lifetimes */
  recentBlockHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Hash */
  signature?: Maybe<Scalars['String']['output']>;
  /** Accounts` public keys */
  signer?: Maybe<Scalars['String']['output']>;
  /** Successed or failed */
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionFee?: Maybe<Scalars['Float']['output']>;
  /** Transaction Index */
  transactionIndex?: Maybe<Scalars['Int']['output']>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionAccountsCountArgs = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionAnyArgs = {
  of: BitquerySolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionCountArgs = {
  uniq?: InputMaybe<BitquerySolanaTransactionUniq>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionCountBigIntArgs = {
  uniq?: InputMaybe<BitquerySolanaTransactionUniq>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionErrorArgs = {
  error?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionFeePayerArgs = {
  feePayer?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionInnerInstructionsCountArgs = {
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionInstructionsCountArgs = {
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionMaximumArgs = {
  get?: InputMaybe<BitquerySolanaTransactionMeasureable>;
  of: BitquerySolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionMinimumArgs = {
  get?: InputMaybe<BitquerySolanaTransactionMeasureable>;
  of: BitquerySolanaTransactionMeasureable;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionRecentBlockHashArgs = {
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionSignatureArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionSignerArgs = {
  signer?: InputMaybe<BitqueryHashSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionSuccessArgs = {
  success?: InputMaybe<BitqueryBooleanSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionTransactionFeeArgs = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  parentSlot?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionFee?: InputMaybe<BitqueryAmountSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};


/** Transaction in Solana  blockchain */
export type BitquerySolanaTransactionTransactionIndexArgs = {
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

export type BitquerySolanaTransactionFilter = {
  accountsCount?: InputMaybe<BitqueryIntegerSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryIntegerSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  innerInstructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  instructionsCount?: InputMaybe<BitqueryIntegerSelector>;
  parentSlot?: InputMaybe<BitqueryBlockSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  transactionFee?: InputMaybe<BitqueryAmountSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
};

/** Solana Transaction Info */
export type BitquerySolanaTransactionInfo = {
  feePayer?: Maybe<Scalars['String']['output']>;
  signature?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** Solana Transaction Info Extended */
export type BitquerySolanaTransactionInfoExt = {
  accountsCount?: Maybe<Scalars['Int']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  feePayer?: Maybe<Scalars['String']['output']>;
  innerInstructionsCount?: Maybe<Scalars['Int']['output']>;
  instructionsCount?: Maybe<Scalars['Int']['output']>;
  recentBlockHash?: Maybe<Scalars['String']['output']>;
  signature?: Maybe<Scalars['String']['output']>;
  signer?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  transactionIndex?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

export type BitquerySolanaTransactionMeasureable =
  /** Hash of the the block */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee'
  /** Number of block in the blockhains */
  | 'height'
  /** The slot index of this block`s parent */
  | 'parent_slot'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time'
  /** Transaction Fee */
  | 'transaction_fee';

export type BitquerySolanaTransactionUniq =
  /** Unique date count */
  | 'dates'
  /** Number of block in the blockchains */
  | 'height'
  /** Transaction Hash */
  | 'signature'
  /** Accounts` public key */
  | 'signer'
  /** Unique time */
  | 'times';

/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransfer = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitquerySolanaBlockInfo>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitquerySolanaCryptoCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Instruction where transfer is included */
  instruction?: Maybe<BitqueryInstructionWithExternals>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryReceiver>;
  /** Sender */
  sender?: Maybe<BitquerySender>;
  /** Transaction where transfer is included */
  transaction?: Maybe<BitquerySolanaTransactionInfoExt>;
  /** Transfer Type */
  transferType?: Maybe<Scalars['String']['output']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferAnyArgs = {
  of: BitquerySolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferBlockArgs = {
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
  uniq?: InputMaybe<BitquerySolanaTransferUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
  uniq?: InputMaybe<BitquerySolanaTransferUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferMaximumArgs = {
  get?: InputMaybe<BitquerySolanaTransferMeasureable>;
  of: BitquerySolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferMinimumArgs = {
  get?: InputMaybe<BitquerySolanaTransferMeasureable>;
  of: BitquerySolanaTransferMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferTransactionArgs = {
  signature?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitquerySolanaTransferTransferTypeArgs = {
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};

export type BitquerySolanaTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  callPath?: InputMaybe<BitqueryStringSelector>;
  currency?: InputMaybe<Array<BitquerySolanaCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<BitqueryStringSelector>;
  externalParsed?: InputMaybe<BitqueryIntegerSelector>;
  externalParsedActionName?: InputMaybe<BitqueryStringSelector>;
  externalParsedProgramName?: InputMaybe<BitqueryStringSelector>;
  externalParsedType?: InputMaybe<BitqueryStringSelector>;
  externalProgramId?: InputMaybe<BitqueryStringSelector>;
  feePayer?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parsed?: InputMaybe<BitqueryIntegerSelector>;
  parsedActionName?: InputMaybe<BitqueryStringSelector>;
  parsedProgramName?: InputMaybe<BitqueryStringSelector>;
  parsedType?: InputMaybe<BitqueryStringSelector>;
  previousBlockHash?: InputMaybe<BitqueryHashSelector>;
  programId?: InputMaybe<BitqueryStringSelector>;
  receiverAddress?: InputMaybe<BitqueryStringSelector>;
  receiverMintAddress?: InputMaybe<BitqueryStringSelector>;
  receiverType?: InputMaybe<BitqueryStringSelector>;
  recentBlockHash?: InputMaybe<BitqueryHashSelector>;
  senderAddress?: InputMaybe<BitqueryStringSelector>;
  senderMintAddress?: InputMaybe<BitqueryStringSelector>;
  senderType?: InputMaybe<BitqueryStringSelector>;
  signature?: InputMaybe<BitqueryHashSelector>;
  signer?: InputMaybe<BitqueryHashSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tokenAccount?: InputMaybe<Array<BitqueryStringSelector>>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transferType?: InputMaybe<BitquerySolanaTransferTypeSelector>;
};

export type BitquerySolanaTransferMeasureable =
  /** Amount Transfer */
  | 'amount'
  /** Hash of the the block */
  | 'block_hash'
  /** Currency Name */
  | 'currency_name'
  /** Currency Symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Transaction Fee */
  | 'fee_payer'
  /** Number of block in the blockhains */
  | 'height'
  /** The block hash of this block`s parent */
  | 'previous_block_hash'
  /** Transaction Hash */
  | 'signature'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token Type */
  | 'token_type'
  /** Transfer Type */
  | 'transfer_type';

export type BitquerySolanaTransferType =
  /** Burn */
  | 'burn'
  /** Close Account */
  | 'close_account'
  /** Create Account */
  | 'create_account'
  /** Mint */
  | 'mint'
  /** Nonce Withdraw */
  | 'nonce_withdraw'
  /** Rent Exemption */
  | 'rent_exemption'
  /** Self */
  | 'self'
  /** Stake */
  | 'stake'
  /** Stake Withdraw */
  | 'stake_withdraw'
  /** Trade Unknown */
  | 'trade_unknown'
  /** Transfer */
  | 'transfer'
  /** Vote */
  | 'vote';

/** Select by transfer type */
export type BitquerySolanaTransferTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitquerySolanaTransferType>>;
  /** Type is */
  is?: InputMaybe<BitquerySolanaTransferType>;
  /** Type not */
  not?: InputMaybe<BitquerySolanaTransferType>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitquerySolanaTransferType>>;
};

export type BitquerySolanaTransferUniq =
  /** Currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Fee Payer */
  | 'fee_payer'
  /** Number of block in the blockchains */
  | 'height'
  /** Transfer To */
  | 'receiver_address'
  /** Transfer To Mint Address */
  | 'receiver_mint_address'
  /** Transfer From */
  | 'sender_address'
  /** Transfer From Mint Address */
  | 'sender_mint_address'
  /** Transaction Hash */
  | 'signature'
  /** Signer */
  | 'signer'
  /** Unique time */
  | 'times'
  /** Token Account Address */
  | 'token_account';

export type BitqueryStakingTransactionsTypeEnum =
  | 'CollectRewards'
  | 'CreateValidator'
  | 'Delegate'
  | 'EditValidator'
  | 'Undelegate';

/** Indicates what type of operation the transaction is supposed to do. */
export type BitqueryStakingTransactionsTypeSelector = {
  /** Type in the list */
  in?: InputMaybe<Array<BitqueryStakingTransactionsTypeEnum>>;
  /** Type is */
  is?: InputMaybe<BitqueryStakingTransactionsTypeEnum>;
  /** Type not */
  not?: InputMaybe<BitqueryStakingTransactionsTypeEnum>;
  /** Type not in the list */
  notIn?: InputMaybe<Array<BitqueryStakingTransactionsTypeEnum>>;
};

/** Stellar Chain */
export type BitqueryStellar = {
  /** Basic information about address */
  address: Array<BitqueryStellarAddressInfo>;
  /** Blockchain Address Statistics */
  addressStats?: Maybe<Array<BitqueryStellarAddressStats>>;
  /** Stellar Balance Effects */
  balanceEffects?: Maybe<Array<BitqueryStellarBalanceEffect>>;
  /** Stellar Ledgers */
  blocks?: Maybe<Array<BitqueryStellarBlock>>;
  /** Stellar Claimable Balance Effects */
  claimableBalanceEffects?: Maybe<Array<BitqueryStellarClaimableBalanceEffect>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryStellarCoinpath>>;
  /** Stellar Effect Arguments */
  effectArguments?: Maybe<Array<BitqueryStellarEffectArgument>>;
  /** Stellar Effects */
  effects?: Maybe<Array<BitqueryStellarEffect>>;
  /** Stellar Liquidity Pool Effects */
  liquidityPoolEffects?: Maybe<Array<BitqueryStellarLiquidityPoolEffect>>;
  /** Stellar Liquidity Pool Trade Effects */
  liquidityPoolTradeEffects?: Maybe<Array<BitqueryStellarLiquidityPoolTradeEffect>>;
  /** Stellar Operations */
  operations?: Maybe<Array<BitqueryStellarOperation>>;
  /** Stellar Payments */
  payments?: Maybe<Array<BitqueryStellarPayment>>;
  /** Stellar Trade Effects */
  tradeEffects?: Maybe<Array<BitqueryStellarTradeEffect>>;
  /** Stellar Transactions */
  transactions?: Maybe<Array<BitqueryStellarTransaction>>;
  /** Stellar Transfers */
  transfers?: Maybe<Array<BitqueryStellarTransfer>>;
};


/** Stellar Chain */
export type BitqueryStellarAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Stellar Chain */
export type BitqueryStellarAddressStatsArgs = {
  address: BitqueryAddressSelector;
  options?: InputMaybe<BitqueryQueryOptions>;
};


/** Stellar Chain */
export type BitqueryStellarBalanceEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarBalanceEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarBlocksArgs = {
  any?: InputMaybe<Array<BitqueryStellarBlockFilter>>;
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Stellar Chain */
export type BitqueryStellarClaimableBalanceEffectsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarClaimableBalanceEffectFilter>>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currencyFrom?: InputMaybe<BitqueryCurrencySelector>;
  currencyTo?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Stellar Chain */
export type BitqueryStellarEffectArgumentsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarEffectArgumentFilter>>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarLiquidityPoolEffectsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarLiquidityPoolEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarLiquidityPoolTradeEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarLiquidityPoolTradeEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarOperationsArgs = {
  any?: InputMaybe<Array<BitqueryStellarOperationFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarPaymentsArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarPaymentFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarTradeEffectsArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryStellarTradeEffectFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Stellar Chain */
export type BitqueryStellarTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryStellarTransactionFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};


/** Stellar Chain */
export type BitqueryStellarTransfersArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryStellarTransferFilter>>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

/** Address detailed information for Stellar network */
export type BitqueryStellarAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** XLM balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Token Balances */
  tokenBalances?: Maybe<Array<BitqueryStellarTokenBalances>>;
};


/** Address detailed information for Stellar network */
export type BitqueryStellarAddressInfoBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/**
 * Counts and aggregates for the address, transfer count,
 *                   amount, number of distinct currencies,
 *                   times of the first and the last transactions
 */
export type BitqueryStellarAddressStat = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Days with received */
  daysWithReceived?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with sent */
  daysWithSent?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transactions */
  daysWithTransactions?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Days with transfers */
  daysWithTransfers?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** First transfer at */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** First tx at */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Last transfer at */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  /** Last tx at */
  lastTxAt?: Maybe<BitqueryDateTime>;
  /** Receive Amount */
  receiveAmount?: Maybe<Scalars['Float']['output']>;
  /** Receive from Count */
  receiveFromCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive from currencies */
  receiveFromCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Receive tx Count */
  receiveTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send Amount */
  sendAmount?: Maybe<Scalars['Float']['output']>;
  /** Send to count */
  sendToCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send to currencies */
  sendToCurrencies?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Send tx count */
  sendTxCount?: Maybe<Scalars['BitqueryBigInt']['output']>;
};

/** AddressStat */
export type BitqueryStellarAddressStats = {
  /** Address With Statistics */
  address?: Maybe<BitqueryStellarAddressStat>;
};

/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffect = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectAnyArgs = {
  of: BitqueryStellarBalanceEffectMeasurable;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarBalanceEffectUniq>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarBalanceEffectUniq>;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarBalanceEffectMeasurable>;
  of: BitqueryStellarBalanceEffectMeasurable;
};


/** Balance effect in Stellar blockchain */
export type BitqueryStellarBalanceEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarBalanceEffectMeasurable>;
  of: BitqueryStellarBalanceEffectMeasurable;
};

export type BitqueryStellarBalanceEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarBalanceEffectMeasurable =
  /** Address */
  | 'address'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Effect index */
  | 'effectIndex'
  /** Issuer */
  | 'issuer'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarBalanceEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies name count */
  | 'currenciesName'
  /** Uniq currencies symbol count */
  | 'currenciesSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Block in Stellar blockchain */
export type BitqueryStellarBlock = {
  any?: Maybe<Scalars['String']['output']>;
  baseFee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  baseReserve?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  feePool?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Ledger number (block|height) in blockchain */
  height: Scalars['Int']['output'];
  /** Max transaction set size */
  maxTxSetSize: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Protocol version */
  protocolVersion: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  totalCoins?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockAnyArgs = {
  of: BitqueryStellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockBaseFeeArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockBaseReserveArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockCountArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  uniq?: InputMaybe<BitqueryStellarBlockUniq>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockCountBigIntArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
  uniq?: InputMaybe<BitqueryStellarBlockUniq>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockFeePoolArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockMaximumArgs = {
  get?: InputMaybe<BitqueryStellarBlockMeasurable>;
  of: BitqueryStellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockMinimumArgs = {
  get?: InputMaybe<BitqueryStellarBlockMeasurable>;
  of: BitqueryStellarBlockMeasurable;
};


/** Block in Stellar blockchain */
export type BitqueryStellarBlockTotalCoinsArgs = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryStellarBlockFilter = {
  baseFee?: InputMaybe<BitqueryFloatSelector>;
  baseReserve?: InputMaybe<BitqueryFloatSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  feePool?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maxTxSetSize?: InputMaybe<BitqueryIntegerSelector>;
  protocolVersion?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  totalCoins?: InputMaybe<BitqueryFloatSelector>;
};

export type BitqueryStellarBlockMeasurable =
  /** Base fee */
  | 'baseFee'
  /** Base reserve */
  | 'baseReserve'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Fee pool */
  | 'feePool'
  /** Block hash */
  | 'hash'
  /** Max tx set size */
  | 'maxTxSetSize'
  /** Protocol version */
  | 'protocolVersion'
  /** Time */
  | 'time'
  /** Total coins */
  | 'totalCoins';

export type BitqueryStellarBlockUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq date count */
  | 'dates'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq max tx set sizes count */
  | 'maxTxSetSizes'
  /** Uniq protocol versions */
  | 'protocolVersions';

/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffect = {
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balanceId?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Claimant */
  claimant?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Sponsor */
  sponsor?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectAnyArgs = {
  of: BitqueryStellarClaimableBalanceEffectMeasurable;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarClaimableBalanceEffectUniq>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarClaimableBalanceEffectUniq>;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarClaimableBalanceEffectMeasurable>;
  of: BitqueryStellarClaimableBalanceEffectMeasurable;
};


/** Claimable balance effect in Stellar blockchain */
export type BitqueryStellarClaimableBalanceEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarClaimableBalanceEffectMeasurable>;
  of: BitqueryStellarClaimableBalanceEffectMeasurable;
};

export type BitqueryStellarClaimableBalanceEffectFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  balanceId?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  claimant?: InputMaybe<BitqueryAddressSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sponsor?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarClaimableBalanceEffectMeasurable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Claimant */
  | 'claimant'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Issuer */
  | 'issuer'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Sponsor */
  | 'sponsor'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarClaimableBalanceEffectUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq claimants count */
  | 'claimants'
  /** Uniq currencies name count */
  | 'currenciesName'
  /** Uniq currencies symbol count */
  | 'currenciesSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq operaion indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq sponsors count */
  | 'sponsors'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Stellar Coinpath */
export type BitqueryStellarCoinpath = {
  /** Summary of transfered value from */
  amountFrom?: Maybe<Scalars['Float']['output']>;
  /** Summary of transfered value to */
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency From of transfer */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency To of transfer */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryStellarCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryStellarTransactionCoinpathDimension>;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathAmountFromArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathAmountToArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathAnyArgs = {
  of: BitqueryStellarCoinpathMeasureable;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryStellarCoinpathMeasureable>;
  of: BitqueryStellarCoinpathMeasureable;
};


/** Stellar Coinpath */
export type BitqueryStellarCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryStellarCoinpathMeasureable>;
  of: BitqueryStellarCoinpathMeasureable;
};

/** Address detailed information for Stellar network */
export type BitqueryStellarCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** First Tx At */
  firstTransferAt?: Maybe<BitqueryDateTime>;
  /** Last Tx At */
  lastTransferAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
};

export type BitqueryStellarCoinpathMeasureable =
  /** Block */
  | 'block'
  /** Depth */
  | 'depth'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Version */
  | 'tx_hash';

/** Effect in Stellar blockchain */
export type BitqueryStellarEffect = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Details */
  details?: Maybe<Scalars['String']['output']>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Effect index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectAnyArgs = {
  of: BitqueryStellarEffectMeasurable;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectUniq>;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectUniq>;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarEffectMeasurable>;
  of: BitqueryStellarEffectMeasurable;
};


/** Effect in Stellar blockchain */
export type BitqueryStellarEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarEffectMeasurable>;
  of: BitqueryStellarEffectMeasurable;
};

/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgument = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Argname */
  argname?: Maybe<Scalars['String']['output']>;
  /** Argvalue */
  argvalue?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentAnyArgs = {
  of: BitqueryStellarEffectArgumentMeasurable;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectArgumentUniq>;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarEffectArgumentUniq>;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryStellarEffectArgumentMeasurable>;
  of: BitqueryStellarEffectArgumentMeasurable;
};


/** Effect argument in Stellar blockchain */
export type BitqueryStellarEffectArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryStellarEffectArgumentMeasurable>;
  of: BitqueryStellarEffectArgumentMeasurable;
};

export type BitqueryStellarEffectArgumentFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarEffectArgumentMeasurable =
  /** Address */
  | 'address'
  /** Argname */
  | 'argname'
  /** Argvalue */
  | 'argvalue'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarEffectArgumentUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq argnames count */
  | 'argnames'
  /** Uniq argvalues count */
  | 'argvalues'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

export type BitqueryStellarEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarEffectMeasurable =
  /** Address */
  | 'address'
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Details */
  | 'details'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq details count */
  | 'details'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffect = {
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect */
  effect?: Maybe<Scalars['String']['output']>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Issuer */
  issuer?: Maybe<BitqueryAddress>;
  /** Liquidity pool details */
  liquidityPoolDetails?: Maybe<Scalars['String']['output']>;
  /** Liquidity pool id bin */
  liquidityPoolId?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  shares?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectAnyArgs = {
  of: BitqueryStellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolEffectUniq>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolEffectUniq>;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolEffectMeasurable;
};


/** Liquidity pool effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolEffectSharesArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarLiquidityPoolEffectFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effect?: InputMaybe<BitqueryStringSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  issuer?: InputMaybe<BitqueryAddressSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  shares?: InputMaybe<BitqueryFloatSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarLiquidityPoolEffectMeasurable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Effect */
  | 'effect'
  /** Effect index */
  | 'effectIndex'
  /** Issuer */
  | 'issuer'
  /** Liquidity pool details */
  | 'liquidityPoolDetails'
  /** Liquidity pool id */
  | 'liquidityPoolId'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Shares */
  | 'shares'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarLiquidityPoolEffectUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies name count */
  | 'currenciesName'
  /** Uniq currencies symbol count */
  | 'currenciesSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq effects count */
  | 'effects'
  /** Uniq issuers count */
  | 'issuers'
  /** Uniq liquidity pool details count */
  | 'liquidityPoolDetails'
  /** Uniq liquidity pool ids count */
  | 'liquidityPoolIds'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffect = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  buyAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Buy currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  /** Buy issuer */
  buyIssuer?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Liquidity pool details */
  liquidityPoolDetails?: Maybe<Scalars['String']['output']>;
  /** Liquidity pool */
  liquidityPoolId?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  sellAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Sell currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Sell issuer */
  sellIssuer?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectAnyArgs = {
  of: BitqueryStellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectBuyAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectUniq>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectUniq>;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarLiquidityPoolTradeEffectMeasurable>;
  of: BitqueryStellarLiquidityPoolTradeEffectMeasurable;
};


/** Liquidity pool trade effect in Stellar blockchain */
export type BitqueryStellarLiquidityPoolTradeEffectSellAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarLiquidityPoolTradeEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  liquidityPoolDetails?: InputMaybe<BitqueryStringSelector>;
  liquidityPoolId?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarLiquidityPoolTradeEffectMeasurable =
  /** Address */
  | 'address'
  /** Block */
  | 'block'
  /** Buy amount */
  | 'buyAmount'
  /** Buy currency name */
  | 'buyCurrencyName'
  /** Buy currency symbol */
  | 'buyCurrencySymbol'
  /** Buy issuer */
  | 'buyIssuer'
  /** Date */
  | 'date'
  /** Effect index */
  | 'effectIndex'
  /** Liquidity pool details */
  | 'liquidityPoolDetails'
  /** Liquidity pool */
  | 'liquidityPoolId'
  /** Operation index */
  | 'opIndex'
  /** Opertation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Sell amount */
  | 'sellAmount'
  /** Sell currency name */
  | 'sellCurrencyName'
  /** Sell currency symbol */
  | 'sellCurrencySymbol'
  /** Sell issuer */
  | 'sellIssuer'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarLiquidityPoolTradeEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq buy currency names count */
  | 'buyCurrencyNames'
  /** Uniq buy currency symbols count */
  | 'buyCurrencySymbols'
  /** Uniq buy issuers count */
  | 'buyIssuers'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq liquidity pool details count */
  | 'liquidityPoolDetails'
  /** Uniq liquidity pool ids count */
  | 'liquidityPoolIds'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq sell currency names count */
  | 'sellCurrencyNames'
  /** Uniq sell currency symbols count */
  | 'sellCurrencySymbols'
  /** Uniq sell issuers count */
  | 'sellIssuers'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

export type BitqueryStellarNetwork =
  /** The Stellar Ledger */
  | 'stellar';

/** Operation in Stellar blockchain */
export type BitqueryStellarOperation = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Details */
  details?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Operation index */
  index?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<Scalars['String']['output']>;
  /** Operation source account */
  sourceAccount?: Maybe<BitqueryAddress>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationAnyArgs = {
  of: BitqueryStellarOperationMeasurable;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationCountArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarOperationUniq>;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationCountBigIntArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarOperationUniq>;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationMaximumArgs = {
  get?: InputMaybe<BitqueryStellarOperationMeasurable>;
  of: BitqueryStellarOperationMeasurable;
};


/** Operation in Stellar blockchain */
export type BitqueryStellarOperationMinimumArgs = {
  get?: InputMaybe<BitqueryStellarOperationMeasurable>;
  of: BitqueryStellarOperationMeasurable;
};

export type BitqueryStellarOperationFilter = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  details?: InputMaybe<BitqueryStringSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  sourceAccount?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarOperationMeasurable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Details */
  | 'details'
  /** Operation index */
  | 'index'
  /** Operation */
  | 'operation'
  /** Operation source account */
  | 'sourceAccount'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarOperationUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq details count */
  | 'details'
  /** Uniq operations count */
  | 'operations'
  /** Uniq op source accounts count */
  | 'sourceAccounts'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Payment in Stellar blockchain */
export type BitqueryStellarPayment = {
  amountFrom?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  amountTo?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the ledger */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  creditedToValue?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Sender's currency */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Receiver's currency */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  debitedFromValue?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Source issuer */
  issuerFrom?: Maybe<BitqueryAddress>;
  /** Issuer */
  issuerTo?: Maybe<BitqueryAddress>;
  maxValueFrom?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minValueTo?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Path */
  path?: Maybe<Scalars['String']['output']>;
  /** Payment receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Payment sender */
  sender?: Maybe<BitqueryAddress>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentAmountFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentAmountToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentAnyArgs = {
  of: BitqueryStellarPaymentMeasurable;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentCountArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarPaymentUniq>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentCountBigIntArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarPaymentUniq>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentCreditedToValueArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentDebitedFromValueArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMaxValueFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMaximumArgs = {
  get?: InputMaybe<BitqueryStellarPaymentMeasurable>;
  of: BitqueryStellarPaymentMeasurable;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMinValueToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Payment in Stellar blockchain */
export type BitqueryStellarPaymentMinimumArgs = {
  get?: InputMaybe<BitqueryStellarPaymentMeasurable>;
  of: BitqueryStellarPaymentMeasurable;
};

export type BitqueryStellarPaymentFilter = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  creditedToValue?: InputMaybe<BitqueryFloatSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  debitedFromValue?: InputMaybe<BitqueryFloatSelector>;
  issuerFrom?: InputMaybe<BitqueryAddressSelector>;
  issuerTo?: InputMaybe<BitqueryAddressSelector>;
  maxValueFrom?: InputMaybe<BitqueryFloatSelector>;
  minValueTo?: InputMaybe<BitqueryFloatSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  path?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarPaymentMeasurable =
  /** Amount from */
  | 'amountFrom'
  /** Amount to */
  | 'amountTo'
  /** Block */
  | 'block'
  /** Credited to value */
  | 'creditedToValue'
  /** Currency from name */
  | 'currencyFromName'
  /** Currency from symbol */
  | 'currencyFromSymbol'
  /** Currency to name */
  | 'currencyToName'
  /** Currency to symbol */
  | 'currencyToSymbol'
  /** Date */
  | 'date'
  /** Debited from value */
  | 'debitedFromValue'
  /** Issuer from */
  | 'issuerFrom'
  /** Issuer to */
  | 'issuerTo'
  /** Max value from */
  | 'maxValueFrom'
  /** Min value to */
  | 'minValueTo'
  /** Op index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Path */
  | 'path'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarPaymentUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currencies from name count */
  | 'currenciesFromName'
  /** Uniq currencies from symbol count */
  | 'currenciesFromSymbol'
  /** Uniq currencies to name count */
  | 'currenciesToName'
  /** Uniq currencies to symbol count */
  | 'currenciesToSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq issuers from count */
  | 'issuersFrom'
  /** Uniq issuers to count */
  | 'issuersTo'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq paths count */
  | 'paths'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Token Balance */
export type BitqueryStellarTokenBalances = {
  /** Asset code */
  assetCode?: Maybe<Scalars['String']['output']>;
  /** Asset issuer */
  assetIssuer?: Maybe<Scalars['String']['output']>;
  /** Asset type */
  assetType?: Maybe<Scalars['String']['output']>;
  /** Balance */
  balance?: Maybe<Scalars['Float']['output']>;
};

/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffect = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  buyAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Buy currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  /** Buy issuer */
  buyIssuer?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Effect index */
  effectIndex?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Offer */
  offerId?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexedWithAccount>;
  /** Order */
  order?: Maybe<Scalars['Int']['output']>;
  sellAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Sell currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Sell issuer */
  sellIssuer?: Maybe<BitqueryAddress>;
  /** Seller */
  seller?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectAnyArgs = {
  of: BitqueryStellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectBuyAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTradeEffectUniq>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTradeEffectUniq>;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectMaximumArgs = {
  get?: InputMaybe<BitqueryStellarTradeEffectMeasurable>;
  of: BitqueryStellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectMinimumArgs = {
  get?: InputMaybe<BitqueryStellarTradeEffectMeasurable>;
  of: BitqueryStellarTradeEffectMeasurable;
};


/** Trade effect in Stellar blockchain */
export type BitqueryStellarTradeEffectSellAmountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarTradeEffectFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  buyAmount?: InputMaybe<BitqueryFloatSelector>;
  buyCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  buyIssuer?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  effectIndex?: InputMaybe<BitqueryIntegerSelector>;
  offerId?: InputMaybe<BitqueryIntegerSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  opSourceAccount?: InputMaybe<BitqueryAddressSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  order?: InputMaybe<BitqueryIntegerSelector>;
  sellAmount?: InputMaybe<BitqueryFloatSelector>;
  sellCurrencyName?: InputMaybe<BitqueryCurrencySelector>;
  sellIssuer?: InputMaybe<BitqueryAddressSelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarTradeEffectMeasurable =
  /** Address */
  | 'address'
  /** Block */
  | 'block'
  /** Buy amount */
  | 'buyAmount'
  /** Buy currency name */
  | 'buyCurrencyName'
  /** Buy currency symbol */
  | 'buyCurrencySymbol'
  /** Buy issuer */
  | 'buyIssuer'
  /** Date */
  | 'date'
  /** Effect index */
  | 'effectIndex'
  /** Offer */
  | 'offerId'
  /** Operation index */
  | 'opIndex'
  /** Operation source account */
  | 'opSourceAccount'
  /** Operation */
  | 'operation'
  /** Order */
  | 'order'
  /** Sell amount */
  | 'sellAmount'
  /** Sell currency name */
  | 'sellCurrencyName'
  /** Sell currency symbol */
  | 'sellCurrencySymbol'
  /** Sell issuer */
  | 'sellIssuer'
  /** Seller */
  | 'seller'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarTradeEffectUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq buy currency names count */
  | 'buyCurrencyNames'
  /** Uniq buy currency symbols count */
  | 'buyCurrencySymbols'
  /** Uniq buy issuers count */
  | 'buyIssuers'
  /** Uniq dates count */
  | 'dates'
  /** Uniq effect indices count */
  | 'effectIndices'
  /** Uniq offer ids count */
  | 'offerIds'
  /** Uniq operation indices count */
  | 'opIndices'
  /** Uniq operation source accounts count */
  | 'opSourceAccounts'
  /** Uniq operations count */
  | 'operations'
  /** Uniq orders count */
  | 'orders'
  /** Uniq sell currency names count */
  | 'sellCurrencyNames'
  /** Uniq sell currency symbols count */
  | 'sellCurrencySymbols'
  /** Uniq sell issuers count */
  | 'sellIssuers'
  /** Uniq sellers count */
  | 'sellers'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction indices count */
  | 'transactionIndices'
  /** Uniq transaction senders count */
  | 'transactionSenders';

/** Transaction in Stellar blockchain */
export type BitqueryStellarTransaction = {
  any?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the ledger that this transaction was included in */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  /** Fee payer */
  feeAccount?: Maybe<BitqueryAddress>;
  /** Hash of this transaction */
  hash?: Maybe<Scalars['String']['output']>;
  /** Index of this transaction */
  index?: Maybe<Scalars['Int']['output']>;
  maxFee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Memo type */
  memoType?: Maybe<Scalars['String']['output']>;
  /** Memos */
  memos?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Amout of operations */
  operationCount?: Maybe<Scalars['Int']['output']>;
  /** Sender of this transaction */
  sender?: Maybe<BitqueryAddress>;
  /** Sequence */
  sequence?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Time bounds */
  timeBounds?: Maybe<Scalars['String']['output']>;
  /** The time this transaction was created */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionAnyArgs = {
  of: BitqueryStellarTransactionMeasurable;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionCountArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryStellarTransactionUniq>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionCountBigIntArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryStellarTransactionUniq>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionFeeArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionMaxFeeArgs = {
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryStellarTransactionMeasurable>;
  of: BitqueryStellarTransactionMeasurable;
};


/** Transaction in Stellar blockchain */
export type BitqueryStellarTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryStellarTransactionMeasurable>;
  of: BitqueryStellarTransactionMeasurable;
};

/** Blockchain transaction Info */
export type BitqueryStellarTransactionCoinpathDimension = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction Index */
  index: Scalars['Int']['output'];
  /** Time */
  time?: Maybe<BitqueryDateTime>;
  /** Transaction Value From */
  valueFrom?: Maybe<Scalars['Float']['output']>;
  /** Transaction Value To */
  valueTo?: Maybe<Scalars['Float']['output']>;
};

/** Blockchain transaction */
export type BitqueryStellarTransactionDimension = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block */
  index: Scalars['Int']['output'];
  /** Transaction sender */
  sender?: Maybe<Scalars['String']['output']>;
};

export type BitqueryStellarTransactionFilter = {
  block?: InputMaybe<BitqueryBlockSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  index?: InputMaybe<BitqueryIntegerSelector>;
  maxFee?: InputMaybe<BitqueryFloatSelector>;
  memoType?: InputMaybe<BitqueryStringSelector>;
  memos?: InputMaybe<BitqueryStringSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  sequence?: InputMaybe<BitqueryIntegerSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  timeBounds?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryStellarTransactionMeasurable =
  /** Ledger */
  | 'block'
  /** Date */
  | 'date'
  /** fee */
  | 'fee'
  /** Transaction Hash */
  | 'hash'
  /** Transaction Index */
  | 'index'
  /** Max fee */
  | 'maxFee'
  /** Memo type */
  | 'memoType'
  /** Memos */
  | 'memos'
  /** Transaction sender */
  | 'sender'
  /** Sequence */
  | 'sequence'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Time bounds */
  | 'timeBounds';

export type BitqueryStellarTransactionUniq =
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq date count */
  | 'dates'
  /** Uniq transaction hashes count */
  | 'hashes'
  /** Uniq memo types count */
  | 'memoTypes'
  /** Uniq transaction senders */
  | 'senders'
  /** Uniq sequences count */
  | 'sequences';

/** Transfer in Stellar blockchain */
export type BitqueryStellarTransfer = {
  amountFrom?: Maybe<Scalars['Float']['output']>;
  amountTo?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the ledger that this transaction was included in */
  block?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency from of transfer */
  currencyFrom?: Maybe<BitqueryCurrency>;
  /** Currency to of transfer */
  currencyTo?: Maybe<BitqueryCurrency>;
  /** The date this transaction was created */
  date?: Maybe<BitqueryDate>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Operation */
  operation?: Maybe<BitqueryOperationIndexed>;
  /** The account this transaction is been sent to */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** The time this transaction was created */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryStellarTransactionDimension>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferAmountFromArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferAmountToArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferAnyArgs = {
  of: BitqueryStellarTransferMeasurable;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferCountArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTransferUniq>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferCountBigIntArgs = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryStellarTransferUniq>;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferMaximumArgs = {
  get?: InputMaybe<BitqueryStellarTransferMeasurable>;
  of: BitqueryStellarTransferMeasurable;
};


/** Transfer in Stellar blockchain */
export type BitqueryStellarTransferMinimumArgs = {
  get?: InputMaybe<BitqueryStellarTransferMeasurable>;
  of: BitqueryStellarTransferMeasurable;
};

export type BitqueryStellarTransferFilter = {
  amountFrom?: InputMaybe<BitqueryFloatSelector>;
  amountTo?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBlockSelector>;
  currencyFromName?: InputMaybe<BitqueryCurrencySelector>;
  currencyToName?: InputMaybe<BitqueryCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  opIndex?: InputMaybe<BitqueryIntegerSelector>;
  operation?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionIndex?: InputMaybe<BitqueryIntegerSelector>;
  transactionSender?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryStellarTransferMeasurable =
  /** Amount from */
  | 'amountFrom'
  /** Amount to */
  | 'amountTo'
  /** Ledger */
  | 'block'
  /** Currency from name */
  | 'currencyFromName'
  /** Currency from symbol */
  | 'currencyFromSymbol'
  /** Currency to name */
  | 'currencyToName'
  /** Currency to symbol */
  | 'currencyToSymbol'
  /** Date */
  | 'date'
  /** Direction */
  | 'direction'
  /** Operation index */
  | 'opIndex'
  /** Operation */
  | 'operation'
  /** Transfer Receiver */
  | 'receiver'
  /** Transfer Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction Hash */
  | 'transactionHash'
  /** Transaction Index */
  | 'transactionIndex'
  /** Transaction sender */
  | 'transactionSender';

export type BitqueryStellarTransferUniq =
  /** Uniq currency from names */
  | 'currenciesFromName'
  /** Uniq currency from symbols */
  | 'currenciesFromSymbol'
  /** Uniq currency to names */
  | 'currenciesToName'
  /** Uniq currency to symbols */
  | 'currenciesToSymbol'
  /** Uniq dates count */
  | 'dates'
  /** Uniq directions */
  | 'directions'
  /** Uniq operation indices */
  | 'opIndices'
  /** Uniq operations */
  | 'operations'
  /** Uniq transfer receivers */
  | 'receivers'
  /** Uniq transfer senders */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes */
  | 'transactionHashes'
  /** Uniq transaction indices */
  | 'transactionIndices'
  /** Uniq transaction senders */
  | 'transactionSenders';

/** Select by ID */
export type BitqueryStringIdSelector = {
  /** ID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** ID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Select by string */
export type BitqueryStringSelector = {
  /** String in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** String is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** String not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** String not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Search result subject */
export type BitquerySubject = BitqueryAddress | BitqueryCurrency | BitqueryMessageHash | BitquerySmartContract | BitqueryTransactionHash;

/** Tezos Chain */
export type BitqueryTezos = {
  /** Basic information about address */
  address: Array<BitqueryTezosAddressInfoWithBalance>;
  /** Tezos Arguments */
  arguments?: Maybe<Array<BitqueryTezosArgument>>;
  /** Tezos Balance Updates */
  balanceUpdates?: Maybe<Array<BitqueryTezosBalanceUpdate>>;
  /** Tezos Blocks */
  blocks?: Maybe<Array<BitqueryTezosBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryTezosCoinpath>>;
  /** Tezos Operations */
  operations?: Maybe<Array<BitqueryTezosOperation>>;
  /** Tezos Transactions */
  transactions?: Maybe<Array<BitqueryTezosTransaction>>;
  /** Tezos Transfers */
  transfers?: Maybe<Array<BitqueryTezosTransfer>>;
};


/** Tezos Chain */
export type BitqueryTezosAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Tezos Chain */
export type BitqueryTezosArgumentsArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryTezosArgumentFilter>>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Tezos Chain */
export type BitqueryTezosBalanceUpdatesArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  any?: InputMaybe<Array<BitqueryTezosBalanceUpdateFilter>>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Tezos Chain */
export type BitqueryTezosBlocksArgs = {
  any?: InputMaybe<Array<BitqueryTezosBlockFilter>>;
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tezos Chain */
export type BitqueryTezosCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tezos Chain */
export type BitqueryTezosOperationsArgs = {
  any?: InputMaybe<Array<BitqueryTezosOperationFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Tezos Chain */
export type BitqueryTezosTransactionsArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryTezosTransactionFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tezos Chain */
export type BitqueryTezosTransfersArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  any?: InputMaybe<Array<BitqueryTezosTransferFilter>>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

/** Address detailed information for Tezos network */
export type BitqueryTezosAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Wallet balance */
  balance?: Maybe<Array<BitqueryTezosBalance>>;
};

/** Argument in Tezos blockchain */
export type BitqueryTezosArgument = {
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Argname */
  argname?: Maybe<Scalars['String']['output']>;
  /** Argvalue */
  argvalue?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Status */
  status?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentAnyArgs = {
  of: BitqueryTezosArgumentMeasurable;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosArgumentUniq>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosArgumentUniq>;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentMaximumArgs = {
  get?: InputMaybe<BitqueryTezosArgumentMeasurable>;
  of: BitqueryTezosArgumentMeasurable;
};


/** Argument in Tezos blockchain */
export type BitqueryTezosArgumentMinimumArgs = {
  get?: InputMaybe<BitqueryTezosArgumentMeasurable>;
  of: BitqueryTezosArgumentMeasurable;
};

export type BitqueryTezosArgumentFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  argname?: InputMaybe<BitqueryStringSelector>;
  argvalue?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryTezosArgumentMeasurable =
  /** Amount */
  | 'amount'
  /** Argname */
  | 'argname'
  /** Argvalue */
  | 'argvalue'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Date */
  | 'date'
  /** Internal */
  | 'internal'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Status */
  | 'status'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type BitqueryTezosArgumentUniq =
  /** Uniq argnames count */
  | 'argnames'
  /** Uniq argvalues count */
  | 'argvalues'
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq statuses count */
  | 'statuses'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** XTZ Balance */
export type BitqueryTezosBalance = {
  /** Spendable Balance */
  available?: Maybe<Scalars['Float']['output']>;
  /** Delegated Balance */
  delegated?: Maybe<Scalars['Float']['output']>;
  /** Frozen Deposit */
  frozenDeposit?: Maybe<Scalars['Float']['output']>;
  /** Staking Balance */
  staking?: Maybe<Scalars['Float']['output']>;
  /** Total Balance */
  total?: Maybe<Scalars['Float']['output']>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceAvailableArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceDelegatedArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceFrozenDepositArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceStakingArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** XTZ Balance */
export type BitqueryTezosBalanceTotalArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdate = {
  /** Address */
  address?: Maybe<BitqueryAddress>;
  any?: Maybe<Scalars['String']['output']>;
  /** Attribute */
  attribute?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  /** Category */
  category?: Maybe<Scalars['String']['output']>;
  change?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Cycle */
  cycle?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Freezer */
  freezer?: Maybe<Scalars['Boolean']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Kind */
  kind?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Source */
  source?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateAnyArgs = {
  of: BitqueryTezosBalanceUpdateMeasurable;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateChangeArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateCountArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosBalanceUpdateUniq>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateCountBigIntArgs = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosBalanceUpdateUniq>;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateMaximumArgs = {
  get?: InputMaybe<BitqueryTezosBalanceUpdateMeasurable>;
  of: BitqueryTezosBalanceUpdateMeasurable;
};


/** Balance update in Tezos blockchain */
export type BitqueryTezosBalanceUpdateMinimumArgs = {
  get?: InputMaybe<BitqueryTezosBalanceUpdateMeasurable>;
  of: BitqueryTezosBalanceUpdateMeasurable;
};

export type BitqueryTezosBalanceUpdateFilter = {
  address?: InputMaybe<BitqueryAddressSelector>;
  attribute?: InputMaybe<BitqueryStringSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  category?: InputMaybe<BitqueryStringSelector>;
  change?: InputMaybe<BitqueryFloatSelector>;
  cycle?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  freezer?: InputMaybe<BitqueryBooleanSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryTezosBalanceUpdateMeasurable =
  /** Address */
  | 'address'
  /** Attribute */
  | 'attribute'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Category */
  | 'category'
  /** Change */
  | 'change'
  /** Cycle */
  | 'cycle'
  /** Date */
  | 'date'
  /** Freezer */
  | 'freezer'
  /** Internal */
  | 'internal'
  /** Kind */
  | 'kind'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Source */
  | 'source'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type BitqueryTezosBalanceUpdateUniq =
  /** Uniq addresses count */
  | 'addresses'
  /** Uniq attributes count */
  | 'attributes'
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq categories count */
  | 'categories'
  /** Uniq cycles count */
  | 'cycles'
  /** Uniq dates count */
  | 'dates'
  /** Uniq kinds count */
  | 'kinds'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq sources count */
  | 'sources'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** Block in Tezos blockchain */
export type BitqueryTezosBlock = {
  any?: Maybe<Scalars['String']['output']>;
  /** Baker */
  baker?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Header */
  header?: Maybe<Scalars['String']['output']>;
  /** Block number (height) in blockchain */
  height?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockAnyArgs = {
  of: BitqueryTezosBlockMeasurable;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockCountArgs = {
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosBlockUniq>;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockCountBigIntArgs = {
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosBlockUniq>;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockMaximumArgs = {
  get?: InputMaybe<BitqueryTezosBlockMeasurable>;
  of: BitqueryTezosBlockMeasurable;
};


/** Block in Tezos blockchain */
export type BitqueryTezosBlockMinimumArgs = {
  get?: InputMaybe<BitqueryTezosBlockMeasurable>;
  of: BitqueryTezosBlockMeasurable;
};

export type BitqueryTezosBlockFilter = {
  baker?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryTezosBlockMeasurable =
  /** Baker */
  | 'baker'
  /** Date */
  | 'date'
  /** Hash */
  | 'hash'
  /** Header */
  | 'header'
  /** Height */
  | 'height'
  /** Metadata */
  | 'metadata'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Time */
  | 'time';

export type BitqueryTezosBlockUniq =
  /** Uniq bakers count */
  | 'bakers'
  /** Uniq dates count */
  | 'dates'
  /** Uniq hashes count */
  | 'hashes'
  /** Uniq headers count */
  | 'headers'
  /** Uniq heights count */
  | 'heights'
  /** Uniq metadatas count */
  | 'metadatas'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq times count */
  | 'times';

/** Tezos block with hash */
export type BitqueryTezosBlockWithHashDimension = {
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block */
  height: Scalars['BitqueryBigInt']['output'];
};

/** Coinpath */
export type BitqueryTezosCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValue>;
};


/** Coinpath */
export type BitqueryTezosCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryTezosCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTezosCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTezosCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

export type BitqueryTezosNetwork =
  /** Tezos */
  | 'tezos';

/** Operation in Tezos blockchain */
export type BitqueryTezosOperation = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  /** Contents */
  contents?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Kind */
  kind?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Source */
  source?: Maybe<Scalars['String']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationAnyArgs = {
  of: BitqueryTezosOperationMeasurable;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationCountArgs = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosOperationUniq>;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationCountBigIntArgs = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosOperationUniq>;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationMaximumArgs = {
  get?: InputMaybe<BitqueryTezosOperationMeasurable>;
  of: BitqueryTezosOperationMeasurable;
};


/** Operation in Tezos blockchain */
export type BitqueryTezosOperationMinimumArgs = {
  get?: InputMaybe<BitqueryTezosOperationMeasurable>;
  of: BitqueryTezosOperationMeasurable;
};

export type BitqueryTezosOperationFilter = {
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  contents?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryTezosOperationMeasurable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Contents */
  | 'contents'
  /** Date */
  | 'date'
  /** Internal */
  | 'internal'
  /** Kind */
  | 'kind'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Source */
  | 'source'
  /** Success */
  | 'success'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type BitqueryTezosOperationUniq =
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq contents count */
  | 'contents'
  /** Uniq dates count */
  | 'dates'
  /** Uniq kinds count */
  | 'kinds'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq sources count */
  | 'sources'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** Transaction in Tezos blockchain */
export type BitqueryTezosTransaction = {
  /** Allocated destination contract */
  allocatedDestinationContract?: Maybe<Scalars['Boolean']['output']>;
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  burnAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  consumedGas?: Maybe<Scalars['BitqueryBigInt']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination contract */
  destinationContract?: Maybe<Scalars['Boolean']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  gasLimit?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  paidStorageAmount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  paidStorageSizeDiff?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transaction source */
  source?: Maybe<BitqueryAddress>;
  /** Status */
  status?: Maybe<Scalars['String']['output']>;
  storageSize?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionAnyArgs = {
  of: BitqueryTezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionBurnAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionConsumedGasArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionCountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosTransactionUniq>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionCountBigIntArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTezosTransactionUniq>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionFeeArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionGasLimitArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionMaximumArgs = {
  get?: InputMaybe<BitqueryTezosTransactionMeasurable>;
  of: BitqueryTezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionMinimumArgs = {
  get?: InputMaybe<BitqueryTezosTransactionMeasurable>;
  of: BitqueryTezosTransactionMeasurable;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionPaidStorageAmountArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionPaidStorageSizeDiffArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transaction in Tezos blockchain */
export type BitqueryTezosTransactionStorageSizeArgs = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryTezosTransactionFilter = {
  allocatedDestinationContract?: InputMaybe<BitqueryBooleanSelector>;
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  burnAmount?: InputMaybe<BitqueryFloatSelector>;
  consumedGas?: InputMaybe<BitqueryBigIntIdSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  fee?: InputMaybe<BitqueryFloatSelector>;
  gasLimit?: InputMaybe<BitqueryBigIntIdSelector>;
  hash?: InputMaybe<BitqueryHashSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  paidStorageAmount?: InputMaybe<BitqueryFloatSelector>;
  paidStorageSizeDiff?: InputMaybe<BitqueryBigIntIdSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  source?: InputMaybe<BitqueryStringSelector>;
  status?: InputMaybe<BitqueryStringSelector>;
  storageSize?: InputMaybe<BitqueryBigIntIdSelector>;
  success?: InputMaybe<BitqueryBooleanSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};

export type BitqueryTezosTransactionMeasurable =
  /** Allocated destination contract */
  | 'allocatedDestinationContract'
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Burn amount */
  | 'burnAmount'
  /** Consumed gas */
  | 'consumedGas'
  /** Date */
  | 'date'
  /** Destination contract */
  | 'destinationContract'
  /** Fee */
  | 'fee'
  /** Gas limit */
  | 'gasLimit'
  /** Transaction hash */
  | 'hash'
  /** Internal */
  | 'internal'
  /** Op path */
  | 'opPath'
  /** Paid storage amount */
  | 'paidStorageAmount'
  /** Paid storage size diff */
  | 'paid_storage_size_diff'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Transaction source */
  | 'source'
  /** Status */
  | 'status'
  /** Storage size */
  | 'storageSize'
  /** Success */
  | 'success'
  /** Time */
  | 'time';

export type BitqueryTezosTransactionUniq =
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq dates count */
  | 'dates'
  /** Uniq transaction hashes count */
  | 'hashes'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq transaction sources count */
  | 'sources'
  /** Uniq statuses count */
  | 'statuses'
  /** Uniq times count */
  | 'times';

/** Tezos transaction with source */
export type BitqueryTezosTransactionWithSourceDimension = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction source */
  source?: Maybe<Scalars['String']['output']>;
};

/** Transfer in Tezos blockchain */
export type BitqueryTezosTransfer = {
  amount?: Maybe<Scalars['BitqueryDecimalNumberAsDiv']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block */
  block?: Maybe<BitqueryTezosBlockWithHashDimension>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  /** Destination contract */
  destinationContract?: Maybe<Scalars['Boolean']['output']>;
  /** Direction */
  direction?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Internal */
  internal?: Maybe<Scalars['Boolean']['output']>;
  /** Kind */
  kind?: Maybe<Scalars['String']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Op path */
  opPath?: Maybe<Scalars['String']['output']>;
  /** Proto */
  proto?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Protocol */
  protocol?: Maybe<Scalars['String']['output']>;
  /** Receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Sender */
  sender?: Maybe<BitqueryAddress>;
  /** Timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** Transaction */
  transaction?: Maybe<BitqueryTezosTransactionWithSourceDimension>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferAmountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferAnyArgs = {
  of: BitqueryTezosTransferMeasurable;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferCountArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosTransferUniq>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferCountBigIntArgs = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
  uniq?: InputMaybe<BitqueryTezosTransferUniq>;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferMaximumArgs = {
  get?: InputMaybe<BitqueryTezosTransferMeasurable>;
  of: BitqueryTezosTransferMeasurable;
};


/** Transfer in Tezos blockchain */
export type BitqueryTezosTransferMinimumArgs = {
  get?: InputMaybe<BitqueryTezosTransferMeasurable>;
  of: BitqueryTezosTransferMeasurable;
};

export type BitqueryTezosTransferFilter = {
  amount?: InputMaybe<BitqueryFloatSelector>;
  block?: InputMaybe<BitqueryBigIntIdSelector>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  destinationContract?: InputMaybe<BitqueryBooleanSelector>;
  direction?: InputMaybe<BitqueryStringSelector>;
  internal?: InputMaybe<BitqueryBooleanSelector>;
  kind?: InputMaybe<BitqueryStringSelector>;
  opPath?: InputMaybe<BitqueryStringSelector>;
  proto?: InputMaybe<BitqueryBigIntIdSelector>;
  protocol?: InputMaybe<BitqueryStringSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  transactionHash?: InputMaybe<BitqueryHashSelector>;
  transactionSource?: InputMaybe<BitqueryStringSelector>;
};

export type BitqueryTezosTransferMeasurable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Block hash */
  | 'blockHash'
  /** Currency name */
  | 'currencyName'
  /** Currency symbol */
  | 'currencySymbol'
  /** Date */
  | 'date'
  /** Destination contract */
  | 'destinationContract'
  /** Direction */
  | 'direction'
  /** Internal */
  | 'internal'
  /** Kind */
  | 'kind'
  /** Op path */
  | 'opPath'
  /** Proto */
  | 'proto'
  /** Protocol */
  | 'protocol'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'transactionHash'
  /** Transaction source */
  | 'transactionSource';

export type BitqueryTezosTransferUniq =
  /** Uniq block hashes count */
  | 'blockHashes'
  /** Uniq blocks count */
  | 'blocks'
  /** Uniq currency names count */
  | 'currencyNames'
  /** Uniq currency symbols count */
  | 'currencySymbols'
  /** Uniq dates count */
  | 'dates'
  /** Uniq destination contracts count */
  | 'destinationContracts'
  /** Uniq directions count */
  | 'directions'
  /** Uniq kinds count */
  | 'kinds'
  /** Uniq op paths count */
  | 'opPaths'
  /** Uniq protocols count */
  | 'protocols'
  /** Uniq protos count */
  | 'protos'
  /** Uniq receivers count */
  | 'receivers'
  /** Uniq senders count */
  | 'senders'
  /** Uniq times count */
  | 'times'
  /** Uniq transaction hashes count */
  | 'transactionHashes'
  /** Uniq transaction sources count */
  | 'transactionSources';

/** Time Interval */
export type BitqueryTimeInterval = {
  day: Scalars['String']['output'];
  hour: Scalars['String']['output'];
  minute: Scalars['String']['output'];
  month: Scalars['String']['output'];
  second: Scalars['String']['output'];
  year: Scalars['String']['output'];
};


/** Time Interval */
export type BitqueryTimeIntervalDayArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalHourArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalMinuteArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalMonthArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalSecondArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};


/** Time Interval */
export type BitqueryTimeIntervalYearArgs = {
  count?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
};

/** Timestamp */
export type BitqueryTimestamp = {
  /** Nanoseconds */
  nanoseconds: Scalars['BitqueryBigInt']['output'];
  time: Scalars['BitqueryISO8601Date']['output'];
};

/** Select trade by ID */
export type BitqueryTradeIdSelector = {
  /** Trade ID in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Trade ID is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Trade ID not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Trade ID not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryTradeSide =
  /** Buy side */
  | 'BUY'
  /** Sell side */
  | 'SELL';

/** Information about transaction */
export type BitqueryTransactionElrond = {
  /** Shard number of sender */
  data?: Maybe<Scalars['String']['output']>;
  /** Shard number of sender */
  dataOperation?: Maybe<Scalars['String']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Shard number of sender */
  function?: Maybe<Scalars['String']['output']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']['output']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']['output']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']['output']>;
  /** Hash of the receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Hash of the sender */
  sender?: Maybe<BitqueryAddress>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Shard number of sender */
  signature?: Maybe<Scalars['String']['output']>;
  /** Shard number of sender */
  status?: Maybe<Scalars['String']['output']>;
};


/** Information about transaction */
export type BitqueryTransactionElrondFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Blockchain transaction */
export type BitqueryTransactionHash = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
};

/** Blockchain transaction */
export type BitqueryTransactionHashIndex = {
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']['output']>;
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0-based */
  index: Scalars['String']['output'];
};

/** Blockchain transaction with value */
export type BitqueryTransactionHashValue = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction value */
  value: Scalars['Float']['output'];
};

/** Blockchain transaction with value and time */
export type BitqueryTransactionHashValueTime = {
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction time */
  time: BitqueryDateTime;
  /** Transaction value */
  value: Scalars['Float']['output'];
};

/** Transaction result */
export type BitqueryTransactionResult = {
  /** Result ID */
  id: Scalars['Int']['output'];
  /** Result name */
  name: Scalars['String']['output'];
};

/** Identification of transaction source as client application */
export type BitqueryTransactionSource = {
  /** ID numeric */
  code: Scalars['Int']['output'];
  /** Name */
  name: Scalars['String']['output'];
};

/** Select by type of transfer */
export type BitqueryTransferTypeSelector = {
  /** Transfer Type in the list */
  in?: InputMaybe<Array<BitqueryFilecoinTransferType>>;
  /** Transfer Type is */
  is?: InputMaybe<BitqueryFilecoinTransferType>;
  /** Transfer Type not */
  not?: InputMaybe<BitqueryFilecoinTransferType>;
  /** Transfer Type not in the list */
  notIn?: InputMaybe<Array<BitqueryFilecoinTransferType>>;
};

export type BitqueryTransfersUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique currencies */
  | 'currencies'
  /** Unique date count */
  | 'dates'
  /** Unique receivers count */
  | 'receivers'
  /** Unique senders count */
  | 'senders'
  /** Transfers */
  | 'transfers'
  /** Unique transactions count */
  | 'txs';

/** Tron Chain */
export type BitqueryTron = {
  /** Basic information about address ( or smart contract ) */
  address: Array<BitqueryTronAddressInfoWithBalance>;
  /** Blockchain Arguments */
  arguments?: Maybe<Array<BitqueryTronArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitqueryTronBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitqueryTronCoinpath>>;
  /** Blockchain Embedded Contracts */
  contracts?: Maybe<Array<BitqueryTronSmartContracts>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<BitqueryTronDexTrades>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<BitqueryTronSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<BitqueryTronSmartContractEvents>>;
  /** Blockchain Embedded Contracts */
  trades?: Maybe<Array<BitqueryTronTrades>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitqueryTronTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<BitqueryTronTransfers>>;
};


/** Tron Chain */
export type BitqueryTronAddressArgs = {
  address: Array<BitqueryAddressSelectorIn>;
};


/** Tron Chain */
export type BitqueryTronArgumentsArgs = {
  any?: InputMaybe<Array<BitqueryTronArgumentFilter>>;
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Tron Chain */
export type BitqueryTronBlocksArgs = {
  any?: InputMaybe<Array<BitqueryTronBlockFilter>>;
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronCoinpathArgs = {
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  depth?: InputMaybe<BitqueryIntegerLimitedSelector>;
  finalAddress?: InputMaybe<BitqueryAddressSelectorIn>;
  initialAddress?: InputMaybe<BitqueryAddressSelector>;
  initialDate?: InputMaybe<BitqueryDateSelector>;
  initialTime?: InputMaybe<BitqueryDateTimeSelector>;
  options?: InputMaybe<BitqueryCoinpathOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Tron Chain */
export type BitqueryTronContractsArgs = {
  any?: InputMaybe<Array<BitqueryTronContractFilter>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronDexTradesArgs = {
  any?: InputMaybe<Array<BitqueryTronDexTradeFilter>>;
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  options?: InputMaybe<BitqueryQueryOptions>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Tron Chain */
export type BitqueryTronSmartContractCallsArgs = {
  any?: InputMaybe<Array<BitqueryTronSmartContractCallFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronSmartContractEventsArgs = {
  any?: InputMaybe<Array<BitqueryTronSmartContractEventFilter>>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Tron Chain */
export type BitqueryTronTradesArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryTronTradeFilter>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Tron Chain */
export type BitqueryTronTransactionsArgs = {
  any?: InputMaybe<Array<BitqueryTronTransactionFilter>>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Tron Chain */
export type BitqueryTronTransfersArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  any?: InputMaybe<Array<BitqueryTronTransferFilter>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  options?: InputMaybe<BitqueryQueryOptions>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Address detailed information for Tron network */
export type BitqueryTronAddressInfo = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryTronSmartContractInfo>;
};

/** Blockchain address */
export type BitqueryTronAddressInfoWithBalance = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']['output']>;
  /** Balances by currencies for the address */
  balances?: Maybe<Array<BitqueryTronBalance>>;
  /** Rewards that a witness or a user has not yet withdrawn */
  claimableRewards?: Maybe<Scalars['Float']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryTronSmartContractInfo>;
};


/** Blockchain address */
export type BitqueryTronAddressInfoWithBalanceBalanceArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Blockchain address */
export type BitqueryTronAddressInfoWithBalanceBalancesArgs = {
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelectorRange>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blockchain address */
export type BitqueryTronAddressInfoWithBalanceClaimableRewardsArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

export type BitqueryTronArgumentFilter = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export type BitqueryTronArgumentUniq =
  /** Unique Number of block in the blockchains */
  | 'block_height'
  /** Calls */
  | 'calls'
  /** Unique date count */
  | 'dates'
  /** Unique Owners */
  | 'owners'
  /** Unique Receivers */
  | 'receivers'
  /** Unique Transaction Hash */
  | 'signature'
  /** Unique number of arguments */
  | 'smart_contracts'
  /** Unique time */
  | 'times'
  /** Unique Transactions */
  | 'txs'
  /** Unique Values */
  | 'values';

/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArguments = {
  any?: Maybe<Scalars['String']['output']>;
  /** Method or event argument */
  argument?: Maybe<BitqueryArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Float']['output']>;
  /** Owner address */
  owner?: Maybe<BitqueryTronAddressInfo>;
  /** Transaction receiver */
  receiver?: Maybe<BitqueryTronAddressInfo>;
  /** Address value of method or event argument */
  reference?: Maybe<BitqueryTronAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<BitquerySignature>;
  /** Transaction Hash */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Transaction Index */
  txIndex?: Maybe<Scalars['Int']['output']>;
  /** The Value of method or event argument */
  value?: Maybe<BitqueryArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsAnyArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  as?: InputMaybe<BitqueryTronArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryTronArgumentsMeasureable;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsArgumentArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<Scalars['String']['input']>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsCountArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryTronArgumentUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsCountBigIntArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  uniq?: InputMaybe<BitqueryTronArgumentUniq>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsMaximumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  as?: InputMaybe<BitqueryTronArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryTronArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryTronArgumentsMeasureable;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsMinimumArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  as?: InputMaybe<BitqueryTronArgumentsConvertable>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  get?: InputMaybe<BitqueryTronArgumentsMeasureable>;
  height?: InputMaybe<BitqueryBlockSelector>;
  of: BitqueryTronArgumentsMeasureable;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsNumberArgs = {
  argument?: InputMaybe<Array<BitqueryArgumentSelector>>;
  argumentType?: InputMaybe<BitqueryArgumentTypeSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  callDepth?: InputMaybe<BitqueryStringSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  owner?: InputMaybe<BitqueryAddressSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  reference?: InputMaybe<BitqueryAddressSelector>;
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryIntegerSelector>;
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsSmartContractSignatureArgs = {
  signatureType?: InputMaybe<BitquerySignatureTypeSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type BitqueryTronArgumentsValueArgs = {
  value?: InputMaybe<Array<BitqueryArgumentValueSelector>>;
};

export type BitqueryTronArgumentsConvertable =
  /** Token name */
  | 'token_name'
  /** Token symbol */
  | 'token_symbol';

export type BitqueryTronArgumentsMeasureable =
  /** Argument */
  | 'argument'
  /** Argument index */
  | 'argument_index'
  /** Argument type */
  | 'argument_type'
  /** Argument value */
  | 'argument_value'
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Date */
  | 'date'
  /** Owner */
  | 'owner'
  /** Receiver */
  | 'receiver'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract Method Signature */
  | 'signature_type'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction Index */
  | 'tx_index';

/** Balance in a currency */
export type BitqueryTronBalance = {
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<BitqueryTronBalanceChange>>;
  value?: Maybe<Scalars['Float']['output']>;
};


/** Balance in a currency */
export type BitqueryTronBalanceValueArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};

/** Change of balance in a currency */
export type BitqueryTronBalanceChange = {
  /** Block number (height) in blockchain */
  block: Scalars['Int']['output'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['BitqueryISO8601DateTime']['output']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type BitqueryTronBlockFilter = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};

/** Blocks in Tron blockchain */
export type BitqueryTronBlocks = {
  any?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Block hash */
  hash: Scalars['String']['output'];
  /** Block number (height) in blockchain */
  height: Scalars['Int']['output'];
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Parent block hash */
  parentBlockHash: Scalars['String']['output'];
  /** Block timestamp */
  timestamp?: Maybe<BitqueryDateTime>;
  /** TX Trie Root Hash */
  txTrieRoot: Scalars['String']['output'];
  /** Block version */
  version?: Maybe<Scalars['Int']['output']>;
  /** Block witness */
  witness?: Maybe<BitqueryAddress>;
  /** Witness signature */
  witnessSignature: Scalars['String']['output'];
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksAnyArgs = {
  of: BitqueryTronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksCountArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTronBlocksUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksCountBigIntArgs = {
  blockHash?: InputMaybe<BitqueryHashSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  uniq?: InputMaybe<BitqueryTronBlocksUniq>;
  version?: InputMaybe<BitqueryIntegerSelector>;
  witness?: InputMaybe<BitqueryAddressSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksHashArgs = {
  blockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksHeightArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksMaximumArgs = {
  get?: InputMaybe<BitqueryTronBlocksMeasureable>;
  of: BitqueryTronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksMinimumArgs = {
  get?: InputMaybe<BitqueryTronBlocksMeasureable>;
  of: BitqueryTronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksParentBlockHashArgs = {
  parentBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksTimestampArgs = {
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksVersionArgs = {
  version?: InputMaybe<BitqueryIntegerSelector>;
};


/** Blocks in Tron blockchain */
export type BitqueryTronBlocksWitnessArgs = {
  witness?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryTronBlocksMeasureable =
  /** Block */
  | 'block'
  /** Block hash */
  | 'block_hash'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Block Version */
  | 'version'
  /** Block Witness address */
  | 'witness';

export type BitqueryTronBlocksUniq =
  /** Unique date count */
  | 'dates'
  /** Unique witness count */
  | 'witnesses';

export type BitqueryTronCallsMeasureable =
  /** Block */
  | 'block'
  /** Call depth */
  | 'call_depth'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Action To */
  | 'tx_to';

/** Coinpath */
export type BitqueryTronCoinpath = {
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']['output']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Receiver address */
  receiver?: Maybe<BitqueryTronCoinpathAddress>;
  /** Sender address */
  sender?: Maybe<BitqueryTronCoinpathAddress>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitqueryTransactionHashValueTime>;
};


/** Coinpath */
export type BitqueryTronCoinpathAmountArgs = {
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Coinpath */
export type BitqueryTronCoinpathAnyArgs = {
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTronCoinpathMaximumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};


/** Coinpath */
export type BitqueryTronCoinpathMinimumArgs = {
  get?: InputMaybe<BitqueryCoinpathMeasureable>;
  of: BitqueryCoinpathMeasureable;
};

/** Address detailed information for Ethereum network */
export type BitqueryTronCoinpathAddress = {
  /** Address */
  address?: Maybe<Scalars['String']['output']>;
  amountIn?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  amountOut?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']['output']>;
  balance?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** Smart Contract if exists on the address */
  firstTxAt?: Maybe<BitqueryDateTime>;
  /** Smart Contract if exists on the address */
  lastTxAt?: Maybe<BitqueryDateTime>;
  receiversCount?: Maybe<Scalars['Int']['output']>;
  sendersCount?: Maybe<Scalars['Int']['output']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<BitqueryTronSmartContractInfo>;
  /** Address type */
  type?: Maybe<Scalars['String']['output']>;
};

export type BitqueryTronContractFilter = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};

/** Select contract type(s) */
export type BitqueryTronContractTypeSelector = {
  /** Contract type in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contract type is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Contract type not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Contract type not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BitqueryTronContractsMeasureable =
  /** Block */
  | 'block'
  /** Contract */
  | 'contract_type'
  /** Date */
  | 'date'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash'
  /** Transaction owner */
  | 'tx_owner';

/**
 * Currency selector in Tron blockchain.
 * Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
 */
export type BitqueryTronCurrencySelector = {
  /** Currency in the list */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Currency is */
  is?: InputMaybe<Scalars['String']['input']>;
  /** Currency not */
  not?: InputMaybe<Scalars['String']['input']>;
  /** Currency not in the list */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Tron DEX attributes */
export type BitqueryTronDex = {
  /** Address for DEX exchange identification */
  address: BitqueryAddress;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String']['output'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String']['output'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']['output']>;
};

export type BitqueryTronDexTradeFilter = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Trades on DEX smart contracts */
export type BitqueryTronDexTrades = {
  /** Trader (maker or taker) */
  address?: Maybe<BitqueryTronAddressInfo>;
  any?: Maybe<Scalars['String']['output']>;
  baseAmount?: Maybe<Scalars['Float']['output']>;
  /** Base currency */
  baseCurrency?: Maybe<BitqueryCurrency>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlockExtended>;
  buyAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<BitqueryCurrency>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyFee?: Maybe<Scalars['Float']['output']>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<BitqueryTronDex>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  internalTransactionsCount?: Maybe<Scalars['Int']['output']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  logsCount?: Maybe<Scalars['Int']['output']>;
  logsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Trade 'maker' side */
  maker?: Maybe<BitqueryTronAddressInfo>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netFee?: Maybe<Scalars['Float']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']['output']>;
  quoteAmount?: Maybe<Scalars['Float']['output']>;
  /** Quote currency */
  quoteCurrency?: Maybe<BitqueryCurrency>;
  quotePrice?: Maybe<Scalars['Float']['output']>;
  sellAmount?: Maybe<Scalars['Float']['output']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<BitqueryTradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<BitqueryTronAddressInfo>;
  /** Time interval */
  timeInterval?: Maybe<BitqueryTimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']['output']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']['output']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<BitqueryTronTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesAddressArgs = {
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesAnyArgs = {
  of: BitqueryTronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBaseAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBaseCurrencyArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBuyAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesBuyCurrencyArgs = {
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesEnergyFeeArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesEnergyUsageTotalArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesExchangeArgs = {
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesFeeArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesInternalTransactionsCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesInternalTransactionsCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesLogsCountArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesLogsCountBigIntArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesMakerArgs = {
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesMaximumArgs = {
  get?: InputMaybe<BitqueryTronDexTradesMeasureable>;
  of: BitqueryTronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesMinimumArgs = {
  get?: InputMaybe<BitqueryTronDexTradesMeasureable>;
  of: BitqueryTronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesNetFeeArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesNetUsageArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesPriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesProtocolArgs = {
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesQuoteAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesQuoteCurrencyArgs = {
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesQuotePriceArgs = {
  baseCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  buyAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  calculate?: InputMaybe<BitqueryPriceAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  exchangeName?: InputMaybe<Array<BitqueryStringSelector>>;
  height?: InputMaybe<BitqueryBlockSelector>;
  maker?: InputMaybe<Array<BitqueryAddressSelector>>;
  makerOrTaker?: InputMaybe<Array<BitqueryAddressSelector>>;
  price?: InputMaybe<Array<BitqueryAmountSelector>>;
  priceAsymmetry?: InputMaybe<Array<BitqueryFloatSelector>>;
  protocol?: InputMaybe<Array<BitqueryStringSelector>>;
  quoteCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  sellAmount?: InputMaybe<Array<BitqueryAmountSelector>>;
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  tradeAmountUsd?: InputMaybe<Array<BitqueryFloatSelector>>;
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesSellAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesSellCurrencyArgs = {
  sellCurrency?: InputMaybe<Array<BitqueryTronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesSmartContractArgs = {
  smartContractAddress?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTakerArgs = {
  taker?: InputMaybe<Array<BitqueryAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTradeAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  in: BitqueryBaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTradeIndexArgs = {
  tradeIndex?: InputMaybe<Array<BitqueryStringSelector>>;
};


/** Trades on DEX smart contracts */
export type BitqueryTronDexTradesTransactionArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};

export type BitqueryTronDexTradesMeasureable =
  /** Block */
  | 'block'
  /** Buy Amount */
  | 'buy_amount'
  /** Buy Token address */
  | 'buy_currency_address'
  /** Buy Currency symbol */
  | 'buy_currency_symbol'
  /** Date */
  | 'date'
  /** Maker */
  | 'maker'
  /** Price */
  | 'price'
  /** Quote Price */
  | 'quote_price'
  /** Sell Amount */
  | 'sell_amount'
  /** Sell Token address */
  | 'sell_currency_address'
  /** Sell Currency symbol */
  | 'sell_currency_symbol'
  /** Taker */
  | 'taker'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryTronDexTradesUniq =
  /** Unique makers & takers count */
  | 'address'
  /** Base currencies count */
  | 'base_currency'
  /** Unique blocks */
  | 'blocks'
  /** Buy currencies count */
  | 'buy_currency'
  /** Unique date count */
  | 'dates'
  /** Unique makers count */
  | 'makers'
  /** Unique protocols count */
  | 'protocols'
  /** Quote currencies count */
  | 'quote_currency'
  /** Sell currencies count */
  | 'sell_currency'
  /** Unique smart contract count */
  | 'smart_contracts'
  /** Unique makers count */
  | 'takers'
  /** Unique transactions count */
  | 'txs';

export type BitqueryTronEventsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Smart Contract Method Signature */
  | 'signature'
  /** Smart Contract Method Signature Hash */
  | 'signature_hash'
  /** Smart Contract Method Name */
  | 'signature_name'
  /** Smart Contract */
  | 'smart_contract'
  /** Time */
  | 'time'
  /** Action From */
  | 'tx_from'
  /** Transaction hash */
  | 'tx_hash'
  /** Action To */
  | 'tx_to';

export type BitqueryTronNetwork =
  /** TRON mainnet */
  | 'tron';

/** Tron smart contract */
export type BitqueryTronSmartContract = {
  /** Smart Contract Address */
  address: BitqueryAddress;
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

export type BitqueryTronSmartContractCallFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Smart Contract Calls */
export type BitqueryTronSmartContractCalls = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Smart contract being called */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<BitqueryMethod>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsAnyArgs = {
  of: BitqueryTronCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsEnergyUsageTotalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsMaximumArgs = {
  get?: InputMaybe<BitqueryTronCallsMeasureable>;
  of: BitqueryTronCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsMinimumArgs = {
  get?: InputMaybe<BitqueryTronCallsMeasureable>;
  of: BitqueryTronCallsMeasureable;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsNetUsageArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  date?: InputMaybe<BitqueryDateSelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsSmartContractArgs = {
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: InputMaybe<BitqueryMethodSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Calls */
export type BitqueryTronSmartContractCallsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryTronSmartContractEventFilter = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Smart Contract Events */
export type BitqueryTronSmartContractEvents = {
  any?: Maybe<Scalars['String']['output']>;
  /** Call arguments */
  arguments?: Maybe<Array<BitqueryArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  /** Smart contract being Evented */
  smartContract?: Maybe<BitqueryTronSmartContract>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<BitqueryEvent>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsAnyArgs = {
  of: BitqueryTronEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsCountArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsCountBigIntArgs = {
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsMaximumArgs = {
  get?: InputMaybe<BitqueryTronEventsMeasureable>;
  of: BitqueryTronEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsMinimumArgs = {
  get?: InputMaybe<BitqueryTronEventsMeasureable>;
  of: BitqueryTronEventsMeasureable;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsSmartContractArgs = {
  smartContractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsSmartContractEventArgs = {
  smartContractEvent?: InputMaybe<BitqueryEventSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Smart Contract Events */
export type BitqueryTronSmartContractEventsTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Blockchain smart contract */
export type BitqueryTronSmartContractInfo = {
  /** Smart Contract Type */
  contractType?: Maybe<BitquerySmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<BitqueryScCurrency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']['output']>;
};

/** Contracts */
export type BitqueryTronSmartContracts = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block in the blockchain */
  block?: Maybe<BitqueryBlock>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']['output']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']['output']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Transactio owner from address */
  txOwner?: Maybe<BitqueryAddress>;
};


/** Contracts */
export type BitqueryTronSmartContractsAmountArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsAnyArgs = {
  of: BitqueryTronContractsMeasureable;
};


/** Contracts */
export type BitqueryTronSmartContractsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsContractTypeArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsCountArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Contracts */
export type BitqueryTronSmartContractsCountBigIntArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitquerySmartContractCallsUniq>;
};


/** Contracts */
export type BitqueryTronSmartContractsCurrencyArgs = {
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsEnergyUsageTotalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Contracts */
export type BitqueryTronSmartContractsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsMaximumArgs = {
  get?: InputMaybe<BitqueryTronContractsMeasureable>;
  of: BitqueryTronContractsMeasureable;
};


/** Contracts */
export type BitqueryTronSmartContractsMinimumArgs = {
  get?: InputMaybe<BitqueryTronContractsMeasureable>;
  of: BitqueryTronContractsMeasureable;
};


/** Contracts */
export type BitqueryTronSmartContractsNetUsageArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsSuccessArgs = {
  success?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};


/** Contracts */
export type BitqueryTronSmartContractsTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Contracts */
export type BitqueryTronSmartContractsTxOwnerArgs = {
  txOwner?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryTronTradeFilter = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};

/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTrades = {
  amountBuy?: Maybe<Scalars['Float']['output']>;
  amountSell?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where Trade transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Buy Currency of Trade */
  buyCurrency?: Maybe<BitqueryCurrency>;
  /** Trade buyer */
  buyer?: Maybe<BitqueryAddress>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** exchange_id */
  exchangeId?: Maybe<Scalars['Int']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Sell Currency of Trade */
  sellCurrency?: Maybe<BitqueryCurrency>;
  /** Trade seller */
  seller?: Maybe<BitqueryAddress>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Transaction hash where Trade happened */
  txHash?: Maybe<Scalars['String']['output']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesAmountBuyArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesAmountSellArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesAnyArgs = {
  of: BitqueryTronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesBuyCurrencyArgs = {
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesBuyerArgs = {
  buyer?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesContractTypeArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesCountArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesCountBigIntArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  uniq?: InputMaybe<BitqueryTronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesEnergyUsageTotalArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesExchangeIdArgs = {
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesFeeArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesMaximumArgs = {
  get?: InputMaybe<BitqueryTronTradesMeasureable>;
  of: BitqueryTronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesMinimumArgs = {
  get?: InputMaybe<BitqueryTronTradesMeasureable>;
  of: BitqueryTronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesNetUsageArgs = {
  amountBuy?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountSell?: InputMaybe<Array<BitqueryAmountSelector>>;
  buyCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  buyer?: InputMaybe<BitqueryAddressSelector>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  exchangeId?: InputMaybe<BitqueryIntIdSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
  seller?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesSellCurrencyArgs = {
  sellCurrency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesSellerArgs = {
  seller?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type BitqueryTronTradesTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};

export type BitqueryTronTradesMeasureable =
  /** Amount Sell */
  | 'amount_buy'
  /** Amount Sell */
  | 'amount_sell'
  /** Block */
  | 'block'
  /** Buy Token address */
  | 'buy_currency_address'
  /** Buy Currency name */
  | 'buy_currency_name'
  /** Buy Currency symbol */
  | 'buy_currency_symbol'
  /** Buy Token address */
  | 'buy_token_id'
  /** Buy Token type */
  | 'buy_token_type'
  /** Buyer */
  | 'buyer'
  /** Contract Type */
  | 'contract_type'
  /** Date */
  | 'date'
  /** Exchange ID */
  | 'exchange_id'
  /** Buy Token address */
  | 'sell_currency_address'
  /** Buy Currency name */
  | 'sell_currency_name'
  /** Buy Currency symbol */
  | 'sell_currency_symbol'
  /** Buy Token address */
  | 'sell_token_id'
  /** Buy Token type */
  | 'sell_token_type'
  /** Seller */
  | 'seller'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryTronTradesUniq =
  /** Unique blocks */
  | 'blocks'
  /** Buy currencies */
  | 'buy_currencies'
  /** Buyers count */
  | 'buyers'
  /** Unique date count */
  | 'dates'
  /** Exchange IDs */
  | 'exchanges'
  /** Sell currencies */
  | 'sell_currencies'
  /** Sellers count */
  | 'sellers'
  /** Unique transactions count */
  | 'txs';

export type BitqueryTronTransactionFilter = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};

/** Blockchain Transaction Extended info */
export type BitqueryTronTransactionInfoExtended = {
  /** Contract Address */
  contractAddress?: Maybe<BitqueryAddress>;
  /** Expiration */
  expiration: Scalars['BitqueryBigInt']['output'];
  /** Fee Limit */
  feeLimit: Scalars['Int']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String']['output'];
  /** Result message */
  result?: Maybe<Scalars['String']['output']>;
  /** Signatures */
  signatures: Scalars['String']['output'];
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** Transactions in Tron blockchain */
export type BitqueryTronTransactions = {
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Contract Address */
  contractAddress?: Maybe<BitqueryAddress>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyFee?: Maybe<Scalars['Float']['output']>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** Expiration */
  expiration: Scalars['Int']['output'];
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  /** Fee Limit */
  feeLimit: Scalars['Int']['output'];
  /** Hash hex representation */
  hash: Scalars['String']['output'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']['output']>;
  internalTransactionsCount?: Maybe<Scalars['Int']['output']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  logsCount?: Maybe<Scalars['Int']['output']>;
  logsCountBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netFee?: Maybe<Scalars['Float']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String']['output'];
  /** Result message */
  result?: Maybe<Scalars['String']['output']>;
  /** Signatures */
  signatures: Scalars['String']['output'];
  /** Success */
  success?: Maybe<Scalars['Boolean']['output']>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsAnyArgs = {
  of: BitqueryTronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsContractAddressArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsCountArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryTronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsCountBigIntArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
  uniq?: InputMaybe<BitqueryTronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsEnergyFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsEnergyUsageTotalArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsHashArgs = {
  txHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsIndexArgs = {
  txIndex?: InputMaybe<Array<BitqueryTxIndexSelector>>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsInternalTransactionsCountArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsInternalTransactionsCountBigIntArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsLogsCountArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsLogsCountBigIntArgs = {
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsMaximumArgs = {
  get?: InputMaybe<BitqueryTronTransactionsMeasureable>;
  of: BitqueryTronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsMinimumArgs = {
  get?: InputMaybe<BitqueryTronTransactionsMeasureable>;
  of: BitqueryTronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsNetFeeArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsNetUsageArgs = {
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractAddress?: InputMaybe<BitqueryAddressSelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  height?: InputMaybe<BitqueryBlockSelector>;
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txIndex?: InputMaybe<BitqueryTxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsRefBlockHashArgs = {
  refBlockHash?: InputMaybe<Array<BitqueryHashSelector>>;
};


/** Transactions in Tron blockchain */
export type BitqueryTronTransactionsSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BitqueryTronTransactionsMeasureable =
  /** Block */
  | 'block'
  /** Date */
  | 'date'
  /** Energy Fee */
  | 'energy_fee'
  /** Fee */
  | 'fee'
  /** Fee Limit */
  | 'fee_limit'
  /** Internal transactions count */
  | 'internal_transactions_count'
  /** Net usage */
  | 'net_usage'
  /** Time */
  | 'time'
  /** Transaction hash */
  | 'tx_hash';

export type BitqueryTronTransactionsUniq =
  /** Unique blocks */
  | 'blocks'
  /** Unique date count */
  | 'dates';

export type BitqueryTronTransferFilter = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfers = {
  amount?: Maybe<Scalars['Float']['output']>;
  any?: Maybe<Scalars['String']['output']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BitqueryBlock>;
  /** Contract type */
  contractType?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  countBigInt?: Maybe<Scalars['BitqueryBigInt']['output']>;
  /** Currency of transfer */
  currency?: Maybe<BitqueryCurrency>;
  /** Calendar date */
  date?: Maybe<BitqueryDate>;
  energyUsageTotal?: Maybe<Scalars['Float']['output']>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']['output']>;
  expression?: Maybe<Scalars['BitqueryDecimalNumber']['output']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']['output']>;
  fee?: Maybe<Scalars['Float']['output']>;
  maximum?: Maybe<Scalars['String']['output']>;
  minimum?: Maybe<Scalars['String']['output']>;
  netUsage?: Maybe<Scalars['Float']['output']>;
  /** Transfer receiver */
  receiver?: Maybe<BitqueryAddress>;
  /** Transfer sender */
  sender?: Maybe<BitqueryAddress>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']['output']>;
  /** Action from address */
  txFrom?: Maybe<BitqueryAddress>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']['output']>;
  /** Action to address */
  txTo?: Maybe<BitqueryAddress>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersAmountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersAnyArgs = {
  of: BitqueryTronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersBlockArgs = {
  height?: InputMaybe<BitqueryBlockSelector>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersContractTypeArgs = {
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersCountArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersCountBigIntArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
  uniq?: InputMaybe<BitqueryTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersCurrencyArgs = {
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersEnergyUsageTotalArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersEntityIdArgs = {
  entityId?: InputMaybe<BitqueryEntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersExpressionArgs = {
  get: Scalars['String']['input'];
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersExternalArgs = {
  external?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersFeeArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  in?: InputMaybe<BitqueryBaseCurrencyEnum>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersMaximumArgs = {
  get?: InputMaybe<BitqueryTronTransfersMeasureable>;
  of: BitqueryTronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersMinimumArgs = {
  get?: InputMaybe<BitqueryTronTransfersMeasureable>;
  of: BitqueryTronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersNetUsageArgs = {
  amount?: InputMaybe<Array<BitqueryAmountSelector>>;
  amountInUSD?: InputMaybe<Array<BitqueryAmountSelector>>;
  calculate?: InputMaybe<BitqueryAmountAggregateFunction>;
  contractType?: InputMaybe<BitqueryTronContractTypeSelector>;
  currency?: InputMaybe<BitqueryTronCurrencySelector>;
  date?: InputMaybe<BitqueryDateSelector>;
  entityId?: InputMaybe<BitqueryEntitySelector>;
  external?: InputMaybe<Scalars['Boolean']['input']>;
  height?: InputMaybe<BitqueryBlockSelector>;
  receiver?: InputMaybe<BitqueryAddressSelector>;
  sender?: InputMaybe<BitqueryAddressSelector>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<BitqueryDateTimeSelector>;
  txFrom?: InputMaybe<BitqueryAddressSelector>;
  txHash?: InputMaybe<BitqueryHashSelector>;
  txTo?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersReceiverArgs = {
  receiver?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersSenderArgs = {
  sender?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersSuccessArgs = {
  success?: InputMaybe<Scalars['Boolean']['input']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersTxFromArgs = {
  txFrom?: InputMaybe<BitqueryAddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersTxHashArgs = {
  txHash?: InputMaybe<BitqueryHashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BitqueryTronTransfersTxToArgs = {
  txTo?: InputMaybe<BitqueryAddressSelector>;
};

export type BitqueryTronTransfersMeasureable =
  /** Amount */
  | 'amount'
  /** Block */
  | 'block'
  /** Token address */
  | 'currency_address'
  /** Currency symbol */
  | 'currency_symbol'
  /** Date */
  | 'date'
  /** Receiver */
  | 'receiver'
  /** Sender */
  | 'sender'
  /** Time */
  | 'time'
  /** Token ID */
  | 'token_id'
  /** Token type */
  | 'token_type'
  /** Transaction hash */
  | 'tx_hash';

/** Selector of index of transaction in block */
export type BitqueryTxIndexSelector = {
  /** Tx index in the list */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Tx index is */
  is?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not */
  not?: InputMaybe<Scalars['Int']['input']>;
  /** Tx index not in the list */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Select transactions by subtype */
export type BitqueryTxSubtypeSelector = {
  /** Transaction SubType in the list */
  in?: InputMaybe<Array<BitqueryAlgorandTxSubType>>;
  /** Transaction SubType is */
  is?: InputMaybe<BitqueryAlgorandTxSubType>;
  /** Transaction SubType not */
  not?: InputMaybe<BitqueryAlgorandTxSubType>;
  /** Transaction SubType not in the list */
  notIn?: InputMaybe<Array<BitqueryAlgorandTxSubType>>;
};

/** Select transactions by type */
export type BitqueryTxTypeSelector = {
  /** Transaction Type in the list */
  in?: InputMaybe<Array<BitqueryAlgorandTxType>>;
  /** Transaction Type is */
  is?: InputMaybe<BitqueryAlgorandTxType>;
  /** Transaction Type not */
  not?: InputMaybe<BitqueryAlgorandTxType>;
  /** Transaction Type not in the list */
  notIn?: InputMaybe<Array<BitqueryAlgorandTxType>>;
};

/** Utilities */
export type BitqueryUtilities = {
  /** Active period */
  activePeriod?: Maybe<BitqueryActivePeriod>;
  /** Query metrics */
  metrics?: Maybe<BitqueryMetrics>;
};


/** Utilities */
export type BitqueryUtilitiesActivePeriodArgs = {
  apiKey: Scalars['String']['input'];
  options?: InputMaybe<BitquerySeedOptions>;
};


/** Utilities */
export type BitqueryUtilitiesMetricsArgs = {
  options?: InputMaybe<BitquerySeedOptions>;
  queryId: Scalars['String']['input'];
};

/** UtilitiesDate */
export type BitqueryUtilitiesDate = {
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String']['output'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int']['output'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int']['output'];
  /** Month number (1-12) */
  month: Scalars['Int']['output'];
  /** Year number */
  year: Scalars['Int']['output'];
};

export type CoinapiModelVwap24RefRate = {
  asset?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  time?: Maybe<Scalars['String']['output']>;
  volume?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiModelsExchangeTimeseriesItem = {
  priceClose?: Maybe<Scalars['Float']['output']>;
  priceHigh?: Maybe<Scalars['Float']['output']>;
  priceLow?: Maybe<Scalars['Float']['output']>;
  priceOpen?: Maybe<Scalars['Float']['output']>;
  symbolIdCoinapi?: Maybe<Scalars['String']['output']>;
  symbolIdExchange?: Maybe<Scalars['String']['output']>;
  timeClose?: Maybe<Scalars['String']['output']>;
  timeOpen?: Maybe<Scalars['String']['output']>;
  timePeriodEnd?: Maybe<Scalars['String']['output']>;
  timePeriodStart?: Maybe<Scalars['String']['output']>;
  tradesCount?: Maybe<Scalars['Int']['output']>;
  volumeTraded?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiMutation = {};

export type CoinapiQuery = {
  modelsExchangeTimeseriesItems?: Maybe<Array<CoinapiModelsExchangeTimeseriesItem>>;
  v1ExchangeRate?: Maybe<CoinapiV1ExchangeRate>;
  v1ExchangeRatesRates?: Maybe<Array<CoinapiV1ExchangeRatesRate>>;
  v1ExchangeRatesTimeseriesItems?: Maybe<Array<CoinapiV1ExchangeRatesTimeseriesItem>>;
  v1IndexData?: Maybe<CoinapiV1IndexData>;
  v1IndexValues?: Maybe<Array<CoinapiV1IndexValue>>;
  v1Indexes?: Maybe<Array<CoinapiV1Index>>;
  v1Metrics?: Maybe<Array<CoinapiV1Metric>>;
  v1OrderBookBases?: Maybe<Array<CoinapiV1OrderBookBase>>;
  v1OrderBookDepth?: Maybe<CoinapiV1OrderBookDepth>;
  v1QuoteTrade?: Maybe<CoinapiV1QuoteTrade>;
  v1QuoteTrades?: Maybe<Array<CoinapiV1QuoteTrade>>;
  v1SymbolMappings?: Maybe<Array<CoinapiV1SymbolMapping>>;
};


export type CoinapiQueryModelsExchangeTimeseriesItemsArgs = {
  exchangeId: Scalars['String']['input'];
  periodId: Scalars['String']['input'];
  timeEnd: Scalars['String']['input'];
  timeStart: Scalars['String']['input'];
};


export type CoinapiQueryV1ExchangeRateArgs = {
  assetIdBase: Scalars['String']['input'];
  assetIdQuote: Scalars['String']['input'];
  time?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1ExchangeRatesRatesArgs = {
  assetIdBase: Scalars['String']['input'];
  filterAssetId?: InputMaybe<Scalars['String']['input']>;
  invert?: InputMaybe<Scalars['Boolean']['input']>;
  time?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1ExchangeRatesTimeseriesItemsArgs = {
  assetIdBase: Scalars['String']['input'];
  assetIdQuote: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  periodId?: InputMaybe<Scalars['String']['input']>;
  timeEnd?: InputMaybe<Scalars['String']['input']>;
  timeStart?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1IndexDataArgs = {
  indexId: Scalars['String']['input'];
};


export type CoinapiQueryV1IndexValuesArgs = {
  indexId: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  timeEnd?: InputMaybe<Scalars['String']['input']>;
  timeStart?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1OrderBookBasesArgs = {
  filterSymbolId?: InputMaybe<Scalars['String']['input']>;
  limitLevels?: InputMaybe<Scalars['Int']['input']>;
};


export type CoinapiQueryV1OrderBookDepthArgs = {
  limitLevels?: InputMaybe<Scalars['Int']['input']>;
  symbolId: Scalars['String']['input'];
};


export type CoinapiQueryV1QuoteTradeArgs = {
  symbolId: Scalars['String']['input'];
};


export type CoinapiQueryV1QuoteTradesArgs = {
  filterSymbolId?: InputMaybe<Scalars['String']['input']>;
};


export type CoinapiQueryV1SymbolMappingsArgs = {
  exchangeId: Scalars['String']['input'];
};

export type CoinapiV1ExchangeRate = {
  assetIdBase?: Maybe<Scalars['String']['output']>;
  assetIdQuote?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  srcSideBase?: Maybe<Array<CoinapiModelVwap24RefRate>>;
  srcSideQuote?: Maybe<Array<CoinapiModelVwap24RefRate>>;
  time?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1ExchangeRatesRate = {
  assetIdQuote?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
  time?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1ExchangeRatesTimeseriesItem = {
  rateClose?: Maybe<Scalars['Float']['output']>;
  rateHigh?: Maybe<Scalars['Float']['output']>;
  rateLow?: Maybe<Scalars['Float']['output']>;
  rateOpen?: Maybe<Scalars['Float']['output']>;
  timeClose?: Maybe<Scalars['String']['output']>;
  timeOpen?: Maybe<Scalars['String']['output']>;
  timePeriodEnd?: Maybe<Scalars['String']['output']>;
  timePeriodStart?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1Index = {
  description?: Maybe<Scalars['String']['output']>;
  indexId?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1IndexData = {
  components?: Maybe<Array<CoinapiV1IndexDataComponent>>;
  description?: Maybe<Scalars['String']['output']>;
  indexId?: Maybe<Scalars['String']['output']>;
  indexMethod?: Maybe<Scalars['String']['output']>;
  indexMethodParameters?: Maybe<Scalars['JSON']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notifyEmails?: Maybe<Scalars['String']['output']>;
  periodRecalculation?: Maybe<Scalars['String']['output']>;
  visibilityPublic?: Maybe<Scalars['Boolean']['output']>;
};

export type CoinapiV1IndexDataComponent = {
  componentId?: Maybe<Scalars['String']['output']>;
  evaluationMethod?: Maybe<Scalars['String']['output']>;
  evaluationMethodParameters?: Maybe<Scalars['JSON']['output']>;
};

export type CoinapiV1IndexValue = {
  composition?: Maybe<Array<CoinapiV1IndexValueComponent>>;
  timestamp?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiV1IndexValueComponent = {
  componentId?: Maybe<Scalars['String']['output']>;
  componentValue?: Maybe<Scalars['Float']['output']>;
};

export type CoinapiV1LastTrade = {
  price?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
  takerSide?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1Metric = {
  description?: Maybe<Scalars['String']['output']>;
  metricId?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1OrderBookBase = {
  symbolId?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1OrderBookDepth = {
  askDepth?: Maybe<Scalars['Float']['output']>;
  askLevels?: Maybe<Scalars['Int']['output']>;
  bidDepth?: Maybe<Scalars['Float']['output']>;
  bidLevels?: Maybe<Scalars['Int']['output']>;
  symbolId?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1QuoteTrade = {
  askPrice?: Maybe<Scalars['Float']['output']>;
  askSize?: Maybe<Scalars['Float']['output']>;
  bidPrice?: Maybe<Scalars['Float']['output']>;
  bidSize?: Maybe<Scalars['Float']['output']>;
  lastTrade?: Maybe<CoinapiV1LastTrade>;
  symbolId?: Maybe<Scalars['String']['output']>;
  timeCoinapi?: Maybe<Scalars['String']['output']>;
  timeExchange?: Maybe<Scalars['String']['output']>;
};

export type CoinapiV1SymbolMapping = {
  assetIdBase?: Maybe<Scalars['String']['output']>;
  assetIdBaseExchange?: Maybe<Scalars['String']['output']>;
  assetIdQuote?: Maybe<Scalars['String']['output']>;
  assetIdQuoteExchange?: Maybe<Scalars['String']['output']>;
  pricePrecision?: Maybe<Scalars['Float']['output']>;
  sizePrecision?: Maybe<Scalars['Float']['output']>;
  symbolId?: Maybe<Scalars['String']['output']>;
  symbolIdExchange?: Maybe<Scalars['String']['output']>;
};

export type Mutation = {
  coinapi: CoinapiMutation;
};

export type Query = {
  /** Access to embedded bitquery API. */
  bitquery: BitqueryQuery;
  coinapi: CoinapiQuery;
};

export type BitcoinQueryVariables = Exact<{ [key: string]: never; }>;


export type BitcoinQuery = { bitquery: { bitcoin?: { blocks?: Array<{ count?: number | null }> | null } | null } };


export const BitcoinDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Bitcoin"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"bitquery"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"bitcoin"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"blocks"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}}]}}]}}]} as unknown as DocumentNode<BitcoinQuery, BitcoinQueryVariables>;